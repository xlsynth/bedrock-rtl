
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_cdc_fifo_ctrl_1r1w
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-17 22:25:50
// Description: Unit test for br_cdc_fifo_ctrl_1r1w
//=============================================================



module br_cdc_fifo_ctrl_1r1w_gen_unittest;
  timeunit 1ns; timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;  // Clock frequency in MHz
  parameter int RESET_DURATION = 100;  // Reset duration in ns
  parameter int TIMEOUT = 10000000;  // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000;  // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;  // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000;  // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks

  //===========================================================
  // DUT Imports and Includes
  //===========================================================

  `include "br_asserts_internal.svh"
  `include "br_gates.svh"

  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int Depth = 2;
  parameter int Width = 1;
  parameter bit RegisterPopOutputs = 0;
  parameter bit RegisterResetActive = 1;
  parameter int RamWriteLatency = 1;
  parameter int RamReadLatency = 0;
  parameter int NumSyncStages = 3;
  parameter bit EnableCoverPushBackpressure = 1;
  parameter bit EnableAssertPushValidStability = EnableCoverPushBackpressure;
  parameter bit EnableAssertPushDataStability = EnableAssertPushValidStability;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int AddrWidth = $clog2(Depth);
  localparam int CountWidth = $clog2((Depth + 1));

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic                  push_clk;
  logic                  pop_clk;
  logic                  push_rst;
  logic                  pop_rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic                  push_valid;
  logic [     Width-1:0] push_data;
  logic                  pop_ready;
  logic                  pop_ram_rd_data_valid;
  logic [     Width-1:0] pop_ram_rd_data;
  logic                  push_ready;
  logic                  push_full;
  logic [CountWidth-1:0] push_slots;
  logic                  push_ram_wr_valid;
  logic [ AddrWidth-1:0] push_ram_wr_addr;
  logic [     Width-1:0] push_ram_wr_data;
  logic                  pop_valid;
  logic [     Width-1:0] pop_data;
  logic                  pop_empty;
  logic [CountWidth-1:0] pop_items;
  logic                  pop_ram_rd_addr_valid;
  logic [ AddrWidth-1:0] pop_ram_rd_addr;

  //===========================================================
  // DUT Instantiation
  //===========================================================
  // Clock to DUT is inverted to avoid race condition between DUT and TB
  br_cdc_fifo_ctrl_1r1w #(
      .Depth(Depth),
      .Width(Width),
      .RegisterPopOutputs(RegisterPopOutputs),
      .RegisterResetActive(RegisterResetActive),
      .RamWriteLatency(RamWriteLatency),
      .RamReadLatency(RamReadLatency),
      .NumSyncStages(NumSyncStages),
      .EnableCoverPushBackpressure(EnableCoverPushBackpressure),
      .EnableAssertPushValidStability(EnableAssertPushValidStability),
      .EnableAssertPushDataStability(EnableAssertPushDataStability),
      .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
  ) dut (
      .push_clk(~push_clk),
      .pop_clk(~pop_clk),
      .push_rst(push_rst),
      .pop_rst(pop_rst),
      .push_valid(push_valid),
      .push_data(push_data),
      .pop_ready(pop_ready),
      .pop_ram_rd_data_valid(pop_ram_rd_data_valid),
      .pop_ram_rd_data(pop_ram_rd_data),
      .push_ready(push_ready),
      .push_full(push_full),
      .push_slots(push_slots),
      .push_ram_wr_valid(push_ram_wr_valid),
      .push_ram_wr_addr(push_ram_wr_addr),
      .push_ram_wr_data(push_ram_wr_data),
      .pop_valid(pop_valid),
      .pop_data(pop_data),
      .pop_empty(pop_empty),
      .pop_items(pop_items),
      .pop_ram_rd_addr_valid(pop_ram_rd_addr_valid),
      .pop_ram_rd_addr(pop_ram_rd_addr)
  );


  //===========================================================
  // Clock Generation
  //===========================================================
  assign pop_clk = push_clk;
  initial begin
    push_clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR / (2 * CLOCK_FREQ)) push_clk = ~push_clk;
  end


  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_valid <= 'h0;
    push_data <= 'h0;
    pop_ready <= 'h0;
    pop_ram_rd_data_valid <= 'h0;
    pop_ram_rd_data <= 'h0;

    // Wiggling the reset signal.
    push_rst = 1'bx;
    pop_rst  = 1'bx;
    #RESET_DURATION;
    push_rst = 1'b1;
    pop_rst  = 1'b1;
    #RESET_DURATION;
    push_rst = 1'b0;
    pop_rst  = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushPopFunctionalityIdx,
    test_PushBackpressureHandlingIdx,
    test_PopLatencyVerificationIdx,
    test_CrossDomainSynchronizationIdx,
    test_ResetBehaviorVerificationIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

`ifdef WAVES_AS_FSDB
  bit enable_fsdb;
`endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
    if (NO_ASSERTS_ON_RESET) $assertoff;
    #(TIMEOUT);
    $display("Error: Testbench timeout!");
    $finish;
  end

`ifdef WAVES_AS_FSDB
  initial begin
    // Enable FSDB dump for TB and DUT
    if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
      $fsdbDumpfile("tb.fsdb");
      $fsdbDumpvars(0, br_cdc_fifo_ctrl_1r1w_gen_tb, "+all");
    end
  end
`endif


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushPopFunctionality();

    reset_dut();
    test_PushBackpressureHandling();

    reset_dut();
    test_PopLatencyVerification();

    reset_dut();
    test_CrossDomainSynchronization();

    reset_dut();
    test_ResetBehaviorVerification();

    if (err_count_arr[test_BasicPushPopFunctionalityIdx] == 0) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "PASSED"}));
    end else if (err_count_arr[test_BasicPushPopFunctionalityIdx] == -1) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "FAILED"}));
    end

    if (err_count_arr[test_PushBackpressureHandlingIdx] == 0) begin
      $display($sformatf({"Test test_PushBackpressureHandling ", "PASSED"}));
    end else if (err_count_arr[test_PushBackpressureHandlingIdx] == -1) begin
      $display($sformatf({"Test test_PushBackpressureHandling ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_PushBackpressureHandling ", "FAILED"}));
    end

    if (err_count_arr[test_PopLatencyVerificationIdx] == 0) begin
      $display($sformatf({"Test test_PopLatencyVerification PASSED"}));
    end else if (err_count_arr[test_PopLatencyVerificationIdx] == -1) begin
      $display($sformatf({"Test test_PopLatencyVerification TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_PopLatencyVerification FAILED"}));
    end

    if (err_count_arr[test_CrossDomainSynchronizationIdx] == 0) begin
      $display($sformatf({"Test test_CrossDomainSynchronization ", "PASSED"}));
    end else if (err_count_arr[test_CrossDomainSynchronizationIdx] == -1) begin
      $display($sformatf({"Test test_CrossDomainSynchronization ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_CrossDomainSynchronization ", "FAILED"}));
    end

    if (err_count_arr[test_ResetBehaviorVerificationIdx] == 0) begin
      $display($sformatf({"Test test_ResetBehaviorVerification ", "PASSED"}));
    end else if (err_count_arr[test_ResetBehaviorVerificationIdx] == -1) begin
      $display($sformatf({"Test test_ResetBehaviorVerification ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_ResetBehaviorVerification ", "FAILED"}));
    end


    if (err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end


  task automatic test_BasicPushPopFunctionality;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_BasicPushPopFunctionality"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_BasicPushPopFunctionality. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_BasicPushPopFunctionalityIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies the basic push and pop functionality of the FIFO by pushing data until full and then popping until empty.

        // Local variables declaration
        int test_failed = 0;
        int data_to_push;
        int push_count = 0;
        int pop_count = 0;
        localparam int MaxPushCount = Depth;

        $display($sformatf({"Time: %0t, START ", "test_BasicPushPopFunctionality - ",
                            "Starting test"}, $time));

        // Ensure the DUT is in reset state
        @(posedge push_clk);

        // Step 3: Drive push_valid high with valid data and monitor push_ready
        while (push_count < MaxPushCount) begin
          data_to_push = $urandom_range(0, (1 << Width) - 1);
          //push_valid = 1'b1;
          //push_data = data_to_push;
          @(posedge push_clk);
          push_valid = 1'b1;
          push_data  = data_to_push;
          if (push_ready !== 1'b1) begin
            $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - ",
                                "push_ready should be high when pushing ", "data, got %b"}, $time,
                                 push_ready));
            test_failed = 1;
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Data ",
                        "pushed: 0x%h, push_ready is high."
                      },
                      $time,
                      data_to_push
                  )
              );
          end
          push_count++;
        end

        @(posedge push_clk);
        push_valid = 1'b0;

        // Step 4: Monitor push_full
        if (push_full !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - ",
                              "push_full should be high when FIFO is ", "full, got %b"}, $time,
                               push_full));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicPushPopFunctionality - ",
                      "push_full is high as expected when FIFO ",
                      "is full."
                    },
                    $time
                )
            );
        end

        // Step 5: Assert pop_ready and monitor pop_valid
        pop_ready = 1'b1;
        @(posedge pop_clk);

        wait (pop_empty == 1'b0);
        @(posedge pop_clk);

        if (pop_valid !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - ",
                              "pop_valid should be high when data is ", "available to pop, got %b"
                               }, $time, pop_valid));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicPushPopFunctionality - ",
                      "pop_valid is high as expected when data ",
                      "is available."
                    },
                    $time
                )
            );
        end

        // Step 6: Read pop_data and monitor pop_empty
        while (pop_count < MaxPushCount) begin
          // @(posedge pop_clk);
          if (pop_valid && pop_ready) begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Data ",
                        "popped: 0x%h"
                      },
                      $time,
                      pop_data
                  )
              );
            pop_count++;
          end
          @(posedge pop_clk);
        end

        // Check pop_empty
        @(posedge pop_clk);
        if (pop_empty !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - ",
                              "pop_empty should be high when FIFO is ", "empty, got %b"}, $time,
                               pop_empty));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicPushPopFunctionality - ",
                      "pop_empty is high as expected when FIFO ",
                      "is empty."
                    },
                    $time
                )
            );
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_BasicPushPopFunctionality"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_BasicPushPopFunctionality"}, $time));
          err_count_arr[test_BasicPushPopFunctionalityIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PushBackpressureHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_PushBackpressureHandling"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_PushBackpressureHandling. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_PushBackpressureHandlingIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies the FIFO's ability to handle backpressure by ensuring `push_valid` and `push_data` remain stable when `push_ready` is deasserted.

        // Local variables declaration
        int test_failed = 0;
        logic [Width-1:0] random_data;
        int push_count = 0;
        int max_push_count = Depth + 2;  // Allow some extra pushes to test backpressure

        @(posedge push_clk);

        // Wait for push_ready to be asserted after reset
        while (!push_ready) begin
          @(posedge push_clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_PushBackpressureHandling - ",
                    "push_ready is asserted, FIFO is ready to",
                    " accept data."
                  },
                  $time
              )
          );

        // Drive push_valid high with valid data on push_data
        for (int i = 0; i < max_push_count; i++) begin
          random_data = $urandom_range(0, (1 << Width) - 1);
          push_valid  = 1'b1;
          push_data   = random_data;
          @(posedge push_clk);
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_PushBackpressureHandling - Driving ",
                      "push_valid=1, push_data=0x%h"
                    },
                    $time,
                    random_data
                )
            );

          // Check if push_ready is asserted
          if (push_ready) begin
            push_count++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_PushBackpressureHandling - ",
                        "push_ready is asserted, data accepted."
                      },
                      $time
                  )
              );
          end

          // Check if push_full is asserted
          if (push_full) begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_PushBackpressureHandling - ",
                        "push_full is asserted, FIFO is full."
                      },
                      $time
                  )
              );
            break;
          end
        end

        // Continue driving push_valid high and monitor push_ready for backpressure
        while (!push_full) begin
          random_data = $urandom_range(0, (1 << Width) - 1);
          push_valid  = 1'b1;
          push_data   = random_data;
          @(posedge push_clk);
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_PushBackpressureHandling - Driving ",
                      "push_valid=1, push_data=0x%h"
                    },
                    $time,
                    random_data
                )
            );

          // Check if push_ready is deasserted due to backpressure
          if (!push_ready) begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_PushBackpressureHandling - ",
                        "push_ready is deasserted, backpressure ",
                        "detected."
                      },
                      $time
                  )
              );
            break;
          end
        end

        // Ensure push_valid and push_data remain stable while push_ready is low
        if (!push_ready) begin
          for (int i = 0; i < 5; i++) begin
            @(posedge push_clk);
            if (push_valid !== 1'b1 || push_data !== random_data) begin
              $display($sformatf({"Time: %0t, ERROR: ", "test_PushBackpressureHandling - ",
                                  "push_valid or push_data not stable under", " backpressure."},
                                   $time));
              test_failed = 1;
            end else if (ENABLE_INFO_MESSAGES == 1) begin
              $display($sformatf({"Time: %0t, INFO: ", "test_PushBackpressureHandling - ",
                                  "push_valid and push_data stable under ", "backpressure."},
                                   $time));
            end
          end
        end

        // Final check for test pass/fail
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_PushBackpressureHandling"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_PushBackpressureHandling"}, $time));
          err_count_arr[test_PushBackpressureHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PopLatencyVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_PopLatencyVerification"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_PopLatencyVerification. Stimuli is ",
                      "not observed or it needs more time to ", "finish this test."}, $time));
        err_count_arr[test_PopLatencyVerificationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // Purpose: Verify that the FIFO correctly handles read latency during pop operations by managing `pop_valid` and `pop_data` timing based on the `RamReadLatency` parameter.

        // Local variables declaration
        int test_failed = 0;
        int random_data;
        int expected_latency;
        int observed_latency;
        int cycle_count;
        logic [Width-1:0] expected_data;

        // Calculate expected latency based on parameters
        localparam int FlopRamAddressDepthStages = 1;  // Assuming a value for demonstration
        localparam int FlopRamReadDataDepthStages = 1;  // Assuming a value for demonstration
        localparam int FlopRamReadDataWidthStages = 1;  // Assuming a value for demonstration
        expected_latency = FlopRamAddressDepthStages +
                           FlopRamReadDataDepthStages +
                           FlopRamReadDataWidthStages;

        $display($sformatf({"Time: %0t, Starting: ", "test_PopLatencyVerification"}, $time));

        // Ensure adequate stimulus propagation time
        @(posedge push_clk);
        random_data = $urandom_range(0, 2 ** Width - 1);
        push_valid  = 1'b1;
        push_data   = random_data;
        @(posedge push_clk);
        push_valid = 1'b0;

        @(posedge pop_clk);

        // Step 3: Assert pop_ready and monitor pop_valid
        pop_ready   = 1'b1;
        cycle_count = 0;
        while (pop_valid !== 1'b1) begin
          @(posedge pop_clk);
          cycle_count++;
          if (cycle_count > TIMEOUT) begin
            $display($sformatf({"Time: %0t, ERROR: ", "test_PopLatencyVerification - Timeout ",
                                "waiting for pop_valid."}, $time));
            test_failed = 1;
            break;
          end
        end
        if (pop_valid === 1'b1) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_PopLatencyVerification - pop_valid ",
                      "is high, indicating valid data is ",
                      "available."
                    },
                    $time
                )
            );
        end

        // Step 4: Read pop_data and verify pop_valid timing
        expected_data = random_data;
        observed_latency = cycle_count;
        while (pop_valid === 1'b1) begin
          @(posedge pop_clk);
          if (pop_data !== expected_data) begin
            $display($sformatf({"Time: %0t, ERROR: ", "test_PopLatencyVerification - Data ",
                                "mismatch. Expected: 0x%h, Got: 0x%h"}, $time, expected_data,
                                 pop_data));
            test_failed = 1;
          end
        end
        if (observed_latency !== expected_latency) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_PopLatencyVerification - Latency ",
                              "mismatch. Expected: %0d cycles, ", "Observed: %0d cycles"}, $time,
                               expected_latency, observed_latency));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_PopLatencyVerification - Latency ",
                      "matches expected value of %0d cycles."
                    },
                    $time,
                    expected_latency
                )
            );
        end

        // Final check for test pass/fail status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_PopLatencyVerification"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_PopLatencyVerification"}, $time));
          err_count_arr[test_PopLatencyVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_CrossDomainSynchronization;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_CrossDomainSynchronization"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_CrossDomainSynchronization. Stimuli",
                      " is not observed or it needs more time ", "to finish this test."}, $time));
        err_count_arr[test_CrossDomainSynchronizationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies the synchronization of data between push_clk and pop_clk domains in the FIFO without data corruption.

        // Local variables declaration
        int test_failed = 0;
        logic [Width-1:0] expected_data;
        logic [Width-1:0] observed_data;
        int random_data;

        $display($sformatf({"Time: %0t, Starting: ", "test_CrossDomainSynchronization"}, $time));

        // Wait for push_ready to be asserted before asserting push_valid
        while (push_ready !== 1'b1) begin
          @(posedge push_clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_CrossDomainSynchronization - ",
                    "push_ready asserted."
                  },
                  $time
              )
          );

        // Drive push_valid high with random data on push_data
        @(posedge push_clk);
        random_data = $urandom_range(0, (1 << Width) - 1);
        push_valid = 1'b1;
        push_data = random_data;
        expected_data = random_data;
        @(posedge push_clk);

        push_valid = 1'b0;
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_CrossDomainSynchronization - ",
                    "Driving push_valid=1, push_data=0x%h."
                  },
                  $time,
                  push_data
              )
          );

        // Assert pop_ready and wait for pop_valid to be asserted
        pop_ready = 1'b1;
        @(posedge pop_clk);
        while (pop_valid !== 1'b1) begin
          @(posedge pop_clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_CrossDomainSynchronization - ", "pop_valid asserted."
                  },
                  $time
              )
          );

        // Capture the observed data and compare with expected data
        observed_data = pop_data;
        if (observed_data !== expected_data) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_CrossDomainSynchronization - Data ",
                              "mismatch. Expected 0x%h, got 0x%h"}, $time, expected_data,
                               observed_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_CrossDomainSynchronization - Data ",
                      "integrity check passed. Expected and ",
                      "observed data: 0x%h."
                    },
                    $time,
                    observed_data
                )
            );
        end

        // Reset signals
        push_valid = 1'b0;
        pop_ready  = 1'b0;

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_CrossDomainSynchronization"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_CrossDomainSynchronization"}, $time));
          err_count_arr[test_CrossDomainSynchronizationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_ResetBehaviorVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_ResetBehaviorVerification"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_ResetBehaviorVerification. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_ResetBehaviorVerificationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // Task to verify the reset behavior of the FIFO and ensure data integrity after reset
        // Local variables declaration
        int test_failed = 0;
        logic [Width-1:0] expected_data;
        logic [Width-1:0] observed_data;
        int data_pattern;

        @(posedge push_clk);
        if (push_ready !== 1'b1 || pop_empty !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_ResetBehaviorVerification - Reset ",
                              "state check failed. Expected ", "push_ready=1, pop_empty=1, got ",
                              "push_ready=%b, pop_empty=%b"}, $time, push_ready, pop_empty));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_ResetBehaviorVerification - Reset ",
                      "state check passed. push_ready=0, ",
                      "pop_empty=1"
                    },
                    $time
                )
            );
        end

        // Verify internal counters and status signals are reset
        @(posedge push_clk);
        if (push_slots !== Depth || pop_items !== 0) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_ResetBehaviorVerification - ",
                              "Internal counters reset check failed. ",
                              "Expected push_slots=%0d, pop_items=0, ",
                              "got push_slots=%0d, pop_items=%0d"}, $time, Depth, push_slots,
                               pop_items));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_ResetBehaviorVerification - ",
                      "Internal counters reset check passed. ",
                      "push_slots=%0d, pop_items=0"
                    },
                    $time,
                    Depth
                )
            );
        end

        // Drive push_valid high with valid data and check data acceptance
        data_pattern = $urandom();
        push_valid = 1'b1;
        push_data = data_pattern;
        @(posedge push_clk);
        push_valid = 1'b0;
        if (push_ready !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_ResetBehaviorVerification - Data ",
                              "acceptance check failed. Expected ",
                              "push_ready=1, got push_ready=%b"}, $time, push_ready));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_ResetBehaviorVerification - Data ",
                      "acceptance check passed. push_ready=1"
                    },
                    $time
                )
            );
        end

        // Assert pop_ready and check data availability
        pop_ready = 1'b1;
        while (pop_valid !== 1'b1) begin
          @(posedge pop_clk);
        end

        // Verify data integrity after reset. Since there is no memory in this
        // design, force signals coming from memory
        pop_ram_rd_data_valid = 1'b1;
        pop_ram_rd_data = data_pattern;

        @(negedge pop_clk);
        observed_data = pop_data;
        expected_data = data_pattern;

        if (observed_data !== expected_data) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_ResetBehaviorVerification - Data ",
                              "integrity check failed. Expected ", "data=0x%h, got data=0x%h"},
                               $time, expected_data, observed_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_ResetBehaviorVerification - Data ",
                      "integrity check passed. Expected ",
                      "data=0x%h, observed data=0x%h"
                    },
                    $time,
                    expected_data,
                    observed_data
                )
            );
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_ResetBehaviorVerification"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_ResetBehaviorVerification"}, $time));
          err_count_arr[test_ResetBehaviorVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
