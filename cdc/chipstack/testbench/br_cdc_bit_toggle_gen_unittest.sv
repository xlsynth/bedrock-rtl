
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_cdc_bit_toggle
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-17 22:25:50
// Description: Unit test for br_cdc_bit_toggle
//=============================================================



module br_cdc_bit_toggle_gen_unittest;
  timeunit 1ns; timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;  // Clock frequency in MHz
  parameter int RESET_DURATION = 100;  // Reset duration in ns
  parameter int TIMEOUT = 10000000;  // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000;  // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;  // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000;  // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks

  //===========================================================
  // DUT Imports and Includes
  //===========================================================

  `include "br_registers.svh"
  `include "br_asserts.svh"
  `include "br_gates.svh"

  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int NumStages = 3;
  parameter bit AddSourceFlop = 1;

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic src_clk;
  logic dst_clk;
  logic src_rst;
  logic dst_rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic src_bit;
  logic dst_bit;

  //===========================================================
  // DUT Instantiation
  //===========================================================
  // Clock to DUT is inverted to avoid race condition between DUT and TB
  br_cdc_bit_toggle #(
      .NumStages(NumStages),
      .AddSourceFlop(AddSourceFlop)
  ) dut (
      .src_clk(~src_clk),
      .dst_clk(~dst_clk),
      .src_rst(src_rst),
      .dst_rst(dst_rst),
      .src_bit(src_bit),
      .dst_bit(dst_bit)
  );


  //===========================================================
  // Clock Generation
  //===========================================================
  assign dst_clk = src_clk;
  initial begin
    src_clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR / (2 * CLOCK_FREQ)) src_clk = ~src_clk;
  end


  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    src_bit <= 'h0;

    // Wiggling the reset signal.
    src_rst = 1'bx;
    dst_rst = 1'bx;
    #RESET_DURATION;
    src_rst = 1'b1;
    dst_rst = 1'b1;
    #RESET_DURATION;
    src_rst = 1'b0;
    dst_rst = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicSignalSynchronizationIdx,
    test_SourceFlopEnabledIdx,
    test_MaximumDelayCheckIdx,
    test_SignalIntegrityUnderResetIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

`ifdef WAVES_AS_FSDB
  bit enable_fsdb;
`endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
    if (NO_ASSERTS_ON_RESET) $assertoff;
    #(TIMEOUT);
    $display("Error: Testbench timeout!");
    $finish;
  end

`ifdef WAVES_AS_FSDB
  initial begin
    // Enable FSDB dump for TB and DUT
    if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
      $fsdbDumpfile("tb.fsdb");
      $fsdbDumpvars(0, br_cdc_bit_toggle_gen_tb, "+all");
    end
  end
`endif


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicSignalSynchronization();

    reset_dut();
    test_SourceFlopEnabled();

    reset_dut();
    test_MaximumDelayCheck();

    reset_dut();
    test_SignalIntegrityUnderReset();

    if (err_count_arr[test_BasicSignalSynchronizationIdx] == 0) begin
      $display($sformatf({"Test test_BasicSignalSynchronization ", "PASSED"}));
    end else if (err_count_arr[test_BasicSignalSynchronizationIdx] == -1) begin
      $display($sformatf({"Test test_BasicSignalSynchronization ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BasicSignalSynchronization ", "FAILED"}));
    end

    if (err_count_arr[test_SourceFlopEnabledIdx] == 0) begin
      $display("Test test_SourceFlopEnabled PASSED");
    end else if (err_count_arr[test_SourceFlopEnabledIdx] == -1) begin
      $display("Test test_SourceFlopEnabled TIMEOUT");
    end else begin
      $display("Test test_SourceFlopEnabled FAILED");
    end

    if (err_count_arr[test_MaximumDelayCheckIdx] == 0) begin
      $display("Test test_MaximumDelayCheck PASSED");
    end else if (err_count_arr[test_MaximumDelayCheckIdx] == -1) begin
      $display("Test test_MaximumDelayCheck TIMEOUT");
    end else begin
      $display("Test test_MaximumDelayCheck FAILED");
    end

    if (err_count_arr[test_SignalIntegrityUnderResetIdx] == 0) begin
      $display($sformatf({"Test test_SignalIntegrityUnderReset ", "PASSED"}));
    end else if (err_count_arr[test_SignalIntegrityUnderResetIdx] == -1) begin
      $display($sformatf({"Test test_SignalIntegrityUnderReset ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_SignalIntegrityUnderReset ", "FAILED"}));
    end


    if (err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end


  task automatic test_BasicSignalSynchronization;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_BasicSignalSynchronization"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_BasicSignalSynchronization. Stimuli",
                      " is not observed or it needs more time ", "to finish this test."}, $time));
        err_count_arr[test_BasicSignalSynchronizationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // Task to verify the synchronization of `src_bit` to `dst_bit` using 3 stages without an additional source flop.

        // Local variables declaration
        int test_failed = 0;
        int expected_value;

        // Ensure the DUT is in a reset state
        @(posedge src_clk);

        // Deassert reset and start normal operation
        src_rst = 1'b0;
        dst_rst = 1'b0;
        @(posedge src_clk);

        // Drive `src_bit` with logic level `1` and capture it
        src_bit = 1'b1;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_BasicSignalSynchronization - ", "Driving src_bit=1"
                  },
                  $time
              )
          );

        // Wait for 3 clock cycles for synchronization
        for (int i = 0; i < 3; i++) begin
          @(posedge dst_clk);
        end

        // Check if `dst_bit` is `1`
        expected_value = 1;
        if (dst_bit !== expected_value) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicSignalSynchronization - Check ",
                              "failed. Expected dst_bit=%0d, got %0d"}, $time, expected_value,
                               dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicSignalSynchronization - Check ",
                      "passed. Expected value for dst_bit is ",
                      "the same as the observed value (both are",
                      " %0d)."
                    },
                    $time,
                    dst_bit
                )
            );
        end

        // Drive `src_bit` with logic level `0` and capture it
        src_bit = 1'b0;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_BasicSignalSynchronization - ", "Driving src_bit=0"
                  },
                  $time
              )
          );

        // Wait for 3 clock cycles for synchronization
        for (int i = 0; i < 3; i++) begin
          @(posedge dst_clk);
        end

        // Check if `dst_bit` is `0`
        expected_value = 0;
        if (dst_bit !== expected_value) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicSignalSynchronization - Check ",
                              "failed. Expected dst_bit=%0d, got %0d"}, $time, expected_value,
                               dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicSignalSynchronization - Check ",
                      "passed. Expected value for dst_bit is ",
                      "the same as the observed value (both are",
                      " %0d)."
                    },
                    $time,
                    dst_bit
                )
            );
        end

        // Report the test result
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_BasicSignalSynchronization"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_BasicSignalSynchronization"}, $time));
          err_count_arr[test_BasicSignalSynchronizationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_SourceFlopEnabled;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_SourceFlopEnabled"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ", "test_SourceFlopEnabled. Stimuli is not ",
                            "observed or it needs more time to finish", " this test."}, $time));
        err_count_arr[test_SourceFlopEnabledIdx] = -1;  // For timeout, set the error count to -1
      end
      begin
        // This task verifies the synchronization of `src_bit` to `dst_bit` with the additional source flop enabled.

        // Local variables declaration
        int   test_failed = 0;
        int   i;
        logic expected_dst_bit;

        // Wait for a positive edge of the source clock to ensure proper stimulus propagation
        @(posedge src_clk);

        // Step 1: Drive `src_bit` with logic level `1` and assert `src_clk`
        src_bit = 1'b1;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf({"Time: %0t, INFO: test_SourceFlopEnabled ", "- Driving src_bit=1"}, $time)
          );

        // Wait for `NumStages + 1` clock cycles
        for (i = 0; i < NumStages + 1; i++) begin
          @(posedge dst_clk);
        end

        // Check if `dst_bit` is `1`
        expected_dst_bit = 1'b1;
        if (dst_bit !== expected_dst_bit) begin
          $display($sformatf({"Time: %0t, ERROR: test_SourceFlopEnabled",
                              " - Check failed. Expected dst_bit=%b, ", "got dst_bit=%b"}, $time,
                               expected_dst_bit, dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: test_SourceFlopEnabled ",
                      "- Check passed. Expected value for ",
                      "dst_bit is the same as the observed ",
                      "value (both are %b)."
                    },
                    $time,
                    dst_bit
                )
            );
        end

        // Step 2: Drive `src_bit` with logic level `0` and assert `src_clk`
        src_bit = 1'b0;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf({"Time: %0t, INFO: test_SourceFlopEnabled ", "- Driving src_bit=0"}, $time)
          );

        // Wait for `NumStages + 1` clock cycles
        for (i = 0; i < NumStages + 1; i++) begin
          @(posedge dst_clk);
        end

        // Check if `dst_bit` is `0`
        expected_dst_bit = 1'b0;
        if (dst_bit !== expected_dst_bit) begin
          $display($sformatf({"Time: %0t, ERROR: test_SourceFlopEnabled",
                              " - Check failed. Expected dst_bit=%b, ", "got dst_bit=%b"}, $time,
                               expected_dst_bit, dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: test_SourceFlopEnabled ",
                      "- Check passed. Expected value for ",
                      "dst_bit is the same as the observed ",
                      "value (both are %b)."
                    },
                    $time,
                    dst_bit
                )
            );
        end

        // Report the test result
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_SourceFlopEnabled"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_SourceFlopEnabled"}, $time));
          err_count_arr[test_SourceFlopEnabledIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_MaximumDelayCheck;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_MaximumDelayCheck"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ", "test_MaximumDelayCheck. Stimuli is not ",
                            "observed or it needs more time to finish", " this test."}, $time));
        err_count_arr[test_MaximumDelayCheckIdx] = -1;  // For timeout, set the error count to -1
      end
      begin
        // Task to verify the propagation of `src_bit` to `dst_bit` across clock domains with maximum expected delay
        // Local variables declaration
        int   test_failed = 0;
        int   cycle_count;
        logic expected_dst_bit;

        // Initial delay to ensure proper stimulus propagation
        @(posedge src_clk);

        // Step 1: Drive `src_bit` with logic level `1` and assert `src_clk`
        src_bit = 1'b1;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf({"Time: %0t, INFO: test_MaximumDelayCheck ", "- Driving src_bit=1"}, $time)
          );

        // Step 2: Wait for `dst_bit` to reflect the value `1` with maximum delay of `NumStages + 1` cycles
        expected_dst_bit = 1'b1;
        cycle_count = 0;
        while (dst_bit !== expected_dst_bit && cycle_count < (NumStages + 1)) begin
          @(posedge dst_clk);
          cycle_count++;
        end

        if (dst_bit !== expected_dst_bit) begin
          $display($sformatf({"Time: %0t, ERROR: test_MaximumDelayCheck",
                              " - Check failed. Expected dst_bit=1, got", " %b"}, $time, dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: test_MaximumDelayCheck ",
                      "- Check passed. Expected value for ",
                      "dst_bit is the same as the observed ",
                      "value (both are 1)."
                    },
                    $time
                )
            );
        end

        // Step 3: Drive `src_bit` with logic level `0` and assert `src_clk`
        src_bit = 1'b0;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf({"Time: %0t, INFO: test_MaximumDelayCheck ", "- Driving src_bit=0"}, $time)
          );

        // Step 4: Wait for `dst_bit` to reflect the value `0` with maximum delay of `NumStages + 1` cycles
        expected_dst_bit = 1'b0;
        cycle_count = 0;
        while (dst_bit !== expected_dst_bit && cycle_count < (NumStages + 1)) begin
          @(posedge dst_clk);
          cycle_count++;
        end

        if (dst_bit !== expected_dst_bit) begin
          $display($sformatf({"Time: %0t, ERROR: test_MaximumDelayCheck",
                              " - Check failed. Expected dst_bit=0, got", " %b"}, $time, dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: test_MaximumDelayCheck ",
                      "- Check passed. Expected value for ",
                      "dst_bit is the same as the observed ",
                      "value (both are 0)."
                    },
                    $time
                )
            );
        end

        // Final test status reporting
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_MaximumDelayCheck"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_MaximumDelayCheck"}, $time));
          err_count_arr[test_MaximumDelayCheckIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_SignalIntegrityUnderReset;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_SignalIntegrityUnderReset"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_SignalIntegrityUnderReset. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_SignalIntegrityUnderResetIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies the integrity of the `dst_bit` signal during reset conditions and ensures it is correctly synchronized after reset deassertion.

        // Local variables declaration
        int   test_failed = 0;
        int   i;
        logic expected_dst_bit;

        // Wait for the reset to be asserted and check the reset behavior
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_SignalIntegrityUnderReset - ",
                    "Asserting src_rst and dst_rst"
                  },
                  $time
              )
          );

        src_rst = 1'b1;
        dst_rst = 1'b1;
        @(posedge src_clk);

        // Check if dst_bit is reset to 0
        expected_dst_bit = 1'b0;
        if (dst_bit !== expected_dst_bit) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_SignalIntegrityUnderReset - Check ",
                              "failed. Expected dst_bit=0, got %b"}, $time, dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_SignalIntegrityUnderReset - Check ",
                      "passed. Expected value for dst_bit is ",
                      "the same as the observed value (both are",
                      " 0)."
                    },
                    $time
                )
            );
        end

        // Deassert reset and wait for NumStages clock cycles
        src_rst = 1'b0;
        dst_rst = 1'b0;
        for (i = 0; i < NumStages; i++) begin
          @(posedge src_clk);
        end

        // Drive src_bit with logic level 1
        src_bit = 1'b1;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_SignalIntegrityUnderReset - Driving", " src_bit=1"
                  },
                  $time
              )
          );

        // Wait for NumStages + 1 cycles for dst_bit to reflect the change
        for (i = 0; i < NumStages + 1; i++) begin
          @(posedge dst_clk);
        end

        // Check if dst_bit is 1
        expected_dst_bit = 1'b1;
        if (dst_bit !== expected_dst_bit) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_SignalIntegrityUnderReset - Check ",
                              "failed. Expected dst_bit=1, got %b"}, $time, dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_SignalIntegrityUnderReset - Check ",
                      "passed. Expected value for dst_bit is ",
                      "the same as the observed value (both are",
                      " 1)."
                    },
                    $time
                )
            );
        end

        // Drive src_bit with logic level 0
        src_bit = 1'b0;
        @(posedge src_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_SignalIntegrityUnderReset - Driving", " src_bit=0"
                  },
                  $time
              )
          );

        // Wait for NumStages + 1 cycles for dst_bit to reflect the change
        for (i = 0; i < NumStages + 1; i++) begin
          @(posedge dst_clk);
        end

        // Check if dst_bit is 0
        expected_dst_bit = 1'b0;
        if (dst_bit !== expected_dst_bit) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_SignalIntegrityUnderReset - Check ",
                              "failed. Expected dst_bit=0, got %b"}, $time, dst_bit));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_SignalIntegrityUnderReset - Check ",
                      "passed. Expected value for dst_bit is ",
                      "the same as the observed value (both are",
                      " 0)."
                    },
                    $time
                )
            );
        end

        // Report the final status of the test
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_SignalIntegrityUnderReset"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_SignalIntegrityUnderReset"}, $time));
          err_count_arr[test_SignalIntegrityUnderResetIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
