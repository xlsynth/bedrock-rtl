
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_cdc_fifo_flops
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-17 22:25:50
// Description: Unit test for br_cdc_fifo_flops
//=============================================================



module br_cdc_fifo_flops_gen_tb;
  timeunit 1ns; timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;  // Clock frequency in MHz
  parameter int RESET_DURATION = 100;  // Reset duration in ns
  parameter int TIMEOUT = 10000000;  // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000;  // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;  // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000;  // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks


  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int Depth = 2;
  parameter int Width = 1;
  parameter bit RegisterPopOutputs = 0;
  parameter bit RegisterResetActive = 1;
  parameter int NumSyncStages = 3;
  parameter int FlopRamDepthTiles = 1;
  parameter int FlopRamWidthTiles = 1;
  parameter int FlopRamAddressDepthStages = 0;
  parameter int FlopRamReadDataDepthStages = 0;
  parameter int FlopRamReadDataWidthStages = 0;
  parameter bit EnableCoverPushBackpressure = 1;
  parameter bit EnableAssertPushValidStability = EnableCoverPushBackpressure;
  parameter bit EnableAssertPushDataStability = EnableAssertPushValidStability;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int AddrWidth = $clog2(Depth);
  localparam int CountWidth = $clog2((Depth + 1));

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic                  push_clk;
  logic                  pop_clk;
  logic                  push_rst;
  logic                  pop_rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic                  push_valid;
  logic [     Width-1:0] push_data;
  logic                  pop_ready;
  logic                  push_ready;
  logic                  pop_valid;
  logic [     Width-1:0] pop_data;
  logic                  push_full;
  logic [CountWidth-1:0] push_slots;
  logic                  pop_empty;
  logic [CountWidth-1:0] pop_items;

  //===========================================================
  // DUT Instantiation
  //===========================================================
  // Clock to DUT is inverted to avoid race condition between DUT and TB
  br_cdc_fifo_flops #(
      .Depth(Depth),
      .Width(Width),
      .RegisterPopOutputs(RegisterPopOutputs),
      .RegisterResetActive(RegisterResetActive),
      .NumSyncStages(NumSyncStages),
      .FlopRamDepthTiles(FlopRamDepthTiles),
      .FlopRamWidthTiles(FlopRamWidthTiles),
      .FlopRamAddressDepthStages(FlopRamAddressDepthStages),
      .FlopRamReadDataDepthStages(FlopRamReadDataDepthStages),
      .FlopRamReadDataWidthStages(FlopRamReadDataWidthStages),
      .EnableCoverPushBackpressure(EnableCoverPushBackpressure),
      .EnableAssertPushValidStability(EnableAssertPushValidStability),
      .EnableAssertPushDataStability(EnableAssertPushDataStability),
      .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
  ) dut (
      .push_clk(~push_clk),
      .pop_clk(~pop_clk),
      .push_rst(push_rst),
      .pop_rst(pop_rst),
      .push_valid(push_valid),
      .push_data(push_data),
      .pop_ready(pop_ready),
      .push_ready(push_ready),
      .pop_valid(pop_valid),
      .pop_data(pop_data),
      .push_full(push_full),
      .push_slots(push_slots),
      .pop_empty(pop_empty),
      .pop_items(pop_items)
  );


  //===========================================================
  // Clock Generation
  //===========================================================
  assign pop_clk = push_clk;
  initial begin
    push_clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR / (2 * CLOCK_FREQ)) push_clk = ~push_clk;
  end


  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_valid <= 'h0;
    push_data  <= 'h0;
    pop_ready  <= 'h0;

    // Wiggling the reset signal.
    push_rst = 1'bx;
    pop_rst  = 1'bx;
    #RESET_DURATION;
    push_rst = 1'b1;
    pop_rst  = 1'b1;
    #RESET_DURATION;
    push_rst = 1'b0;
    pop_rst  = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushPopFunctionalityIdx,
    test_PushBackpressureHandlingIdx,
    test_PopUnderflowHandlingIdx,
    test_GrayCodeSynchronizationIdx,
    test_FinalStateAssertionVerificationIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

`ifdef WAVES_AS_FSDB
  bit enable_fsdb;
`endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
    if (NO_ASSERTS_ON_RESET) $assertoff;
    #(TIMEOUT);
    $display("Error: Testbench timeout!");
    $finish;
  end

`ifdef WAVES_AS_FSDB
  initial begin
    // Enable FSDB dump for TB and DUT
    if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
      $fsdbDumpfile("tb.fsdb");
      $fsdbDumpvars(0, br_cdc_fifo_flops_gen_tb, "+all");
    end
  end
`endif


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushPopFunctionality();

    reset_dut();
    test_PushBackpressureHandling();

    reset_dut();
    test_PopUnderflowHandling();

    reset_dut();
    test_GrayCodeSynchronization();

    reset_dut();
    test_FinalStateAssertionVerification();

    if (err_count_arr[test_BasicPushPopFunctionalityIdx] == 0) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "PASSED"}));
    end else if (err_count_arr[test_BasicPushPopFunctionalityIdx] == -1) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "FAILED"}));
    end

    if (err_count_arr[test_PushBackpressureHandlingIdx] == 0) begin
      $display($sformatf({"Test test_PushBackpressureHandling ", "PASSED"}));
    end else if (err_count_arr[test_PushBackpressureHandlingIdx] == -1) begin
      $display($sformatf({"Test test_PushBackpressureHandling ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_PushBackpressureHandling ", "FAILED"}));
    end

    if (err_count_arr[test_PopUnderflowHandlingIdx] == 0) begin
      $display("Test test_PopUnderflowHandling PASSED");
    end else if (err_count_arr[test_PopUnderflowHandlingIdx] == -1) begin
      $display("Test test_PopUnderflowHandling TIMEOUT");
    end else begin
      $display("Test test_PopUnderflowHandling FAILED");
    end

    if (err_count_arr[test_GrayCodeSynchronizationIdx] == 0) begin
      $display($sformatf({"Test test_GrayCodeSynchronization PASSED"}));
    end else if (err_count_arr[test_GrayCodeSynchronizationIdx] == -1) begin
      $display($sformatf({"Test test_GrayCodeSynchronization ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_GrayCodeSynchronization FAILED"}));
    end

    if (err_count_arr[test_FinalStateAssertionVerificationIdx] == 0) begin
      $display($sformatf({"Test ", "test_FinalStateAssertionVerification ", "PASSED"}));
    end else if (err_count_arr[test_FinalStateAssertionVerificationIdx] == -1) begin
      $display($sformatf({"Test ", "test_FinalStateAssertionVerification ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test ", "test_FinalStateAssertionVerification ", "FAILED"}));
    end


    if (err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end


  task automatic test_BasicPushPopFunctionality;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_BasicPushPopFunctionality"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_BasicPushPopFunctionality. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_BasicPushPopFunctionalityIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task tests the basic functionality of the FIFO by pushing data until it is full and then popping data until it is empty.
        // Local variables declaration
        int test_failed = 0;
        int push_count = 0;
        int pop_count = 0;
        logic [Width-1:0] random_data;

        // Wait for the design to drive push_ready high, indicating the FIFO is ready to accept data
        @(posedge push_clk);
        if (push_ready !== 1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - ",
                              "push_ready should be high after reset. ", "Observed: %b"}, $time,
                               push_ready));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicPushPopFunctionality - ",
                      "push_ready is high after reset as ",
                      "expected."
                    },
                    $time
                )
            );
        end

        // Push data until the FIFO is full
        while (push_full !== 1) begin
          @(posedge push_clk);
          random_data = $urandom_range(0, (1 << Width) - 1);
          push_valid  = 1;
          push_data   = random_data;
          // @(posedge push_clk);
          if (push_ready === 1) begin
            push_count++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Pushed ",
                        "data: 0x%h, push_count: %0d"
                      },
                      $time,
                      random_data,
                      push_count
                  )
              );
          end
        end

        // Assert pop_ready and wait for pop_valid to indicate data is available for popping
        pop_ready = 1;
        @(posedge pop_clk);

        // Wait for pop_empty to be deasserted
        wait (pop_empty == 1'b0);

        fork
          begin
            @(negedge pop_clk);
            if (pop_valid !== 1) begin
              $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - ",
                                  "pop_valid should be high when data is ",
                                  "available. Observed: %b"}, $time, pop_valid));
              test_failed = 1;
            end else begin
              if (ENABLE_INFO_MESSAGES == 1)
                $display(
                    $sformatf(
                        {
                          "Time: %0t, INFO: ",
                          "test_BasicPushPopFunctionality - ",
                          "pop_valid is high, data is available for",
                          " popping."
                        },
                        $time
                    )
                );
            end
          end
        join_none

        // Pop data until the FIFO is empty
        while (pop_empty !== 1) begin
          @(posedge pop_clk);
          if (pop_valid === 1 && pop_ready === 1) begin
            pop_count++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Popped ",
                        "data: 0x%h, pop_count: %0d"
                      },
                      $time,
                      pop_data,
                      pop_count
                  )
              );
          end
        end

        // Check if the number of pushed and popped items match
        if (push_count !== pop_count) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - ",
                              "Mismatch in push and pop counts. Pushed:", " %0d, Popped: %0d"},
                               $time, push_count, pop_count));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicPushPopFunctionality - Push ",
                      "and pop counts match. Count: %0d"
                    },
                    $time,
                    push_count
                )
            );
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_BasicPushPopFunctionality"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_BasicPushPopFunctionality"}, $time));
          err_count_arr[test_BasicPushPopFunctionalityIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PushBackpressureHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_PushBackpressureHandling"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_PushBackpressureHandling. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_PushBackpressureHandlingIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies the FIFO's ability to handle backpressure on the push side by maintaining data stability and deasserting `push_ready` when full.

        // Local variables declaration
        int test_failed = 0;
        int data_to_push;
        int slots_available;

        // Wait for the reset to complete and the FIFO to be ready
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_PushBackpressureHandling - Waiting ",
                    "for FIFO to be ready after reset."
                  },
                  $time
              )
          );
        while (!push_ready) @(posedge push_clk);

        // Start pushing data until FIFO is full
        while (!push_full) begin
          data_to_push = $urandom_range(0, (1 << Width) - 1);
          push_valid = 1'b1;
          push_data = data_to_push;
          @(posedge push_clk);
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ", "test_PushBackpressureHandling - Pushing ", "data: 0x%h"
                    },
                    $time,
                    data_to_push
                )
            );
        end

        // Check if FIFO is full
        if (!push_full) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_PushBackpressureHandling - FIFO ",
                              "should be full but push_full is not ", "asserted."}, $time));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_PushBackpressureHandling - FIFO is ",
                              "full as expected."}, $time));
        end

        // Continue driving push_valid high and monitor push_ready for backpressure
        push_valid = 1'b1;
        data_to_push = $urandom_range(0, (1 << Width) - 1);
        push_data = data_to_push;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_PushBackpressureHandling - ",
                    "Monitoring push_ready for backpressure."
                  },
                  $time
              )
          );

        while (push_ready) @(posedge push_clk);

        // Check data stability during backpressure
        slots_available = push_slots;
        if (push_data !== data_to_push) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_PushBackpressureHandling - Data ",
                              "instability detected during ",
                              "backpressure. Expected: 0x%h, Observed: ", "0x%h"}, $time,
                               data_to_push, push_data));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_PushBackpressureHandling - Data ",
                              "stability maintained during ", "backpressure."}, $time));
        end

        // Check push_slots and pop_empty
        if (slots_available !== 0) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_PushBackpressureHandling - Expected",
                              " push_slots to be 0, but got %0d."}, $time, slots_available));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_PushBackpressureHandling - ",
                              "push_slots is 0 as expected."}, $time));
        end

        if (!pop_empty) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_PushBackpressureHandling - Expected",
                              " pop_empty to be asserted, but it is ", "not."}, $time));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_PushBackpressureHandling - ",
                              "pop_empty is asserted as expected."}, $time));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_PushBackpressureHandling"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_PushBackpressureHandling"}, $time));
          err_count_arr[test_PushBackpressureHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PopUnderflowHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_PopUnderflowHandling"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ", "test_PopUnderflowHandling. Stimuli is ",
                            "not observed or it needs more time to ", "finish this test."}, $time));
        err_count_arr[test_PopUnderflowHandlingIdx] = -1;  // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the FIFO correctly handles pop operations when it is empty by asserting `pop_empty` and ensuring `pop_data` is not valid.

        // Local variables declaration
        int test_failed = 0;
        logic [Width-1:0] expected_pop_data;

        // Initial delay to ensure proper stimulus propagation
        @(posedge pop_clk);

        // Step 1: Assert `pop_rst` for at least one cycle of `pop_clk` to reset the FIFO
        pop_rst = 1'b1;
        @(posedge pop_clk);
        pop_rst = 1'b0;
        @(posedge pop_clk);

        // Step 2: Wait for the design to drive `pop_empty` high, indicating the FIFO is empty
        while (pop_empty !== 1'b1) begin
          @(posedge pop_clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_PopUnderflowHandling - `pop_empty` ",
                    "is high, FIFO is empty."
                  },
                  $time
              )
          );

        // Step 3: Deassert `pop_rst` and wait for a few cycles to confirm `pop_empty` is still high
        @(posedge pop_clk);
        for (int i = 0; i < 3; i++) begin
          @(posedge pop_clk);
          if (pop_empty !== 1'b1) begin
            $display($sformatf({"Time: %0t, ERROR: ", "test_PopUnderflowHandling - `pop_empty` ",
                                "is not high after reset. Expected 1, got", " %b"}, $time,
                                 pop_empty));
            test_failed = 1;
          end
        end

        // Step 4: Assert `pop_ready` and monitor `pop_valid`
        pop_ready = 1'b1;
        @(posedge pop_clk);
        if (pop_valid !== 1'b0) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_PopUnderflowHandling - `pop_valid` ",
                              "is not low when FIFO is empty. Expected ", "0, got %b"}, $time,
                               pop_valid));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_PopUnderflowHandling - `pop_valid` ",
                              "is low as expected when FIFO is empty."}, $time));
        end

        // Step 5: Monitor `pop_data` and ensure it remains in an undefined or zero state
        expected_pop_data = 'h0;  // Assuming zero state for undefined
        if (pop_data !== expected_pop_data) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_PopUnderflowHandling - `pop_data` ",
                              "is not in expected state. Expected %h, ", "got %h"}, $time,
                               expected_pop_data, pop_data));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_PopUnderflowHandling - `pop_data` ",
                              "is in expected state when FIFO is empty."}, $time));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_PopUnderflowHandling"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_PopUnderflowHandling"}, $time));
          err_count_arr[test_PopUnderflowHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_GrayCodeSynchronization;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_GrayCodeSynchronization"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_GrayCodeSynchronization. Stimuli is",
                      " not observed or it needs more time to ", "finish this test."}, $time));
        err_count_arr[test_GrayCodeSynchronizationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies the synchronization of gray-coded counters between push and pop sides of the FIFO.

        // Local variables declaration
        int test_failed = 0;
        int expected_pop_items;
        int data_to_push;
        int synchronized_gray_count;

        // Wait for reset to complete and FIFO to be ready
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_GrayCodeSynchronization - Waiting ",
                    "for FIFO reset completion."
                  },
                  $time
              )
          );
        while (push_ready !== 1 || pop_empty !== 1) begin
          @(posedge push_clk);
        end

        // Deassert reset and wait for FIFO to be ready
        @(posedge push_clk);
        push_rst = 0;
        pop_rst  = 0;
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_GrayCodeSynchronization - ", "Deasserting reset."
                  },
                  $time
              )
          );
        while (push_ready !== 1 || pop_empty !== 1) begin
          @(posedge push_clk);
        end

        // Drive push_valid high and provide data on push_data
        @(posedge push_clk);
        data_to_push = $urandom_range(0, (1 << Width) - 1);
        push_valid = 1;
        push_data = data_to_push;
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_GrayCodeSynchronization - Driving ",
                    "push_valid=1, push_data=0x%h."
                  },
                  $time,
                  data_to_push
              )
          );
        while (push_ready !== 1) begin
          @(posedge push_clk);
        end

        // Assert pop_ready and wait for pop_valid
        @(posedge pop_clk);
        pop_ready = 1;
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_GrayCodeSynchronization - Asserting", " pop_ready."
                  },
                  $time
              )
          );
        // repeat (3) @(posedge pop_clk);

        wait (pop_empty == 1'b0);

        fork
          begin
            @(negedge pop_clk);
            if (pop_valid !== 1) begin
              $display($sformatf({"Time: %0t, ERROR: ", "test_GrayCodeSynchronization - pop_valid",
                                  " not asserted as expected."}, $time));
              test_failed = 1;
            end else if (ENABLE_INFO_MESSAGES == 1) begin
              $display($sformatf({"Time: %0t, INFO: ", "test_GrayCodeSynchronization - pop_valid",
                                  " asserted as expected."}, $time));
            end
          end
        join_none

        // Read data from pop_data and check pop_items
        @(posedge pop_clk);
        expected_pop_items = 1;  // Since we pushed one item
        if (pop_data !== data_to_push) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_GrayCodeSynchronization - Data ",
                              "mismatch. Expected 0x%h, got 0x%h."}, $time, data_to_push,
                               pop_data));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_GrayCodeSynchronization - Data ",
                              "match. Expected and got 0x%h."}, $time, data_to_push));
        end

        // Check synchronized gray-encoded count
        // Assuming pop_items reflects the synchronized gray count
        synchronized_gray_count = pop_items;
        if (synchronized_gray_count !== expected_pop_items) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_GrayCodeSynchronization - Gray ",
                              "count mismatch. Expected %0d, got %0d."}, $time, expected_pop_items,
                               synchronized_gray_count));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ", "test_GrayCodeSynchronization - Gray ",
                              "count match. Expected and got %0d."}, $time, expected_pop_items));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_GrayCodeSynchronization"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_GrayCodeSynchronization"}, $time));
          err_count_arr[test_GrayCodeSynchronizationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_FinalStateAssertionVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_FinalStateAssertionVerification"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ", "test_FinalStateAssertionVerification. ",
                            "Stimuli is not observed or it needs more", " time to finish this test."
                             }, $time));
        err_count_arr[test_FinalStateAssertionVerificationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the FIFO is empty and no valid bits are asserted at the end of the test.

        // Local variables declaration
        int test_failed = 0;
        int cycle_counter;
        int random_data;
        int expected_data;

        // Wait for reset to complete
        @(posedge push_clk);

        // Deassert reset and wait for FIFO to be ready
        push_rst = 1'b0;
        pop_rst  = 1'b0;
        @(posedge push_clk);
        #RESET_DURATION;

        // Check if FIFO is ready for operation
        if (push_ready !== 1'b1 || pop_empty !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_FinalStateAssertionVerification - ",
                              "FIFO not ready after reset. push_ready: ", "%b, pop_empty: %b"},
                               $time, push_ready, pop_empty));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_FinalStateAssertionVerification - ",
                      "FIFO ready for operation after reset."
                    },
                    $time
                )
            );
        end

        // Push data into FIFO until full
        while (push_full !== 1'b1) begin
          if (push_ready !== 1'b1) begin
            $display($sformatf({"Time: %0t, ERROR: ", "test_FinalStateAssertionVerification - ",
                                "push_ready not asserted when expected."}, $time));
            test_failed = 1;
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_FinalStateAssertionVerification - ",
                        "Data pushed: 0x%h"
                      },
                      $time,
                      random_data
                  )
              );
            @(posedge push_clk);
            random_data = $urandom_range(0, (1 << Width) - 1);
            push_valid  = 1'b1;
            push_data   = random_data;
          end
        end
        push_valid = 1'b0;

        // Assert pop_ready and start popping data
        pop_ready = 1'b1;
        cycle_counter = 0;

        // Wait until pop_empty is deasserted indicating that the FIFO is not
        // empty
        wait (pop_empty == 1'b0);

        while (pop_empty !== 1'b1) begin
          @(posedge pop_clk);
          cycle_counter++;

          if (pop_valid !== 1'b1) begin
            if (cycle_counter > TIMEOUT) begin
              $display($sformatf({"Time: %0t, ERROR: ", "test_FinalStateAssertionVerification - ",
                                  "Timeout waiting for pop_valid."}, $time));
              test_failed = 1;
              break;
            end
          end else begin
            expected_data = random_data;  // Assuming data is popped in the same order it was pushed
            if (pop_data !== expected_data) begin
              $display($sformatf({"Time: %0t, ERROR: ", "test_FinalStateAssertionVerification - ",
                                  "Data mismatch. Expected: 0x%h, Got: 0x%h"}, $time,
                                   expected_data, pop_data));
              test_failed = 1;
            end else begin
              if (ENABLE_INFO_MESSAGES == 1)
                $display(
                    $sformatf(
                        {
                          "Time: %0t, INFO: ",
                          "test_FinalStateAssertionVerification - ",
                          "Data popped: 0x%h"
                        },
                        $time,
                        pop_data
                    )
                );
            end
          end
        end

        repeat (5) @(posedge push_clk);

        // Final check to ensure FIFO is empty
        if (pop_empty !== 1'b1 || push_full !== 1'b0) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_FinalStateAssertionVerification - ",
                              "Final state check failed. pop_empty: %b,", " push_full: %b"}, $time,
                               pop_empty, push_full));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_FinalStateAssertionVerification - ",
                      "FIFO is empty and push_full is ",
                      "deasserted."
                    },
                    $time
                )
            );
        end

        // Report test result
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_FinalStateAssertionVerification"},
                               $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_FinalStateAssertionVerification"},
                               $time));
          err_count_arr[test_FinalStateAssertionVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
