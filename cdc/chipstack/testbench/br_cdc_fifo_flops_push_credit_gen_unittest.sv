
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_cdc_fifo_flops_push_credit
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-17 22:25:50
// Description: Unit test for br_cdc_fifo_flops_push_credit
//=============================================================

module br_cdc_fifo_flops_push_credit_gen_unittest;
  timeunit 1ns; timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;  // Clock frequency in MHz
  parameter int RESET_DURATION = 100;  // Reset duration in ns
  parameter int TIMEOUT = 10000000;  // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000;  // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;  // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000;  // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks


  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int Depth = 2;
  parameter int Width = 1;
  parameter int MaxCredit = Depth;
  parameter bit RegisterPushOutputs = 0;
  parameter bit RegisterPopOutputs = 1;
  parameter bit RegisterResetActive = 1;
  parameter int NumSyncStages = 3;
  parameter int FlopRamDepthTiles = 1;
  parameter int FlopRamWidthTiles = 1;
  parameter int FlopRamAddressDepthStages = 0;
  parameter int FlopRamReadDataDepthStages = 0;
  parameter int FlopRamReadDataWidthStages = 0;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int AddrWidth = $clog2(Depth);
  localparam int CountWidth = $clog2((Depth + 1));
  localparam int CreditWidth = $clog2((MaxCredit + 1));

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic push_clk;
  logic pop_clk;
  logic push_rst;
  logic pop_rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic push_credit_stall;
  logic push_valid;
  logic [Width-1:0] push_data;
  logic pop_ready;
  logic [CreditWidth-1:0] credit_initial_push;
  logic [CreditWidth-1:0] credit_withhold_push;
  logic push_receiver_in_reset;
  logic push_sender_in_reset;
  logic push_credit;
  logic pop_valid;
  logic [Width-1:0] pop_data;
  logic push_full;
  logic [CountWidth-1:0] push_slots;
  logic [CreditWidth-1:0] credit_count_push;
  logic [CreditWidth-1:0] credit_available_push;
  logic pop_empty;
  logic [CountWidth-1:0] pop_items;

  //===========================================================
  // DUT Instantiation
  //===========================================================
  // Clock to DUT is inverted to avoid race condition between DUT and TB
  br_cdc_fifo_flops_push_credit #(
      .Depth(Depth),
      .Width(Width),
      .MaxCredit(MaxCredit),
      .RegisterPushOutputs(RegisterPushOutputs),
      .RegisterPopOutputs(RegisterPopOutputs),
      .RegisterResetActive(RegisterResetActive),
      .NumSyncStages(NumSyncStages),
      .FlopRamDepthTiles(FlopRamDepthTiles),
      .FlopRamWidthTiles(FlopRamWidthTiles),
      .FlopRamAddressDepthStages(FlopRamAddressDepthStages),
      .FlopRamReadDataDepthStages(FlopRamReadDataDepthStages),
      .FlopRamReadDataWidthStages(FlopRamReadDataWidthStages),
      .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
  ) dut (
      .push_clk(~push_clk),
      .pop_clk(~pop_clk),
      .push_rst(push_rst),
      .pop_rst(pop_rst),
      .push_credit_stall(push_credit_stall),
      .push_valid(push_valid),
      .push_data(push_data),
      .pop_ready(pop_ready),
      .credit_initial_push(credit_initial_push),
      .credit_withhold_push(credit_withhold_push),
      .push_sender_in_reset(push_sender_in_reset),
      .push_receiver_in_reset(push_receiver_in_reset),
      .push_credit(push_credit),
      .pop_valid(pop_valid),
      .pop_data(pop_data),
      .push_full(push_full),
      .push_slots(push_slots),
      .credit_count_push(credit_count_push),
      .credit_available_push(credit_available_push),
      .pop_empty(pop_empty),
      .pop_items(pop_items)
  );


  //===========================================================
  // Clock Generation
  //===========================================================
  assign pop_clk = push_clk;
  initial begin
    push_clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR / (2 * CLOCK_FREQ)) push_clk = ~push_clk;
  end


  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_credit_stall <= 'h0;
    push_valid <= 'h0;
    push_data <= 'h0;
    pop_ready <= 'h0;
    credit_initial_push <= 'h0;
    credit_withhold_push <= 'h0;

    // Wiggling the reset signal.
    push_rst = 1'bx;
    pop_rst  = 1'bx;
    #RESET_DURATION;
    push_rst = 1'b1;
    pop_rst  = 1'b1;
    #RESET_DURATION;
    push_rst = 1'b0;
    pop_rst  = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;

    // Drive push_sender_in_reset to 0
    push_sender_in_reset = 1'b0;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushPopFunctionalityIdx,
    test_CreditManagementVerificationIdx,
    test_ClockDomainSynchronizationIdx,
    test_BackpressureHandlingIdx,
    test_CornerCaseCreditOverflowIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

`ifdef WAVES_AS_FSDB
  bit enable_fsdb;
`endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
    if (NO_ASSERTS_ON_RESET) $assertoff;
    #(TIMEOUT);
    $display("Error: Testbench timeout!");
    $finish;
  end

`ifdef WAVES_AS_FSDB
  initial begin
    // Enable FSDB dump for TB and DUT
    if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
      $fsdbDumpfile("tb.fsdb");
      $fsdbDumpvars(0, br_cdc_fifo_flops_push_credit_gen_tb, "+all");
    end
  end
`endif


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushPopFunctionality();

    reset_dut();
    test_CreditManagementVerification();

    reset_dut();
    test_ClockDomainSynchronization();

    reset_dut();
    test_BackpressureHandling();

    reset_dut();
    test_CornerCaseCreditOverflow();

    if (err_count_arr[test_BasicPushPopFunctionalityIdx] == 0) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "PASSED"}));
    end else if (err_count_arr[test_BasicPushPopFunctionalityIdx] == -1) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ", "FAILED"}));
    end

    if (err_count_arr[test_CreditManagementVerificationIdx] == 0) begin
      $display($sformatf({"Test test_CreditManagementVerification ", "PASSED"}));
    end else if (err_count_arr[test_CreditManagementVerificationIdx] == -1) begin
      $display($sformatf({"Test test_CreditManagementVerification ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_CreditManagementVerification ", "FAILED"}));
    end

    if (err_count_arr[test_ClockDomainSynchronizationIdx] == 0) begin
      $display($sformatf({"Test test_ClockDomainSynchronization ", "PASSED"}));
    end else if (err_count_arr[test_ClockDomainSynchronizationIdx] == -1) begin
      $display($sformatf({"Test test_ClockDomainSynchronization ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_ClockDomainSynchronization ", "FAILED"}));
    end

    if (err_count_arr[test_BackpressureHandlingIdx] == 0) begin
      $display("Test test_BackpressureHandling PASSED");
    end else if (err_count_arr[test_BackpressureHandlingIdx] == -1) begin
      $display("Test test_BackpressureHandling TIMEOUT");
    end else begin
      $display("Test test_BackpressureHandling FAILED");
    end

    if (err_count_arr[test_CornerCaseCreditOverflowIdx] == 0) begin
      $display($sformatf({"Test test_CornerCaseCreditOverflow ", "PASSED"}));
    end else if (err_count_arr[test_CornerCaseCreditOverflowIdx] == -1) begin
      $display($sformatf({"Test test_CornerCaseCreditOverflow ", "TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_CornerCaseCreditOverflow ", "FAILED"}));
    end


    if (err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end


  task automatic test_BasicPushPopFunctionality;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_BasicPushPopFunctionality"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_BasicPushPopFunctionality. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_BasicPushPopFunctionalityIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task tests the basic push and pop functionality of the FIFO, ensuring it handles push operations until full and pop operations until empty.

        // Local variables declaration
        int test_failed = 0;
        int push_data_value;
        int pop_data_value;
        int credit_count;
        int push_count;
        int pop_count;

        // Initial delay to ensure stimulus propagation
        @(posedge push_clk);

        // Set initial credit
        credit_initial_push = 2;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_BasicPushPopFunctionality - Initial",
                    " credit set to %0d"
                  },
                  $time,
                  credit_initial_push
              )
          );

        @(posedge push_clk);
        // Initialize variables
        push_data_value = 0;
        credit_count = credit_initial_push;
        push_count = 0;
        pop_count = 0;

        // Push data until FIFO is full
        while (!push_full) begin
          push_valid = 1'b1;
          push_data  = push_data_value;
          @(posedge push_clk);

          if (!push_credit_stall) begin
            push_data_value = $urandom_range(0, (1 << Width) - 1);
            credit_count -= 1;
            push_count += 1;
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Pushed ",
                        "data: 0x%h, Credit count: %0d"
                      },
                      $time,
                      push_data,
                      credit_count
                  )
              );
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Push ",
                        "stalled, waiting for credit"
                      },
                      $time
                  )
              );
          end
        end

        // Check if FIFO is full
        if (push_full) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicPushPopFunctionality - FIFO is",
                      " full after %0d pushes"
                    },
                    $time,
                    push_count
                )
            );
        end else begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - FIFO ",
                              "did not reach full condition"}, $time));
          test_failed = 1;
        end

        wait (pop_empty == 1'b0);

        // Pop data until FIFO is empty
        pop_ready = 1'b1;
        @(posedge pop_clk);
        while (!pop_empty) begin
          @(posedge pop_clk);
          if (pop_valid) begin
            pop_data_value = pop_data;
            credit_count += 1;
            pop_count += 1;
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Popped ",
                        "data: 0x%h, Credit count: %0d"
                      },
                      $time,
                      pop_data_value,
                      credit_count
                  )
              );
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_BasicPushPopFunctionality - Waiting",
                        " for valid data to pop"
                      },
                      $time
                  )
              );
          end
        end

        // Check if FIFO is empty
        if (pop_empty) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BasicPushPopFunctionality - FIFO is",
                      " empty after %0d pops"
                    },
                    $time,
                    pop_count
                )
            );
        end else begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BasicPushPopFunctionality - FIFO ",
                              "did not reach empty condition"}, $time));
          test_failed = 1;
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_BasicPushPopFunctionality"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_BasicPushPopFunctionality"}, $time));
          err_count_arr[test_BasicPushPopFunctionalityIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_CreditManagementVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_CreditManagementVerification"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ", "test_CreditManagementVerification. ",
                            "Stimuli is not observed or it needs more", " time to finish this test."
                             }, $time));
        err_count_arr[test_CreditManagementVerificationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task verifies the FIFO's credit management system, ensuring correct handling of credit allocation and withholding during push operations.

        // Local variables declaration
        int test_failed = 0;
        int random_data;
        int initial_credit;
        int withheld_credit;

        // Ensure adequate stimulus propagation time
        @(posedge push_clk);

        // Step 1: Assert push_rst high for at least one full cycle of push_clk to reset the FIFO
        push_rst = 1'b1;
        @(posedge push_clk);
        push_rst = 1'b0;
        @(posedge push_clk);
        if (push_receiver_in_reset !== 1'b0) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_CreditManagementVerification - ",
                              "Reset failed. Expected ", "push_receiver_in_reset=0, got %b"},
                               $time, push_receiver_in_reset));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_CreditManagementVerification - ",
                      "Reset successful."
                    },
                    $time
                )
            );
        end

        // Step 2: Drive credit_initial_push with the default value Depth
        initial_credit = Depth;
        credit_initial_push = initial_credit;
        @(posedge push_clk);

        // Assert push_rst high for at least one full cycle of push_clk to reset the FIFO
        push_rst = 1'b1;
        @(posedge push_clk);
        push_rst = 1'b0;
        if (credit_count_push !== initial_credit) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_CreditManagementVerification - ",
                              "Initial credit setup failed. Expected ",
                              "credit_count_push=%0d, got %0d"}, $time, initial_credit,
                               credit_count_push));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_CreditManagementVerification - ",
                      "Initial credit setup successful. ",
                      "credit_count_push=%0d"
                    },
                    $time,
                    credit_count_push
                )
            );
        end

        // Step 3: Drive credit_withhold_push with a specific value
        @(posedge push_clk);
        withheld_credit = 1;  // Example value for withholding
        credit_withhold_push = withheld_credit;
        if (credit_available_push !== (initial_credit - withheld_credit)) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_CreditManagementVerification - ",
                              "Credit withholding failed. Expected ",
                              "credit_available_push=%0d, got %0d"}, $time,
                               (initial_credit - withheld_credit), credit_available_push));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_CreditManagementVerification - ",
                      "Credit withholding successful. ",
                      "credit_available_push=%0d"
                    },
                    $time,
                    credit_available_push
                )
            );
        end

        // Step 4: Assert push_valid high and drive random valid data on push_data
        push_valid  = 1'b1;
        random_data = $urandom_range(0, (1 << Width) - 1);
        push_data   = random_data;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_CreditManagementVerification - ",
                    "Driving push_data=0x%h"
                  },
                  $time,
                  push_data
              )
          );

        // Step 5: Monitor credit_count_push and credit_available_push for correct updates
        while (credit_available_push > 0) begin
          @(posedge push_clk);
          random_data = $urandom_range(0, (1 << Width) - 1);
          push_data   = random_data;
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_CreditManagementVerification - ",
                      "Driving push_data=0x%h"
                    },
                    $time,
                    push_data
                )
            );
        end

        // Step 6: Continue asserting push_valid high and drive data until push_full is high
        while (!push_full) begin
          @(posedge push_clk);
          random_data = $urandom_range(0, (1 << Width) - 1);
          push_data   = random_data;
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_CreditManagementVerification - ",
                      "Driving push_data=0x%h"
                    },
                    $time,
                    push_data
                )
            );
        end

        // Final check for test pass/fail status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_CreditManagementVerification"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_CreditManagementVerification"}, $time));
          err_count_arr[test_CreditManagementVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_ClockDomainSynchronization;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_ClockDomainSynchronization"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_ClockDomainSynchronization. Stimuli",
                      " is not observed or it needs more time ", "to finish this test."}, $time));
        err_count_arr[test_ClockDomainSynchronizationIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // Task to verify the FIFO's ability to synchronize data across different clock domains, maintaining data integrity and proper operation in asynchronous environments.

        // Local variables declaration
        int test_failed = 0;
        int random_data;
        int expected_data;

        // Ensure adequate stimulus propagation time
        @(posedge push_clk);

        // Step 1: Assert and deassert reset signals
        push_rst = 1'b1;
        pop_rst  = 1'b1;
        @(posedge push_clk);
        push_rst = 1'b0;
        pop_rst  = 1'b0;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_ClockDomainSynchronization - Reset ",
                    "applied and released."
                  },
                  $time
              )
          );

        // Step 2: Provide clock signals with different frequencies
        // This is handled by the testbench clock generation logic

        // Step 3: Assert push_valid with valid data and monitor push_credit_stall
        random_data = $urandom_range(0, (1 << Width) - 1);
        push_data   = random_data;
        push_valid  = 1'b1;
        @(posedge push_clk);
        if (push_credit_stall == 1'b0) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ", "test_ClockDomainSynchronization - Data ", "pushed: 0x%h"
                    },
                    $time,
                    random_data
                )
            );
        end else begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_ClockDomainSynchronization - ",
                              "push_credit_stall is high, data not ", "pushed."}, $time));
          test_failed = 1;
        end
        push_valid = 1'b0;

        wait (pop_empty == 1'b0);

        // Step 4: Assert pop_ready and wait for pop_valid
        pop_ready = 1'b1;
        @(posedge pop_clk);
        wait (pop_valid == 1'b1);
        if (pop_valid == 1'b1) begin
          expected_data = random_data;
          if (pop_data == expected_data) begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display(
                  $sformatf(
                      {
                        "Time: %0t, INFO: ",
                        "test_ClockDomainSynchronization - Data ",
                        "popped: 0x%h, matches expected: 0x%h"
                      },
                      $time,
                      pop_data,
                      expected_data
                  )
              );
          end else begin
            $display($sformatf({"Time: %0t, ERROR: ", "test_ClockDomainSynchronization - Data ",
                                "mismatch. Expected: 0x%h, got: 0x%h"}, $time, expected_data,
                                 pop_data));
            test_failed = 1;
          end
        end else begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_ClockDomainSynchronization - ",
                              "pop_valid not asserted, no data ", "available."}, $time));
          test_failed = 1;
        end
        pop_ready = 1'b0;

        // Step 5: Continuously monitor pop_valid and pop_data
        // Ensure ready-valid handshake protocol is correctly implemented
        @(posedge pop_clk);
        if (pop_valid == 1'b1 && pop_data == expected_data) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_ClockDomainSynchronization - ",
                      "Handshake successful, data integrity ",
                      "maintained."
                    },
                    $time
                )
            );
        end else begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_ClockDomainSynchronization - ",
                              "Handshake failed or data integrity ", "issue."}, $time));
          test_failed = 1;
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_ClockDomainSynchronization"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_ClockDomainSynchronization"}, $time));
          err_count_arr[test_ClockDomainSynchronizationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_BackpressureHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_BackpressureHandling"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ", "test_BackpressureHandling. Stimuli is ",
                            "not observed or it needs more time to ", "finish this test."}, $time));
        err_count_arr[test_BackpressureHandlingIdx] = -1;  // For timeout, set the error count to -1
      end
      begin
        // This task tests the FIFO's ability to handle backpressure by dynamically asserting and deasserting `push_credit_stall` and `pop_ready`, ensuring that the FIFO manages data flow without overflow or underflow.

        // Local variables declaration
        int test_failed = 0;
        int random_data;
        int initial_credits;

        // Initial delay to ensure stimulus propagation
        @(posedge push_clk);

        // Step 1: Reset the FIFO
        push_rst = 1'b1;
        pop_rst  = 1'b1;
        @(posedge push_clk);
        push_rst = 1'b0;
        pop_rst  = 1'b0;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_BackpressureHandling - Reset ",
                    "applied and released."
                  },
                  $time
              )
          );

        // Step 2: Set initial credits
        initial_credits = 2;  // Example value, can be adjusted
        credit_initial_push = initial_credits;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_BackpressureHandling - Initial ",
                    "credits set to %0d."
                  },
                  $time,
                  initial_credits
              )
          );

        // Step 3: Drive push_valid high with valid data and assert push_credit_stall
        random_data = $urandom_range(0, (1 << Width) - 1);
        push_valid = 1'b1;
        push_data = random_data;
        push_credit_stall = 1'b1;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_BackpressureHandling - Driving ",
                    "push_valid=1, push_data=0x%h, ",
                    "push_credit_stall=1."
                  },
                  $time,
                  random_data
              )
          );
        push_valid = 1'b0;

        // Step 4: Monitor push_credit and push_full
        @(posedge push_clk);
        if (push_credit !== 1'b0 || push_full !== 1'b0) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BackpressureHandling - push_credit ",
                              "or push_full incorrect. Expected ",
                              "push_credit=0, push_full=0, got ", "push_credit=%b, push_full=%b"},
                               $time, push_credit, push_full));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BackpressureHandling - push_credit ",
                      "and push_full are correct."
                    },
                    $time
                )
            );
        end

        // Step 5: Drive pop_ready high and deassert it
        pop_ready = 1'b1;
        @(posedge pop_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ", "test_BackpressureHandling - Driving ", "pop_ready=1."
                  },
                  $time
              )
          );

        wait (pop_empty == 1'b0);

        wait (pop_valid == 1'b1);

        // Step 6: Monitor pop_valid and pop_empty after two cycles
        repeat (2) @(posedge pop_clk);

        if (pop_valid !== 1'b0 || pop_empty !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_BackpressureHandling - pop_valid or",
                              " pop_empty incorrect. Expected ", "pop_valid=0, pop_empty=1, got ",
                              "pop_valid=%b, pop_empty=%b"}, $time, pop_valid, pop_empty));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_BackpressureHandling - pop_valid ",
                      "and pop_empty are correct."
                    },
                    $time
                )
            );
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_BackpressureHandling"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_BackpressureHandling"}, $time));
          err_count_arr[test_BackpressureHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_CornerCaseCreditOverflow;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ", "test_CornerCaseCreditOverflow"}, $time));
        $display($sformatf(
                     {"Time: %0t, INFO: Timeout: ", "test_CornerCaseCreditOverflow. Stimuli ",
                      "is not observed or it needs more time to", " finish this test."}, $time));
        err_count_arr[test_CornerCaseCreditOverflowIdx] = -1;
        // For timeout, set the error count to -1
      end
      begin
        // This task tests the FIFO's response to a potential credit overflow condition.
        // Local variables declaration
        int test_failed = 0;
        int random_data;
        localparam int MaxCreditValue = MaxCredit;
        localparam int CreditWidthParam = CreditWidth;
        logic [CreditWidthParam-1:0] initial_credit;
        logic [CreditWidthParam-1:0] withhold_credit;

        // Ensure stimulus propagation
        @(posedge push_clk);

        // Step 1: Set credit_initial_push close to MaxCredit
        initial_credit = MaxCreditValue - 1;
        credit_initial_push = initial_credit;

        // Step 2: Set credit_withhold_push to potentially exceed MaxCredit
        withhold_credit = 2;  // Example value that could cause overflow
        credit_withhold_push = withhold_credit;

        // Step 3: Reset the FIFO
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_CornerCaseCreditOverflow - Set ",
                    "credit_initial_push to %0d."
                  },
                  $time,
                  initial_credit
              )
          );
        push_rst = 1'b1;
        pop_rst  = 1'b1;
        @(posedge push_clk);
        push_rst = 1'b0;
        pop_rst = 1'b0;

        // Step 4: Drive push_valid high with valid data and monitor push_credit_stall
        random_data = $urandom_range(0, (1 << Width) - 1);
        push_valid = 1'b1;
        push_data = random_data;
        @(posedge push_clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display(
              $sformatf(
                  {
                    "Time: %0t, INFO: ",
                    "test_CornerCaseCreditOverflow - Driving ",
                    "push_valid with data 0x%h."
                  },
                  $time,
                  random_data
              )
          );

        // Step 5: Monitor credit_count_push and credit_available_push
        if (credit_count_push > MaxCreditValue || credit_available_push > MaxCreditValue) begin
          $display($sformatf({"Time: %0t, ERROR: ", "test_CornerCaseCreditOverflow - Credit ",
                              "overflow detected. credit_count_push: ",
                              "%0d, credit_available_push: %0d"}, $time, credit_count_push,
                               credit_available_push));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display(
                $sformatf(
                    {
                      "Time: %0t, INFO: ",
                      "test_CornerCaseCreditOverflow - Credit ",
                      "values within valid range. ",
                      "credit_count_push: %0d, ",
                      "credit_available_push: %0d"
                    },
                    $time,
                    credit_count_push,
                    credit_available_push
                )
            );
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ", "test_CornerCaseCreditOverflow"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ", "test_CornerCaseCreditOverflow"}, $time));
          err_count_arr[test_CornerCaseCreditOverflowIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
