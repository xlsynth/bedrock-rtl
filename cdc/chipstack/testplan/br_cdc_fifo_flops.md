## Simulation Unit Test Scenarios
### File: ./cdc/rtl/br_cdc_fifo_flops.sv

|Name|Description|
|---|---|
|BasicPushPopFunctionality|This scenario tests the basic functionality of the FIFO by pushing data until it is full and then popping data until it is empty. It verifies that the FIFO correctly handles data flow and updates its status signals accordingly.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `push_rst` to reset the FIFO and waits for the design to drive `push_ready` low, indicating the reset state.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `push_rst` and waits for the design to drive `push_ready` high, indicating the FIFO is ready to accept data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` high and provides data on `push_data`, then waits for the design to drive `push_ready` high, confirming data acceptance.  <br><br>&nbsp;&nbsp;&nbsp; - Repeat the push operation until the design drives `push_full` high, indicating the FIFO is full.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` and waits for the design to drive `pop_valid` high, indicating data is available for popping.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench reads data from `pop_data` and waits for the design to update `pop_items` accordingly.  <br><br>&nbsp;&nbsp;&nbsp; - Repeat the pop operation until the design drives `pop_empty` high, indicating the FIFO is empty.  <br><br>|
|PushBackpressureHandling|Check that the FIFO correctly handles backpressure on the push side by maintaining data stability and deasserting `push_ready` when full.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `push_rst` to reset the FIFO and waits for `<h1>RESET_DURATION` for the design to drive `push_ready` low, indicating the reset state.</h1><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `push_rst` and waits for the design to eventually drive `push_ready` high, indicating the FIFO is ready to accept data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` high and provides data on `push_data` with width determined by the `Width` parameter, then waits for the design to eventually drive `push_ready` high, confirming data acceptance.  <br><br>&nbsp;&nbsp;&nbsp; - Repeat the push operation until the design drives `push_full` high, indicating the FIFO is full.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench continues to drive `push_valid` high and monitors `push_ready`, waiting for it to be driven low by the design, indicating backpressure.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench ensures that `push_data` remains stable while `push_ready` is low, verifying data stability during backpressure.  <br><br>&nbsp;&nbsp;&nbsp; - Additionally, the testbench monitors `push_slots` to verify the number of available slots, checks `pop_empty` to confirm the FIFO's empty state, and ensures gray code synchronization for data integrity.  <br><br>|
|PopUnderflowHandling|Check that the FIFO correctly handles pop operations when it is empty by asserting `pop_empty` and ensuring `pop_data` is not valid.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_rst` for at least one cycle of `pop_clk` to reset the FIFO and waits for the design to eventually drive `pop_empty` high, indicating the FIFO is empty.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `pop_rst` and waits for a few cycles of `pop_clk` for the design to eventually drive `pop_empty` high, confirming the FIFO is still empty.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` and monitors `pop_valid`, waiting for it to remain low, indicating no data is available for popping.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_data` and ensures it remains in an undefined or zero state while `pop_empty` is high, verifying data integrity during underflow.  <br><br>|
|GrayCodeSynchronization|Check that the FIFO correctly synchronizes gray-coded counters between the push and pop sides, maintaining data integrity across clock domains.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `push_rst` and `pop_rst` to reset the FIFO and waits for the design to drive `push_ready` high and `pop_empty` high, indicating the reset state. The testbench monitors `push_ready` and `pop_empty`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `push_rst` and `pop_rst` and waits for the design to drive `push_ready` high and `pop_empty` high, confirming the FIFO is ready for operation. The testbench monitors `push_ready` and `pop_empty`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` high and provides data on `push_data`, then waits for the design to drive `push_ready` high, confirming data acceptance. The testbench monitors `push_ready`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` and waits for 3 clock cycles for the design to drive `pop_valid` high, indicating data is available for popping. The testbench monitors `pop_valid`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench reads data from `pop_data` and waits for the design to update `pop_items` accordingly. The testbench monitors `pop_items`.  <br><br>&nbsp;&nbsp;&nbsp; - Check that the synchronized gray-encoded count accurately represents the number of items that can be popped from the FIFO by comparing the synchronized count with the expected number of items based on the push operations performed. The testbench monitors the synchronized gray-encoded count.  <br><br>|
|FinalStateAssertionVerification|Check that the FIFO is empty and no valid bits are asserted at the end of the test, verifying proper FIFO operation.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `push_rst` and `pop_rst` to reset the FIFO and waits for `<h1>RESET_DURATION` for the design to drive `push_ready` low and `pop_empty` high, indicating the reset state.</h1><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `push_rst` and `pop_rst` and waits for `<h1>RESET_DURATION` for the design to drive `push_ready` high and `pop_empty` high, confirming the FIFO is ready for operation.</h1><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` high and assigns a random value to `push_data` using `$urandom_range`, then waits for one clock cycle for the design to drive `push_ready` high, confirming data acceptance.  <br><br>&nbsp;&nbsp;&nbsp; - Repeat the push operation until the design drives `push_full` high, indicating the FIFO is full.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` and starts a cycle counter, waiting for the design to drive `pop_valid` high within `TIMEOUT` cycles, indicating data is available for popping. If `pop_valid` is not high within `TIMEOUT` cycles, log an error; otherwise, log an informational message.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench reads data from `pop_data` and waits for the design to update `pop_items` accordingly, ensuring data integrity by comparing `pop_data` with the expected random data.  <br><br>&nbsp;&nbsp;&nbsp; - Repeat the pop operation until the design drives `pop_empty` high, indicating the FIFO is empty.  <br><br>&nbsp;&nbsp;&nbsp; - Check that `pop_empty` is asserted and `push_full` is deasserted, confirming the FIFO is empty at the end of the test.  <br><br>|
