## Simulation Unit Test Scenarios
### File: ./cdc/rtl/br_cdc_bit_toggle.sv

|Name|Description|
|---|---|
|BasicSignalSynchronization|Check that the `br_cdc_bit_toggle` module correctly synchronizes the `src_bit` signal to the `dst_bit` signal using 3 synchronization stages without an additional source flop.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - Initially, the testbench asserts both `src_rst` and `dst_rst` to reset the system, ensuring all flip-flops and logic elements are in a known state. The testbench then deasserts both `src_rst` and `dst_rst` to allow the system to begin normal operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives the input port `src_bit` with a logic level `1` and asserts the `src_clk` to capture the signal. The testbench monitors the `src_bit` to ensure it remains stable for at least one full clock cycle of the `src_clk`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive the output port `dst_bit` with the value `1` eventually, after a delay of 3 clock cycles due to the synchronization stages.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives the input port `src_bit` with a logic level `0` and asserts the `src_clk` to capture the signal. The testbench monitors the `src_bit` to ensure it remains stable for at least one full clock cycle of the `src_clk`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive the output port `dst_bit` with the value `0` eventually, after a delay of 3 clock cycles due to the synchronization stages.  <br><br>|
|SourceFlopEnabled|Check that the signal synchronization process correctly captures and transfers the `src_bit` to `dst_bit` with the additional source flop enabled (`AddSourceFlop` = 1), ensuring proper delay and stability across clock domains.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives the input port `src_bit` with a logic level `1` and asserts the `src_clk`. The testbench monitors the design to ensure that the `src_bit` is captured by the additional source flop on the rising edge of `src_clk`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for `NumStages + 1` clock cycles after asserting `src_clk` and then monitors the output port `dst_bit`. Check that the design eventually drives the output port `dst_bit` with the value `1`, reflecting the synchronized `src_bit`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives the input port `src_bit` with a logic level `0` and asserts the `src_clk`. The testbench monitors the design to ensure that the `src_bit` is captured by the additional source flop on the rising edge of `src_clk`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for `NumStages + 1` clock cycles after asserting `src_clk` and then monitors the output port `dst_bit`. Check that the design eventually drives the output port `dst_bit` with the value `0`, reflecting the synchronized `src_bit`.  <br><br>|
|MaximumDelayCheck|Check that the signal `src_bit` propagates to `dst_bit` across clock domains with the maximum expected delay, ensuring signal integrity and synchronization with the default number of stages (`NumStages` = 3).  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives the input port `src_bit` with a logic level `1` and asserts the `src_clk` to initiate the signal propagation. The testbench monitors the `src_clk` to ensure it is asserted.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive the output port `dst_bit` with the value `1` eventually, considering the maximum expected delay of 3 cycles due to the synchronization stages. The testbench monitors `dst_bit` to verify this behavior.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives the input port `src_bit` with a logic level `0` and asserts the `src_clk` to initiate the signal propagation. The testbench monitors the `src_clk` to ensure it is asserted.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive the output port `dst_bit` with the value `0` eventually, considering the maximum expected delay of 3 cycles due to the synchronization stages. The testbench monitors `dst_bit` to verify this behavior.  <br><br>|
|SignalIntegrityUnderReset|Check that the `dst_bit` signal maintains integrity during reset conditions and is correctly synchronized after reset deassertion.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `src_rst` and `dst_rst` (active high) to reset the design and waits for the design to drive the output port `dst_bit` with the reset value `0`. The testbench monitors `dst_bit` for this expected behavior.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `src_rst` and `dst_rst` and waits for at least `NumStages` clock cycles before driving the input port `src_bit` with a logic level `1`. The testbench monitors `src_bit` to ensure it is driven correctly.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `src_clk` to capture the `src_bit` signal on the rising edge, as `AddSourceFlop` is enabled. The testbench waits for the design to drive the output port `dst_bit` with the value `1` eventually, after a delay of `NumStages + 1` cycles due to the synchronization stages. The testbench monitors `dst_bit` for this expected behavior.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives the input port `src_bit` with a logic level `0` and asserts `src_clk` to capture the signal on the rising edge. The testbench monitors `src_bit` to ensure it is driven correctly.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive the output port `dst_bit` with the value `0` eventually, after a delay of `NumStages + 1` cycles due to the synchronization stages. The testbench monitors `dst_bit` for this expected behavior.  <br><br>|
