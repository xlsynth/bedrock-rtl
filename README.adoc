// Copyright 2024 The Bedrock-RTL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

= Bedrock-RTL

WARNING: UNDER CONSTRUCTION. Everything is broken.

High quality and composable base RTL libraries in Verilog

== Prerequisites

You need to have the following tools installed in your environment.

* Bazel (tested with 7.3.1)
* pre-commit (tested with 3.8.0)
* Your own EDA tools (for running tests)

#TODO(mgottscho): Add more as we implement more things.#

== Pre-Commit Hooks

We use pre-commit hooks to enforce code quality. To install the hooks, run:

[source,shell]
----
pre-commit install
----

They should automatically run on every commit.
You can also run them manually via:

[source,shell]
----
pre-commit run
----

== Building and Testing

:bazel: https://bazel.build/

We use the powerful {bazel}[Bazel^] build system to assemble filelists and to run all tests (elaboration, lint, simulation, and formal).

A one-step command builds and runs all tests:

[source,shell]
----
bazel test //...
----

[IMPORTANT]
.Action required for tests to pass!
====
By default, the Bazel tests will fail because they call a placeholder wrapper script that does not reference any particular vendor EDA tool.
We do this because:

1. We want to keep test definitions as vendor-agnostic as possible.
2. Certain vendors may have non-disclosure agreements that protect usage of their APIs or licensing agreements that restrict where and how the tools can be run.

You will need to point Bazel to a "real" implementation of the wrapper script to be able to run the tests.
====

The Bazel test rule implementations at `//bazel:verilog.bzl` shell out to a program with a generic EDA vendor tool-agnostic API that actually implements the test.
By default, a placeholder tool called `placeholder_verilog_runner.py` is used. It implements the argument parsing part of the API but does nothing other than fail the test.
This placeholder test is generated by Bazel during the build with `//bazel:write_placeholder_verilog_runner_py.bzl`.

To use a real implementation of the script, you tell Bazel where to find it by setting `--action_env=BAZEL_VERILOG_RUNNER_TOOL=/path/to/your/verilog_runner.py` on the command line or in the `.bazelrc` file.

== Continuous Integration

Using GitHub Actions, which currently just runs pre-commit checks.

#TODO(mgottscho): Find a way to have CI run Bazel tests using real EDA tools.#

== Style Guide

:xlsynth-verilog-style-guide: https://github.com/xlsynth/verilog-style-guides/blob/master/VerilogCodingStyle.md
:lowrisc-verilog-style-guide: https://github.com/lowrisc/verilog-style-guides/blob/master/VerilogCodingStyle.md

We follow the {xlsynth-verilog-style-guide}[xlsynth Verilog Style Guide^], which is a fork of the {lowrisc-verilog-style-guide}[lowRISC style guide^] with some minor differences.

== Bazel Rules for Verilog

This repository defines several generally-helpful Bazel Verilog rules that you can use in your own projects.

=== `verilog_library` (external)

:verilog-library: https://github.com/hdl/bazel_rules_hdl/blob/main/verilog/providers.bzl

The `verilog_library` rule is used to collect Verilog source and header files and track their dependencies.
The original definition of the `verilog_library` rule can be found {verilog-library}[here^].
We pick up that rule dependency transitively (see the top-level `MODULE.bazel`).

.Using `verilog_library`
[%collapsible]
====
[source,bazel]
----
load("@rules_hdl//verilog:providers.bzl", "verilog_library")

verilog_library(
    name = "bar",
    srcs = ["bar.sv"],
    hdrs = ["baz.svh"]
)

verilog_library(
    name = "foo",
    srcs = ["foo.sv"],
    deps = [":bar"],
)
----
====

== Other rules

Please see link:bazel/verilog_rules.md[] for documentation on rules defined in this repository.

== Using Bedrock

:bzlmod: https://docs.bazel.build/versions/5.1.0/bzlmod.html

Usage is best illustrated with an example using the {bzlmod}[bzlmod^] dependency management system in Bazel.

TIP: You are not required to use Bazel to depend on Bedrock-RTL.
You can also use the Verilog files directly in your own projects (e.g., with git submodule, git subtree, or some other method).

In your project's `MODULE.bazel`:

.`MODULE.bazel`
[%collapsible]
====
[source,bzl]
----
module(name = "your-project")

bazel_dep(name = "bedrock-rtl", version = "0.0.1")
git_override(
    module_name = "bedrock-rtl",
    commit = <fill_in_git_commit_sha>,
    remote = "https://github.com/xlsynth/bedrock-rtl",
)

rules_hdl_extension = use_extension("@bedrock-rtl//dependency_support/rules_hdl:extension.bzl", "rules_hdl_extension")
use_repo(rules_hdl_extension, "rules_hdl")
----
====

Then suppose you have the following SystemVerilog module called `datapath_join.sv`:

.`datapath_join.sv`
[%collapsible]
====
[source,verilog]
----
// An example design using two Bedrock-RTL modules: br_flow_reg_fwd and br_flow_join.
//
// Joins two or more equal-bitwidth datapaths into a single output datapath.
// Uses ready/valid protocol on all flows.
// Push-side is registered.

`include "br_asserts.svh"

module datapath_join #(
    parameter int NumFlows = 2,  // must be at least 2
    parameter int BitWidthPerFlow = 32  // must be at least 1
) (
    input logic clk,
    input logic rst,
    output logic [NumFlows-1:0] push_ready,
    input logic [NumFlows-1:0] push_valid,
    input logic [NumFlows-1:0][BitWidthPerFlow-1:0] push_data,
    input logic pop_ready,
    output logic pop_valid,
    output logic [(NumFlows*BitWidthPerFlow)-1:0] pop_data
);

  `BR_ASSERT_STATIC(numflows_gte_2_a, NumFlows >= 2)
  `BR_ASSERT_STATIC(bitwidthperflow_gte_1_a, BitWidthPerFlow >= 1)

  logic [NumFlows-1:0] inter_ready;
  logic [NumFlows-1:0] inter_valid;
  logic [NumFlows-1:0][BitWidthPerFlow-1:0] inter_data;

  for (genvar i = 0; i < NumFlows; i++) begin : gen_regs
    br_flow_reg_fwd #(
        .BitWidth(BitWidthPerFlow)
    ) br_flow_reg_fwd (
        .clk,
        .rst,
        .push_ready(push_ready[i]),
        .push_valid(push_valid[i]),
        .push_data (push_data[i]),
        .pop_ready (inter_ready[i]),
        .pop_valid (inter_valid[i]),
        .pop_data  (inter_data[i])
    );
  end

  br_flow_join #(
      .NumFlows(NumFlows)
  ) br_flow_join (
      .clk,
      .rst,
      .push_ready(inter_ready),
      .push_valid(inter_valid),
      .pop_ready (pop_ready),
      .pop_valid (pop_valid)
  );

  assign pop_data = inter_data;  // direct concat

endmodule : datapath_join
----
====

Your `BUILD.bazel` file could then do this:

.`BUILD.bazel`
[%collapsible]
====
[source,bzl]
----
load("@bedrock-rtl//bazel:verilog.bzl", "verilog_elab_and_lint_test_suite", "verilog_elab_test", "verilog_lint_test")
load("@rules_hdl//verilog:providers.bzl", "verilog_library")

package(default_visibility = ["//visibility:private"])

verilog_library(
    name = "datapath_join",
    srcs = ["datapath_join.sv"],
    deps = [
        "@bedrock-rtl//flow/rtl:br_flow_join",
        "@bedrock-rtl//flow/rtl:br_flow_reg_fwd",
        "@bedrock-rtl//macros:br_asserts",
    ],
)

verilog_elab_test(
    name = "datapath_join_elab_test",
    deps = [":datapath_join"],
)

verilog_lint_test(
    name = "datapath_join_lint_test",
    deps = [":datapath_join"],
)

verilog_elab_and_lint_test_suite(
    name = "datapath_join_test_suite",
    params = {
        "NumFlows": [
            "2",
            "3",
        ],
        "BitWidthPerFlow": [
            "1",
            "64",
        ],
    },
    deps = [":datapath_join"],
)
----
====

== Macros

The following table lists all the macros that we plan to have in the Bedrock-RTL library.

TODO(mgottscho): WIP

| macros
a| Macros for inferring flip-flop registers with combinations of the following features.

* [x] Posedge clock
* [x] Active-high sync/async reset
* [x] Initial value
* [x] Load enable

Macros for SystemVerilog assertions.

* [x] Static
* [x] Concurrent
* [x] Immediate
* [x] Bedrock library-internal


== Modules

The following table lists all the modules that we plan to have in the Bedrock-RTL library.

[cols="1,2,1,4,1,1"]
|===
| Prefix | Category | Module | Description | Implemented | Verified

| arb
| Arbiters
| `br_arb_fixed`
| Fixed priority
| Yes
|

| arb
| Arbiters
| `br_arb_lru`
| Least-recently used
| Yes
|

| arb
| Arbiters
| `br_arb_rr`
| Round-robin
| Yes
|

| cdc
| Clock-domain crossing
| `br_cdc_bit`
| Single-bit CDC
|
|

| cdc
| Clock-domain crossing
| `br_cdc_fifo_ctrl_1r1w`
| Bus CDC using a dual-clock FIFO controller for a 1R1W dual-clock SRAM
|
|

| cdc
| Clock-domain crossing
| `br_cdc_fifo_flops`
| Bus CDC using a dual-clock FIFO with internal flop-RAM
|
|

| counter
| Counters
| `br_counter_incr`
| Incrementing counter
| Yes
|

| counter
| Counters
| `br_counter_decr`
| Decrementing counter
| Yes
|

| counter
| Counters
| `br_counter`
| Up-down counter
| Yes
|

| counter
| Counters
| `br_counter_sat`
| Up-down saturating counter
|
|

| credit
| Credit
| `br_credit_counter`
| Credit counter
| Yes
|

| credit
| Credit
| `br_credit_sender`
| Ready/valid to credit/valid converter (credit-loop sender-side)
| Yes
|

| credit
| Credit
| `br_credit_receiver`
| Credit/valid to ready/valid converter (credit-loop receiver-side)
| Yes
|

| delay
| Fixed-delay pipelines
| `br_delay`
| With reset
| Yes
|

| delay
| Fixed-delay pipelines
| `br_delay_nr`
| Without reset
| Yes, but want to merge with `br_delay` (https://github.com/xlsynth/bedrock-rtl/issues/137)
|

| delay
| Fixed-delay pipelines
| `br_delay_valid`
| With self-gating (valid)
| Yes
|

| delay
| Fixed-delay pipelines
| `br_delay_valid_next`
| With self-gating (valid-next)
| Yes
|

| delay
| Fixed-delay pipelines
| `br_delay_valid_next_nr`
| With self-gating (valid-next) and without reset
| Yes, but want to merge with `br_delay_valid_next` (https://github.com/xlsynth/bedrock-rtl/issues/137)
|

| ecc
| Error correcting codes
| `br_ecc_parity_enc`
| Parity encoder
|
|

| ecc
| Error correcting codes
| `br_ecc_parity_dec`
| Parity decoder
|
|

| ecc
| Error correcting codes
| `br_ecc_secded_enc`
| Single-error-correcting, double-error-detecting encoder
|
|

| ecc
| Error correcting codes
| `br_ecc_secded_dec`
| Single-error-correcting, double-error-detecting decoder
|
|

| enc
| Encoders
| `br_enc_bin2gray`
| Binary to gray
| Yes
|

| enc
| Encoders
| `br_enc_bin2onehot`
| Binary to onehot
| Yes
|

| enc
| Encoders
| `br_enc_gray2bin`
| Gray to binary
| Yes
|

| enc
| Encoders
| `br_enc_onehot2bin`
| One-hot to binary
| Yes
|

| enc
| Encoders
| `br_enc_priority`
| Priority encoder
| Yes
|

| fifo
| FIFOs
| `br_fifo_ctrl_1r1w`
| FIFO controller with external RAM port for 1R1W, ready/valid push and ready/valid pop
| Yes
|

| fifo
| FIFOs
| `br_fifo_ctrl_1r1w_bare`
| FIFO controller with external RAM port for 1R1W, without any push or pop flow control
|
|

| fifo
| FIFOs
| `br_fifo_ctrl_1r1w_pop_credit`
| FIFO controller with external RAM port for 1R1W, ready/valid push and credit/valid pop
|
|

| fifo
| FIFOs
| `br_fifo_ctrl_1r1w_push_credit`
| FIFO controller with external RAM port for 1R1W, credit/valid push and ready/valid pop
| Yes
|

| fifo
| FIFOs
| `br_fifo_flops`
| FIFO with internal flop RAM, ready/valid push and ready/valid pop
| Yes
|

| fifo
| FIFOs
| `br_fifo_flops_pop_credit`
| FIFO with internal flop RAM, ready/valid push and credit/valid pop
|
|

| fifo
| FIFOs
| `br_fifo_flops_push_credit`
| FIFO with internal flop RAM, credit/valid push and ready/valid pop
| Yes
|


| flow
| Ready/valid pipelines
| `br_flow_arb_fixed`
| Fixed priority arbiter with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_arb_lru`
| Least-recently used arbiter with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_arb_rr`
| Round-robin arbiter with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_demux_select`
| Registered demultiplexer (user select) with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_demux_select_unstable`
| Combinational demultiplexer (user select) with unstable flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_fork`
| Datapath flow control split
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_join`
| Datapath flow control join
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_mux_fixed`
| Fixed priority arbitrated multiplexer with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_mux_lru`
| Least-recently used arbitrated multiplexer with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_mux_rr`
| Round-robin arbitrated multiplexer with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_mux_select`
| Registered multiplexer (user select) with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_mux_select_unstable`
| Combinational multiplexer (user select) with unstable flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_reg_both`
| Pipeline register, registered forward and reverse signals, with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_reg_fwd`
| Pipeline register, registered forward signals, with flow control
| Yes
|

| flow
| Ready/valid pipelines
| `br_flow_reg_rev`
| Pipeline register, registered backward signals, with flow control
| Yes
|

|===

TODO(mgottscho): WIP

| ram
a| Memories

* [x] Parameterizable Flop RAM
* [ ] CAM
* [ ] Addressing helpers
* [ ] Hazard detection

| rdc
a| Reset domain crossings

* [ ] Reset controls
* [ ] Reset handshakes

| timer
a| Timers

* [ ] Watchdog
* [ ] Rollover



== Packages

The following table lists all the packages that we plan to have in the Bedrock-RTL library.

TODO(mgottscho): WIP
