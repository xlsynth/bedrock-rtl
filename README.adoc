// Copyright 2024 The Bedrock-RTL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

= Bedrock-RTL

WARNING: UNDER CONSTRUCTION. Everything is broken.

High quality and composable base RTL libraries in Verilog

== Prerequisites

You need to have the following tools installed in your environment.

* Bazel (tested with 7.3.1)
* pre-commit (tested with 3.8.0)
* Your own EDA tools (for running tests)

#TODO(mgottscho): Add more as we implement more things.#

== Pre-Commit Hooks

We use pre-commit hooks to enforce code quality. To install the hooks, run:

[source,shell]
----
pre-commit install
----

They should automatically run on every commit.
You can also run them manually via:

[source,shell]
----
pre-commit run
----

== Building and Testing

:bazel: https://bazel.build/

We use the powerful {bazel}[Bazel^] build system to assemble filelists and to run all tests (elaboration, lint, simulation, and formal).

A one-step command builds and runs all tests:

[source,shell]
----
bazel test //...
----

[IMPORTANT]
.Action required for tests to pass!
====
By default, the Bazel tests will fail because they call a placeholder wrapper script that does not reference any particular vendor EDA tool.
We do this because:

1. We want to keep test definitions as vendor-agnostic as possible.
2. Certain vendors may have non-disclosure agreements that protect usage of their APIs or licensing agreements that restrict where and how the tools can be run.

You will need to point Bazel to a "real" implementation of the wrapper script to be able to run the tests.
====

The Bazel test rule implementations at `//bazel:verilog.bzl` shell out to a program with a generic EDA vendor tool-agnostic API that actually implements the test.
By default, a placeholder tool called `placeholder_verilog_test.py` is used. It implements the argument parsing part of the API but does nothing other than fail the test.
This placeholder test is generated by Bazel during the build with `//bazel:write_placeholder_verilog_test_py.bzl`.

To use a real implementation of the script, you tell Bazel where to find it by setting `--action_env=BAZEL_VERILOG_TEST_TOOL=/path/to/your/verilog_test.py` on the command line or in the `.bazelrc` file.

== Continuous Integration

Using GitHub Actions, which currently just runs pre-commit checks.

#TODO(mgottscho): Find a way to have CI run Bazel tests using real EDA tools.

== Style Guide

:xlsynth-verilog-style-guide: https://github.com/xlsynth/verilog-style-guides/blob/master/VerilogCodingStyle.md
:lowrisc-verilog-style-guide: https://github.com/lowrisc/verilog-style-guides/blob/master/VerilogCodingStyle.md

We follow the {xlsynth-verilog-style-guide}[xlsynth Verilog Style Guide^], which is a fork of the {lowrisc-verilog-style-guide}[lowRISC style guide^] with some minor differences.

== Bazel Rules for Verilog

This repository defines several generally-helpful Bazel Verilog rules that you can use in your own projects.

=== `verilog_library` (external)

:verilog-library: https://github.com/hdl/bazel_rules_hdl/blob/main/verilog/providers.bzl

The `verilog_library` rule is used to collect Verilog source and header files and track their dependencies.
The original definition of the `verilog_library` rule can be found {verilog-library}[here^].
We pick up that rule dependency transitively (see the top-level `MODULE.bazel`).

.Using `verilog_library`
[%collapsible]
====
[source,bazel]
----
load("@rules_hdl//verilog:providers.bzl", "verilog_library")

verilog_library(
    name = "bar",
    srcs = ["bar.sv"],
    hdrs = ["baz.svh"]
)

verilog_library(
    name = "foo",
    srcs = ["foo.sv"],
    deps = [":bar"],
)
----
====

== `verilog_elab_test`

The `verilog_elab_test` rule tests that a top-level Verilog design can be statically analyzed and elaborated without errors.

.Using `verilog_elab_test`
[%collapsible]
====
[source,bazel]
----
load("@bedrock-rtl//bazel:verilog.bzl", "verilog_elab_test")

...

verilog_elab_test(
    name = "foo_elab_test",
    deps = [":foo"],
)
----
====

== `verilog_lint_test`

The `verilog_lint_test` rule tests that a top-level Verilog design can pass a set of lint rules without errors.

.Using `verilog_lint_test`
[%collapsible]
====
[source,bazel]
----
load("@bedrock-rtl//bazel:verilog.bzl", "verilog_lint_test")

...

verilog_lint_test(
    name = "foo_lint_test",
    deps = [":foo"],
)
----
====

== `verilog_sim_test`

The `verilog_sim_test` rule tests that a top-level Verilog design can one-step compile, elaborate, and simulate without errors.
It is designed for basic unit tests, not complex scenarios that require multi-step compilation, elaboration, and simulation processes.

.Using `verilog_sim_test`
[%collapsible]
====
[source,bazel]
----
load("@bedrock-rtl//bazel:verilog.bzl", "verilog_sim_test")

...

verilog_sim_test(
    name = "foo_vcs_test",
    deps = [":foo_tb"],
    tool = "vcs",
)
----
====

== `verilog_fpv_test`

The `verilog_fpv_test` rule tests that a top-level Verilog design can one-step compile, elaborate, and pass formal property verification (FPV) checks without errors.
It is designed for basic unit tests, not complex scenarios that require multi-step compilation, elaboration, and formal processes.

.Using `verilog_fpv_test`
[%collapsible]
====
[source,bazel]
----
load("@bedrock-rtl//bazel:verilog.bzl", "verilog_fpv_test")

...

verilog_fpv_test(
    name = "foo_jg_test",
    deps = [":foo_tb"],
    tool = "jg",
)
----
====

== Using Bedrock

:bzlmod: https://docs.bazel.build/versions/5.1.0/bzlmod.html

Usage is best illustrated with an example using the {bzlmod}[bzlmod^] dependency management system in Bazel.

TIP: You are not required to use Bazel to depend on Bedrock-RTL.
You can also use the Verilog files directly in your own projects (e.g., with git submodule, git subtree, or some other method).

In your project's `MODULE.bazel`:

.`MODULE.bazel`
[%collapsible]
====
[source,bzl]
----
module(name = "your-project")

bazel_dep(name = "bedrock-rtl", version = "0.0.1")
git_override(
    module_name = "bedrock-rtl",
    commit = <fill_in_git_commit_sha>,
    remote = "https://github.com/xlsynth/bedrock-rtl",
)

rules_hdl_extension = use_extension("@bedrock-rtl//dependency_support/rules_hdl:extension.bzl", "rules_hdl_extension")
use_repo(rules_hdl_extension, "rules_hdl")
----
====

Then suppose you have the following SystemVerilog module called `datapath_join.sv`:

.`datapath_join.sv`
[%collapsible]
====
[source,verilog]
----
// An example design using two Bedrock-RTL modules: br_flow_reg_fwd and br_flow_join.
//
// Joins two or more equal-bitwidth datapaths into a single output datapath.
// Uses ready/valid protocol on all flows.
// Push-side is registered.

`include "br_asserts.svh"

module datapath_join #(
    parameter int NumFlows = 2,  // must be at least 2
    parameter int BitWidthPerFlow = 32  // must be at least 1
) (
    input logic clk,
    input logic rst,
    output logic [NumFlows-1:0] push_ready,
    input logic [NumFlows-1:0] push_valid,
    input logic [NumFlows-1:0][BitWidthPerFlow-1:0] push_data,
    input logic pop_ready,
    output logic pop_valid,
    output logic [(NumFlows*BitWidthPerFlow)-1:0] pop_data
);

  `BR_ASSERT_STATIC(numflows_gte_2_a, NumFlows >= 2)
  `BR_ASSERT_STATIC(bitwidthperflow_gte_1_a, BitWidthPerFlow >= 1)

  logic [NumFlows-1:0] inter_ready;
  logic [NumFlows-1:0] inter_valid;
  logic [NumFlows-1:0][BitWidthPerFlow-1:0] inter_data;

  for (genvar i = 0; i < NumFlows; i++) begin : gen_regs
    br_flow_reg_fwd #(
        .BitWidth(BitWidthPerFlow)
    ) br_flow_reg_fwd (
        .clk,
        .rst,
        .push_ready(push_ready[i]),
        .push_valid(push_valid[i]),
        .push_data (push_data[i]),
        .pop_ready (inter_ready[i]),
        .pop_valid (inter_valid[i]),
        .pop_data  (inter_data[i])
    );
  end

  br_flow_join #(
      .NumFlows(NumFlows)
  ) br_flow_join (
      .clk,
      .rst,
      .push_ready(inter_ready),
      .push_valid(inter_valid),
      .pop_ready (pop_ready),
      .pop_valid (pop_valid)
  );

  assign pop_data = inter_data;  // direct concat

endmodule : datapath_join
----
====

Your `BUILD.bazel` file could then do this:

.`BUILD.bazel`
[%collapsible]
====
[source,bzl]
----
load("@bedrock-rtl//bazel:verilog.bzl", "verilog_elab_and_lint_test_suite", "verilog_elab_test", "verilog_lint_test")
load("@rules_hdl//verilog:providers.bzl", "verilog_library")

package(default_visibility = ["//visibility:private"])

verilog_library(
    name = "datapath_join",
    srcs = ["datapath_join.sv"],
    deps = [
        "@bedrock-rtl//flow/rtl:br_flow_join",
        "@bedrock-rtl//flow/rtl:br_flow_reg_fwd",
        "@bedrock-rtl//macros:br_asserts",
    ],
)

verilog_elab_test(
    name = "datapath_join_elab_test",
    deps = [":datapath_join"],
)

verilog_lint_test(
    name = "datapath_join_lint_test",
    deps = [":datapath_join"],
)

verilog_elab_and_lint_test_suite(
    name = "datapath_join_test_suite",
    params = {
        "NumFlows": [
            "2",
            "3",
        ],
        "BitWidthPerFlow": [
            "1",
            "64",
        ],
    },
    deps = [":datapath_join"],
)
----
====

== Planned Features

The following table summarizes the list of features that we plan to implement in the Bedrock-RTL library.
Checked boxes already have prototype implementations, though they are not verified yet.

[cols="1,2"]
|===
| Category | Description

| arb
a| Basic arbiters

 * [x] Fixed priority
 * [x] LRU
 * [x] Round-robin
 * [ ] Weighted LRU
 * [ ] Weighted round-robin

| cdc
a| Clock-domain crossings

* [ ] Single-bit sync
* [ ] Bus sync using CDC FIFOs

| counter
a| Counters with the following feature combinations:

* [x] Incrementing/decrementing
* [x] Wrapping
* [ ] Saturating
* [ ] Re-initializable

| credit
a| Credit/valid flow control

* [x] Credit counter
* [ ] Ready/valid -> credit/valid producer conversion

| delay
a| Feedforward delay pipeline registers

* [x] Non-gated, reset
* [x] Non-gated, non-reset
* [x] Self-gated (valid), reset
* [x] Self-gated on next cycle (valid-next), reset
* [x] Self-gated on next cycle (valid-next), non-reset

| ecc
a| Error correcting codes

* [ ] Parity encoder/decoder
* [ ] SECDED encoder/decoder

| enc
a| Encoders

* [x] onehot2bin
* [x] bin2onehot
* [x] priority

| err
a| Errors

* [ ] Sticky error log register
* [ ] Source masking
* [ ] Interrupt masking

| fifo
a| FIFO (queue) controllers with external RAM ports. Combinations of:

* [x] Push ready/valid
* [ ] Push credit/valid
* [x] Pop ready/valid
* [ ] Pop credit/valid
* [x] 1R1W (single bank)
* [ ] 1RW (dual bank)

Additionally, FIFOs that are simple wrappers around controllers and flop-RAMs.

| flow
a| Ready/valid flow control (streaming)

* [x] Arbs
* [x] Muxes
* [x] Regs
* [x] Fork
* [x] Join
* [x] Demuxes

| macros
a| Macros for inferring flip-flop registers with combinations of the following features.

* [x] Posedge clock
* [x] Active-high sync/async reset
* [x] Initial value
* [x] Load enable

Macros for SystemVerilog assertions.

* [x] Static
* [x] Concurrent
* [x] Immediate
* [x] Bedrock library-internal

| ram
a| Memories

* [x] Parameterizable Flop RAM
* [ ] CAM
* [ ] Addressing helpers
* [ ] Hazard detection

| rdc
a| Reset domain crossings

* [ ] Reset controls
* [ ] Reset handshakes

| timer
a| Timers

* [ ] Watchdog
* [ ] Rollover

|===
