// Copyright 2024 The Bedrock-RTL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// Copyright 2024 The Bedrock-RTL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Bedrock-RTL Single-Error-Correcting, Double-Error-Detecting (SECDED - Hsiao) Decoder
//
// Decodes a codeword using a single-error-correcting, double-error-detecting
// linear block code in systematic form (in layperson's terms: a Hsiao SECDED [1] decoder,
// closely related to Hamming codes).
//
// Systematic form means that the codeword is formed by appending the
// calculated parity bits to the message, i.e., the code has the property
// that the message bits are 1:1 with a slice of bits in the codeword (if they
// have not been corrupted).
//
// In Bedrock ECC libs, our convention is to always append the parity bits on
// the MSbs:
//     codeword == {parity, message}
//
// This is a purely combinational module. Valid bits are provided for
// convenience of user integration and port compatibility with the
// corresponding encoder module (br_ecc_secded_encoder).
//
// The data is still marked valid even if an error is detected.
//
// Any data width >= 1 is supported. It is considered internally zero-padded up to
// the nearest power-of-2 message width as part of decoding. The following
// table outlines the number of parity bits required for different message widths.
//
// | Message Width (k) | Parity Width (r) | Codeword Width (n)|
// |-------------------|------------------|-------------------|
// | 4                 | 4                | 8                 |
// | 8                 | 5                | 13                |
// | 16                | 6                | 22                |
// | 32                | 7                | 39                |
// | 64                | 8                | 72                |
// | 128               | 9                | 137               |
// | 256               | 10               | 266               |
// | 512               | 11               | 523               |
// | 1024              | 12               | 1036              |
//
// The number of parity bits must be one of the values in the table above
// or the module will not elaborate.
//
// References:
// [1] https://ieeexplore.ieee.org/abstract/document/5391627

`include "br_asserts_internal.svh"

// TODO(mgottscho): Pipeline the syndrome decoding and then correction with a parameter.
module br_ecc_secded_decoder #(
    parameter int DataWidth = 1,  // Must be at least 1
    parameter int ParityWidth = 4,  // Must be at least 4 and at most 12
    localparam int MessageWidth = 2 ** $clog2(DataWidth),
    localparam int CodewordWidth = MessageWidth + ParityWidth
) (
    input  logic                     codeword_valid,
    input  logic [CodewordWidth-1:0] codeword,
    output logic                     data_valid,
    output logic [    DataWidth-1:0] data,
    output logic                     error_valid,
    output logic                     error_corrected,
    output logic                     error_detected_but_uncorrectable,
    output logic [  ParityWidth-1:0] error_syndrome
);

  //------------------------------------------
  // Integration checks
  //------------------------------------------
  `BR_ASSERT_STATIC(message_width_gte_1_a, DataWidth >= 1)
  `BR_ASSERT_STATIC(parity_width_gte_4_a, ParityWidth >= 4)
  `BR_ASSERT_STATIC(parity_width_lte_12_a, ParityWidth <= 12)
  `BR_ASSERT_STATIC(message_width_is_power_of_2_a, br_math::is_power_of_2(MessageWidth))

  //------------------------------------------
  // Implementation
  //------------------------------------------
  logic [CodewordWidth-1:0][ParityWidth-1:0] H;  // parity-check-matrix

  // verilog_format: off
  // verilog_lint: waive-start line-length
  if (CodewordWidth == 4 && MessageWidth == 4) begin : gen_8_4
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 4)
{{ secded_dec_syndrome_8_4 }}
{{ secded_dec_H_8_4 }}
  end else if (CodewordWidth == 13 && MessageWidth == 8) begin : gen_13_8
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 5)
{{ secded_dec_syndrome_13_8 }}
{{ secded_dec_H_13_8 }}
  end else if (CodewordWidth == 22 && MessageWidth == 16) begin : gen_22_16
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 6)
{{ secded_dec_syndrome_22_16 }}
{{ secded_dec_H_22_16 }}
  end else if (CodewordWidth == 39 && MessageWidth == 32) begin : gen_39_32
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 7)
{{ secded_dec_syndrome_39_32 }}
{{ secded_dec_H_39_32 }}
  end else if (CodewordWidth == 72 && MessageWidth == 64) begin : gen_72_64
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 8)
{{ secded_dec_syndrome_72_64 }}
{{ secded_dec_H_72_64 }}
  end else if (CodewordWidth == 137 && MessageWidth == 128) begin : gen_137_128
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 9)
{{ secded_dec_syndrome_137_128 }}
{{ secded_dec_H_137_128 }}
  end else if (CodewordWidth == 266 && MessageWidth == 256) begin : gen_266_256
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 10)
{{ secded_dec_syndrome_266_256 }}
{{ secded_dec_H_266_256 }}
  end else if (CodewordWidth == 523 && MessageWidth == 512) begin : gen_523_512
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 11)
{{ secded_dec_syndrome_523_512 }}
{{ secded_dec_H_523_512 }}
  end else if (CodewordWidth == 1036 && MessageWidth == 1024) begin : gen_1036_1024
    `BR_ASSERT_STATIC(parity_width_matches_a, ParityWidth == 12)
{{ secded_dec_syndrome_1036_1024 }}
{{ secded_dec_H_1036_1024 }}
  end else begin : gen_default_parity
    `BR_ASSERT_STATIC(invalid_parity_width_a, 1'b0)
  end
  // verilog_lint: waive-stop line-length
  // verilog_format: on


  // Decode syndrome.
  // * Case 0: Syndrome is zero, no errors detected.
  // * Case 1: Syndrome is for an even number of bits in error, which happens when the syndrome is even in a Hsiao SECDED code.
  //   Maximum likelihood decoding produces multiple equiprobable candidate codewords, so treat as detected-but-uncorrectable.
  //   NOTE: We are returning *some* message but it is likely to have been corrupted!
  // * Remaining case: Syndrome is for an odd number of bits in error, which happens when the syndrome is odd in a Hsiao SECDED code.
  //   *Usually* this is a single-bit error, which is always closest to exactly one codeword. So with maximum likelihood decoding
  //   we can correct it. However, sometimes it can be a three-bit error that is actually detected-but-uncorrectable.

  logic [ParityWidth-1:0] syndrome_ones_count;
  logic syndrome_is_zero;
  logic syndrome_is_even;
  logic syndrome_is_odd;
  logic [CodewordWidth-1:0] column_match_onehot;

  br_enc_countones #(
      .Width(ParityWidth)
  ) br_enc_countones_syndrome (
      .in(error_syndrome),
      .count(syndrome_ones_count)
  );

  assign syndrome_is_zero = error_syndrome == '0;
  assign syndrome_is_even = !syndrome_is_zero && !syndrome_ones_count[0];
  assign syndrome_is_odd = syndrome_ones_count[1];

  // TODO(mgottscho): Implement this. Need code generation. (WIP)
  assign column_match_onehot = '0;

  assign error_detected_but_uncorrectable = codeword_valid &&
    (syndrome_is_even || (syndrome_is_odd && column_match_onehot == 0));
  assign error_corrected = codeword_valid && syndrome_is_odd && (column_match_onehot != 0);

  // Actually correct the error.
  logic PadWidth = MessageWidth - DataWidth;
  logic [CodewordWidth-1:0] corrected_codeword;
  logic [MessageWidth-1:0] message;

  assign corrected_codeword = codeword ^ column_match_onehot;

  assign message = corrected_codeword[MessageWidth-1:0];
  assign data_valid = codeword_valid;
  assign data = message[DataWidth-1:0];

  //------------------------------------------
  // Implementation checks
  //------------------------------------------
  `BR_ASSERT_COMB_IMPL(data_valid_only_if_codeword_valid_a, !data_valid || codeword_valid)
  `BR_ASSERT_COMB_IMPL(error_valid_only_if_data_valid_a, !error_valid || data_valid)
  `BR_ASSERT_COMB_IMPL(ce_due_mutually_exclusive_a,
                       !error_valid || !(error_corrected && error_detected_but_uncorrectable))
  `BR_COVER_COMB_IMPL(error_valid_c, error_valid)
  `BR_COVER_COMB_IMPL(ce_c, error_valid && error_corrected)
  `BR_COVER_COMB_IMPL(due_c, error_valid && error_detected_but_uncorrectable)

endmodule : br_ecc_secded_decoder
