// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;
use std::fs::File;
use std::io::{BufReader, Write};
use std::path::PathBuf;
use std::str::FromStr;

use clap::Args;
use num_bigint::BigInt;
use serde::{Deserialize, Serialize};
use topstitch::ModDef;

use crate::common;

#[derive(Args)]
pub struct InstantiateArgs {
    /// The name of the module to instantiate
    #[arg(short, long)]
    module_name: String,

    /// The name of the wrapper module to create
    #[arg(short, long)]
    wrapper_name: String,

    /// JSON file containing list of parameters to use for each instantiation
    #[arg(short, long)]
    param_file: String,

    /// The output file to write the instantiated module to
    #[arg(short, long)]
    output_file: String,

    /// Disable these lint rules in the generated file
    #[arg(short, long)]
    disable_lint_rules: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Parameters {
    param_sets: Vec<HashMap<String, String>>
}

fn create_instantiation_wrapper(
    wrapper_name: &str,
    module: &ModDef,
    params: &Parameters
) -> Result<ModDef, &'static str> {
    let wrapper = ModDef::new(wrapper_name);

    for (i, param_set) in params.param_sets.iter().enumerate() {
        let inst = {
            let parameters: Vec<(&str, BigInt)> = param_set.iter().map(
                |(k, v)| (k.as_str(), BigInt::from_str(v.as_str()).unwrap())
            ).collect();
            let module = if parameters.is_empty() {
                module
            } else {
                let mut def_name = module.get_name().clone();
                for (param_name, param_value) in &parameters {
                    def_name.push_str(&format!("_{}_{}", param_name, param_value));
                }
                &module.parameterize(&parameters).wrap(Some(&def_name), None)
            };
            wrapper.instantiate(module, None, None)
        };

        for port in inst.get_ports(None) {
            let inst_name = inst.name();
            let port_name = port.name();
            port.export_as(format!("{inst_name}__{port_name}"));
        }
    }

    Ok(wrapper)
}

const SV_HEADER_COMMENT: &str =
    "// This file is automatically generated by Stitch. DO NOT EDIT.";

const COMMON_DISABLED_LINT_RULES: [&str; 12] = [
    "ONE_PER_FILE",
    "FILE_NAME",
    "MOD_NAME",
    "PORT_NAME",
    "SIG_NAME",
    "INST_NAME",
    "CLOCK_NAME",
    "SAME_CLOCK_NAME",
    "CLOCK_LIMIT",
    "RESET_NAME",
    "SAME_RESET_NAME",
    "ENUM_RHS",
];

pub fn instantiate_main(
    args: &InstantiateArgs,
    common_args: &common::CommonArgs
) {
    eprintln!("Creating instantiation wrapper for module {}", args.module_name);

    let moddef = common::load_module(
        &args.module_name,
        &common_args.sv_files,
        &common_args.sv_headers
    );
    let param_file = File::open(&args.param_file)
        .expect("Failed to open parameter file");
    let param_reader = BufReader::new(param_file);
    let params: Parameters = serde_json::from_reader(param_reader)
        .expect("Failed to parse parameter file");

    let inst_mod = create_instantiation_wrapper(&args.wrapper_name, &moddef, &params)
        .expect("Failed to create instantiation wrapper");

    let out_path = PathBuf::from(&args.output_file);
    let mut out_file = File::create(&out_path).expect("Failed to create output file");

    write!(out_file, "{SV_HEADER_COMMENT}\n")
        .expect("Failed to write header comment");

    for rule in COMMON_DISABLED_LINT_RULES.iter() {
        write!(out_file, "// ri lint_check_off {rule}\n")
            .expect("Failed to write lint off comment");
    }

    for rule in args.disable_lint_rules.iter() {
        write!(out_file, "// ri lint_check_off {rule}\n")
            .expect("Failed to write lint off comment");
    }

    let sv_body = inst_mod.emit(true);
    write!(out_file, "{sv_body}").expect("Failed to write module body");

    for rule in args.disable_lint_rules.iter().rev() {
        write!(out_file, "// ri lint_check_on {rule}\n")
            .expect("Failed to write lint on comment");
    }

    for rule in COMMON_DISABLED_LINT_RULES.iter().rev() {
        write!(out_file, "// ri lint_check_on {rule}\n")
            .expect("Failed to write lint on comment");
    }

    eprintln!("Instantiated module written to {}", args.output_file);
}
