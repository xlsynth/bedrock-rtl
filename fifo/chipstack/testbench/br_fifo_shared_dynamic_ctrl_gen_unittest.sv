
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_fifo_shared_dynamic_ctrl
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-17 19:39:07
// Description: Unit test for br_fifo_shared_dynamic_ctrl
//=============================================================



module br_fifo_shared_dynamic_ctrl_gen_tb;
  timeunit 1ns;
  timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;     // Clock frequency in MHz
  parameter int RESET_DURATION = 100;    // Reset duration in ns
  parameter int TIMEOUT = 10000000;          // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000; // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;        // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000; // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks
  
  //===========================================================
  // DUT Imports and Includes
  //===========================================================
  
  `include "br_asserts_internal.svh"
    
  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int NumWritePorts = 2;
  parameter int NumReadPorts = 2;
  parameter int NumFifos = 2;
  parameter int Depth = 6;
  parameter int Width = 1;
  parameter int StagingBufferDepth = 1;
  parameter bit RegisterPopOutputs = 0;
  parameter bit RegisterDeallocation = 0;
  parameter int DataRamReadLatency = 0;
  parameter int PointerRamReadLatency = 0;
  parameter bit EnableCoverPushBackpressure = 1;
  parameter bit EnableAssertPushValidStability = EnableCoverPushBackpressure;
  parameter bit EnableAssertPushDataStability = EnableAssertPushValidStability;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int FifoIdWidth = br_math::clamped_clog2(NumFifos);
  localparam int AddrWidth = br_math::clamped_clog2(Depth);

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic clk;
  logic rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic[NumWritePorts-1:0] push_valid;
  logic[NumWritePorts-1:0][Width-1:0] push_data;
  logic[NumWritePorts-1:0][FifoIdWidth-1:0] push_fifo_id;
  logic[NumFifos-1:0] pop_ready;
  logic[NumReadPorts-1:0] data_ram_rd_data_valid;
  logic[NumReadPorts-1:0][Width-1:0] data_ram_rd_data;
  logic[NumReadPorts-1:0] ptr_ram_rd_data_valid;
  logic[NumReadPorts-1:0][AddrWidth-1:0] ptr_ram_rd_data;
  logic[NumWritePorts-1:0] push_ready;
  logic[NumFifos-1:0] pop_valid;
  logic[NumFifos-1:0][Width-1:0] pop_data;
  logic[NumWritePorts-1:0] data_ram_wr_valid;
  logic[NumWritePorts-1:0][AddrWidth-1:0] data_ram_wr_addr;
  logic[NumWritePorts-1:0][Width-1:0] data_ram_wr_data;
  logic[NumReadPorts-1:0] data_ram_rd_addr_valid;
  logic[NumReadPorts-1:0][AddrWidth-1:0] data_ram_rd_addr;
  logic[NumWritePorts-1:0] ptr_ram_wr_valid;
  logic[NumWritePorts-1:0][AddrWidth-1:0] ptr_ram_wr_addr;
  logic[NumWritePorts-1:0][AddrWidth-1:0] ptr_ram_wr_data;
  logic[NumReadPorts-1:0] ptr_ram_rd_addr_valid;
  logic[NumReadPorts-1:0][AddrWidth-1:0] ptr_ram_rd_addr;

  //===========================================================
  // DUT Instantiation
  //===========================================================
// Clock to DUT is inverted to avoid race condition between DUT and TB
  br_fifo_shared_dynamic_ctrl 
      #(
          .NumWritePorts(NumWritePorts),
          .NumReadPorts(NumReadPorts),
          .NumFifos(NumFifos),
          .Depth(Depth),
          .Width(Width),
          .StagingBufferDepth(StagingBufferDepth),
          .RegisterPopOutputs(RegisterPopOutputs),
          .RegisterDeallocation(RegisterDeallocation),
          .DataRamReadLatency(DataRamReadLatency),
          .PointerRamReadLatency(PointerRamReadLatency),
          .EnableCoverPushBackpressure(EnableCoverPushBackpressure),
          .EnableAssertPushValidStability(EnableAssertPushValidStability),
          .EnableAssertPushDataStability(EnableAssertPushDataStability),
          .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
      )  dut (
          .clk(~clk),
          .rst(rst),
          .push_valid(push_valid),
          .push_data(push_data),
          .push_fifo_id(push_fifo_id),
          .pop_ready(pop_ready),
          .data_ram_rd_data_valid(data_ram_rd_data_valid),
          .data_ram_rd_data(data_ram_rd_data),
          .ptr_ram_rd_data_valid(ptr_ram_rd_data_valid),
          .ptr_ram_rd_data(ptr_ram_rd_data),
          .push_ready(push_ready),
          .pop_valid(pop_valid),
          .pop_data(pop_data),
          .data_ram_wr_valid(data_ram_wr_valid),
          .data_ram_wr_addr(data_ram_wr_addr),
          .data_ram_wr_data(data_ram_wr_data),
          .data_ram_rd_addr_valid(data_ram_rd_addr_valid),
          .data_ram_rd_addr(data_ram_rd_addr),
          .ptr_ram_wr_valid(ptr_ram_wr_valid),
          .ptr_ram_wr_addr(ptr_ram_wr_addr),
          .ptr_ram_wr_data(ptr_ram_wr_data),
          .ptr_ram_rd_addr_valid(ptr_ram_rd_addr_valid),
          .ptr_ram_rd_addr(ptr_ram_rd_addr)
      );
      

  //===========================================================
  // Clock Generation
  //===========================================================
  initial begin
    clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR/(2*CLOCK_FREQ)) clk = ~clk;
  end
  

  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_valid <= 'h0;
    push_data <= 'h0;
    push_fifo_id <= 'h0;
    pop_ready <= 'h0;
    data_ram_rd_data_valid <= 'h0;
    data_ram_rd_data <= 'h0;
    ptr_ram_rd_data_valid <= 'h0;
    ptr_ram_rd_data <= 'h0;
  
    // Wiggling the reset signal.
    rst = 1'bx;
    #RESET_DURATION;
    rst = 1'b1;
    #RESET_DURATION;
    rst = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushAndPopIdx,
    test_PushBackpressureHandlingIdx,
    test_ConcurrentPushAndPopIdx,
    test_DynamicFifoAllocationIdx,
    test_PointerRamReadWriteIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};
  
  `ifdef WAVES_AS_FSDB
     bit enable_fsdb;
  `endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
      if (NO_ASSERTS_ON_RESET) $assertoff;
      #(TIMEOUT);
      $display("Error: Testbench timeout!");
      $finish;
  end

  `ifdef WAVES_AS_FSDB
    initial begin
      // Enable FSDB dump for TB and DUT
      if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
        $fsdbDumpfile("tb.fsdb");
        $fsdbDumpvars(0, br_fifo_shared_dynamic_ctrl_gen_tb, "+all");
      end
    end
  `endif
    
        
  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushAndPop();
  
    reset_dut();
    test_PushBackpressureHandling();
  
    reset_dut();
    test_ConcurrentPushAndPop();
  
    reset_dut();
    test_DynamicFifoAllocation();
  
    reset_dut();
    test_PointerRamReadWrite();
  
    if (err_count_arr[test_BasicPushAndPopIdx] == 0) begin
      $display("Test test_BasicPushAndPop PASSED");
    end else if (err_count_arr[test_BasicPushAndPopIdx] == -1) begin
      $display("Test test_BasicPushAndPop TIMEOUT");
    end else begin
      $display("Test test_BasicPushAndPop FAILED");
    end
  
    if (err_count_arr[test_PushBackpressureHandlingIdx] == 0) begin
      $display($sformatf({"Test test_PushBackpressureHandling ","PASSED"}));
    end else if (err_count_arr[test_PushBackpressureHandlingIdx] == -1) begin
      $display($sformatf({"Test test_PushBackpressureHandling ","TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_PushBackpressureHandling ","FAILED"}));
    end
  
    if (err_count_arr[test_ConcurrentPushAndPopIdx] == 0) begin
      $display("Test test_ConcurrentPushAndPop PASSED");
    end else if (err_count_arr[test_ConcurrentPushAndPopIdx] == -1) begin
      $display("Test test_ConcurrentPushAndPop TIMEOUT");
    end else begin
      $display("Test test_ConcurrentPushAndPop FAILED");
    end
  
    if (err_count_arr[test_DynamicFifoAllocationIdx] == 0) begin
      $display("Test test_DynamicFifoAllocation PASSED");
    end else if (err_count_arr[test_DynamicFifoAllocationIdx] == -1) begin
      $display($sformatf({"Test test_DynamicFifoAllocation TIMEOUT"}));
    end else begin
      $display("Test test_DynamicFifoAllocation FAILED");
    end
  
    if (err_count_arr[test_PointerRamReadWriteIdx] == 0) begin
      $display("Test test_PointerRamReadWrite PASSED");
    end else if (err_count_arr[test_PointerRamReadWriteIdx] == -1) begin
      $display("Test test_PointerRamReadWrite TIMEOUT");
    end else begin
      $display("Test test_PointerRamReadWrite FAILED");
    end
  
  
    if ( err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end

  
  task automatic test_BasicPushAndPop;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: test_BasicPushAndPop"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_BasicPushAndPop. Stimuli is not ","observed or it needs more time to finish"," this test."}, $time));
        err_count_arr[test_BasicPushAndPopIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task tests the basic push and pop operations of the FIFO, ensuring data integrity and proper operation.
        
        // Local variables declaration
        int test_failed = 0;
        int expected_data;
        int fifo_id;
        int push_data_value;
        
        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);
        
        // Step 1: Release reset and start normal operation
        rst = 1'b0;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","Released reset, starting normal ","operation."}, $time));
        
        // Step 2: Drive push_valid high for the first write port, provide valid push_data and push_fifo_id
        push_valid[0] = 1'b1;
        push_data_value = $urandom_range(0, (1 << Width) - 1);
        push_data[0] = push_data_value;
        fifo_id = $urandom_range(0, NumFifos - 1);
        push_fifo_id[0] = fifo_id;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","Driving push_valid=1, push_data=0x%h, ","push_fifo_id=%0d"}, $time, push_data_value, fifo_id));
        
        // Step 3: Monitor push_ready and wait for it to be high
        while (push_ready[0] != 1'b1) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","push_ready is high, FIFO is ready to ","accept data."}, $time));
        
        // Step 4: Drive pop_ready high for the corresponding FIFO ID
        pop_ready[fifo_id] = 1'b1;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","Driving pop_ready=1 for FIFO ID %0d"}, $time, fifo_id));
        
        // Step 5: Monitor pop_valid and wait for it to be high
        while (pop_valid[fifo_id] != 1'b1) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","pop_valid is high, valid data is ","available."}, $time));
        
        // Step 6: Monitor pop_data and verify it matches the expected data
        expected_data = push_data_value;
        if (pop_data[fifo_id] !== expected_data) begin
          $display($sformatf({"Time: %0t, ERROR: test_BasicPushAndPop -"," Check failed. Expected pop_data=0x%h, ","got 0x%h"}, $time, expected_data, pop_data[fifo_id]));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","Check passed. Expected pop_data=0x%h ","matches observed value."}, $time, expected_data));
        end
        
        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: test_BasicPushAndPop"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: test_BasicPushAndPop"}, $time));
          err_count_arr[test_BasicPushAndPopIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  
  
  task automatic test_PushBackpressureHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_PushBackpressureHandling"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_PushBackpressureHandling. Stimuli ","is not observed or it needs more time to"," finish this test."}, $time));
        err_count_arr[test_PushBackpressureHandlingIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task tests the FIFO's ability to handle backpressure conditions and maintain data integrity when full.
        
        // Local variables declaration
        int test_failed = 0;
        int random_data;
        int random_fifo_id;
        int stable_push_valid;
        int stable_push_data;
        int stable_push_fifo_id;
        int push_ready_low_detected = 0;
        int push_ready_high_detected = 0;
        
        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);
        
        // Step 1: Assert reset
        rst = 1'b1;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - Reset ","asserted."}, $time));
        
        // Step 2: Deassert reset
        rst = 1'b0;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - Reset ","deasserted."}, $time));
        
        // Step 3: Continuously assert push_valid high for all write ports with random data
        for (int i = 0; i < NumWritePorts; i++) begin
          random_data = $urandom();
          random_fifo_id = $urandom_range(0, NumFifos-1);
          push_valid[i] = 1'b1;
          push_data[i] = random_data;
          push_fifo_id[i] = random_fifo_id;
        end
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - Driving ","push_valid high with random data and ","FIFO IDs."}, $time));
        
        // Step 4: Monitor push_ready for backpressure
        while (!push_ready_low_detected) begin
          @(posedge clk);
          for (int i = 0; i < NumWritePorts; i++) begin
            if (push_ready[i] == 1'b0) begin
              push_ready_low_detected = 1;
              stable_push_valid = push_valid[i];
              stable_push_data = push_data[i];
              stable_push_fifo_id = push_fifo_id[i];
              if (ENABLE_INFO_MESSAGES == 1)
                $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - Detected"," push_ready low, indicating ","backpressure."}, $time));
            end
          end
        end
        
        // Step 5: Ensure push_valid remains stable
        for (int i = 0; i < NumWritePorts; i++) begin
          if (push_ready[i] == 1'b0) begin
            if (push_valid[i] !== stable_push_valid || push_data[i] !== stable_push_data || push_fifo_id[i] !== stable_push_fifo_id) begin
              $display($sformatf({"Time: %0t, ERROR: ","test_PushBackpressureHandling - ","push_valid, push_data, or push_fifo_id ","changed under backpressure."}, $time));
              test_failed = 1;
            end else if (ENABLE_INFO_MESSAGES == 1) begin
              $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - ","push_valid, push_data, and push_fifo_id ","remained stable under backpressure."}, $time));
            end
          end
        end
        
        // Step 6: Assert pop_ready high for one FIFO to create space
        pop_ready[0] = 1'b1;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - ","pop_ready asserted high for FIFO 0."}, $time));
        
        // Step 7: Monitor push_ready to detect when FIFO can accept new data
        while (!push_ready_high_detected) begin
          @(posedge clk);
          for (int i = 0; i < NumWritePorts; i++) begin
            if (push_ready[i] == 1'b1) begin
              push_ready_high_detected = 1;
              if (ENABLE_INFO_MESSAGES == 1)
                $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - Detected"," push_ready high, FIFO can accept new ","data."}, $time));
            end
          end
        end
        
        // Final check for test pass/fail status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_PushBackpressureHandling"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_PushBackpressureHandling"}, $time));
          err_count_arr[test_PushBackpressureHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  
  
  task automatic test_ConcurrentPushAndPop;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_ConcurrentPushAndPop"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_ConcurrentPushAndPop. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_ConcurrentPushAndPopIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // Task to test concurrent push and pop operations across multiple ports, ensuring data integrity and correct functionality.
        
        // Local variables declaration
        int test_failed = 0;
        int expected_data[NumFifos];
        int observed_data[NumFifos];
        int push_data_values[NumWritePorts];
        int push_fifo_ids[NumWritePorts];
        int pop_ready_values[NumFifos];
        int pop_valid_values[NumFifos];
        int pop_data_values[NumFifos];
        
        // Initialize expected data for FIFOs
        for (int i = 0; i < NumFifos; i++) begin
          expected_data[i] = $urandom_range(0, (1 << Width) - 1);
        end
        
        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);
        
        // Deassert reset to start normal operation
        rst = 1'b0;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - Reset ","deasserted, starting normal operation."}, $time));
        
        // Drive push_valid, push_data, and push_fifo_id for multiple write ports
        for (int i = 0; i < NumWritePorts; i++) begin
          push_data_values[i] = $urandom_range(0, (1 << Width) - 1);
          push_fifo_ids[i] = $urandom_range(0, NumFifos - 1);
          push_valid[i] = 1'b1;
          push_data[i] = push_data_values[i];
          push_fifo_id[i] = push_fifo_ids[i];
        end
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - Driving ","push_valid, push_data, and push_fifo_id."}, $time));
        
        // Wait for push_ready to be asserted for each port
        for (int i = 0; i < NumWritePorts; i++) begin
          while (!push_ready[i]) @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - push_ready ","asserted for all write ports."}, $time));
        
        // Drive pop_ready for multiple FIFOs
        for (int i = 0; i < NumFifos; i++) begin
          pop_ready[i] = 1'b1;
        end
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - Driving ","pop_ready for multiple FIFOs."}, $time));
        
        // Wait for pop_valid to be asserted for each FIFO
        for (int i = 0; i < NumFifos; i++) begin
          while (!pop_valid[i]) @(posedge clk);
          pop_valid_values[i] = pop_valid[i];
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - pop_valid ","asserted for all FIFOs."}, $time));
        
        // Capture pop_data and verify against expected values
        for (int i = 0; i < NumFifos; i++) begin
          observed_data[i] = pop_data[i];
          if (observed_data[i] !== expected_data[i]) begin
            $display($sformatf({"Time: %0t, ERROR: ","test_ConcurrentPushAndPop - Data ","mismatch for FIFO %0d. Expected: 0x%h, ","Got: 0x%h"}, $time, i, expected_data[i], observed_data[i]));
            test_failed = 1;
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - Data match ","for FIFO %0d. Expected and Got: 0x%h"}, $time, i, observed_data[i]));
          end
        end
        
        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_ConcurrentPushAndPop"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_ConcurrentPushAndPop"}, $time));
          err_count_arr[test_ConcurrentPushAndPopIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  
  
  task automatic test_DynamicFifoAllocation;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_DynamicFifoAllocation"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_DynamicFifoAllocation. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_DynamicFifoAllocationIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the dynamic allocation capability of the FIFO, ensuring data can be pushed to and popped from different logical FIFOs without fixed allocation.
        
        // Local variables declaration
        int test_failed = 0;
        int push_data_value;
        int expected_pop_data;
        int fifo_id;
        int write_port;
        int read_fifo;
        
        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);
        
        // Step 1: Release reset and wait for 20 ns
        rst = 1'b0;
        #(20);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - Reset ","released."}, $time));
        
        // Step 2: Drive push_valid high for a specific write port, provide valid push_data, and specify a push_fifo_id
        write_port = 0;
        push_data_value = $urandom_range(0, 2**Width-1);
        fifo_id = 0;
        push_valid[write_port] = 1'b1;
        push_data[write_port] = push_data_value;
        push_fifo_id[write_port] = fifo_id;
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - Driving ","push_valid[%0d]=1, push_data[%0d]=0x%h, ","push_fifo_id[%0d]=%0d"}, $time, write_port, write_port, push_data_value, write_port, fifo_id));
        
        // Step 3: Monitor push_ready and wait for it to be high
        @(posedge clk);
        while (push_ready[write_port] != 1'b1) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - ","push_ready[%0d] is high, ready to accept"," data."}, $time, write_port));
        
        // Step 4: Change push_fifo_id to a different FIFO and repeat the push operation
        fifo_id = 1;
        push_data_value = $urandom_range(0, 2**Width-1);
        push_fifo_id[write_port] = fifo_id;
        push_data[write_port] = push_data_value;
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - Changing ","push_fifo_id[%0d]=%0d, ","push_data[%0d]=0x%h"}, $time, write_port, fifo_id, write_port, push_data_value));
        
        // Step 5: Monitor push_ready for the new FIFO
        @(posedge clk);
        while (push_ready[write_port] != 1'b1) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - ","push_ready[%0d] is high for new FIFO."}, $time, write_port));
        
        // Step 6: Drive pop_ready high for the first FIFO and monitor pop_valid
        read_fifo = 0;
        pop_ready[read_fifo] = 1'b1;
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - Driving ","pop_ready[%0d]=1"}, $time, read_fifo));
        
        @(posedge clk);
        while (pop_valid[read_fifo] != 1'b1) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - ","pop_valid[%0d] is high, valid data ","available."}, $time, read_fifo));
        
        // Step 7: Monitor pop_data and verify data integrity
        expected_pop_data = push_data_value;
        if (pop_data[read_fifo] !== expected_pop_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_DynamicFifoAllocation - Data ","mismatch. Expected 0x%h, got 0x%h"}, $time, expected_pop_data, pop_data[read_fifo]));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - Data ","integrity verified for FIFO %0d. ","Expected and got 0x%h"}, $time, read_fifo, expected_pop_data));
        end
        
        // Step 8: Repeat the pop operation for the second FIFO
        read_fifo = 1;
        pop_ready[read_fifo] = 1'b1;
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - Driving ","pop_ready[%0d]=1"}, $time, read_fifo));
        
        @(posedge clk);
        while (pop_valid[read_fifo] != 1'b1) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - ","pop_valid[%0d] is high, valid data ","available."}, $time, read_fifo));
        
        // Verify data integrity for the second FIFO
        expected_pop_data = push_data_value;
        if (pop_data[read_fifo] !== expected_pop_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_DynamicFifoAllocation - Data ","mismatch for FIFO %0d. Expected 0x%h, ","got 0x%h"}, $time, read_fifo, expected_pop_data, pop_data[read_fifo]));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_DynamicFifoAllocation - Data ","integrity verified for FIFO %0d. ","Expected and got 0x%h"}, $time, read_fifo, expected_pop_data));
        end
        
        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_DynamicFifoAllocation"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_DynamicFifoAllocation"}, $time));
          err_count_arr[test_DynamicFifoAllocationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  
  
  task automatic test_PointerRamReadWrite;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_PointerRamReadWrite"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_PointerRamReadWrite. Stimuli is not"," observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_PointerRamReadWriteIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the correct operation of pointer RAM read and write processes, ensuring accurate management of FIFO pointers.
        
        // Local variables declaration
        int test_failed = 0;
        int wport;
        int expected_ptr_ram_wr_addr;
        int expected_ptr_ram_wr_data;
        int expected_ptr_ram_rd_data;
        logic [NumWritePorts-1:0] local_push_valid;
        logic [NumWritePorts-1:0][Width-1:0] local_push_data;
        logic [NumWritePorts-1:0][FifoIdWidth-1:0] local_push_fifo_id;
        logic [NumFifos-1:0] local_pop_ready;
        
        // Wait for reset to complete
        @(negedge rst);
        @(posedge clk);
        
        // Randomly select a write port
        wport = $urandom_range(0, NumWritePorts-1);
        
        // Generate random data and FIFO ID for push operation
        local_push_valid = '0;
        local_push_data = '0;
        local_push_fifo_id = '0;
        local_pop_ready = '0;
        
        local_push_valid[wport] = 1'b1;
        local_push_data[wport] = $urandom();
        local_push_fifo_id[wport] = $urandom_range(0, NumFifos-1);
        
        // Drive push signals
        @(posedge clk);
        push_valid <= local_push_valid;
        push_data <= local_push_data;
        push_fifo_id <= local_push_fifo_id;
        
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PointerRamReadWrite - Driving ","push_valid=0x%h, push_data=0x%h, ","push_fifo_id=0x%h"}, $time, local_push_valid, local_push_data, local_push_fifo_id));
        
        // Wait for ptr_ram_wr_valid to be asserted
        wait (ptr_ram_wr_valid[wport] == 1'b1);
        expected_ptr_ram_wr_addr = ptr_ram_wr_addr[wport];
        expected_ptr_ram_wr_data = ptr_ram_wr_data[wport];
        
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PointerRamReadWrite - Observed ","ptr_ram_wr_valid=1, ","ptr_ram_wr_addr=0x%h, ","ptr_ram_wr_data=0x%h"}, $time, expected_ptr_ram_wr_addr, expected_ptr_ram_wr_data));
        
        // Drive pop_ready for the corresponding FIFO
        @(posedge clk);
        local_pop_ready[local_push_fifo_id[wport]] = 1'b1;
        pop_ready <= local_pop_ready;
        
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PointerRamReadWrite - Driving ","pop_ready=0x%h"}, $time, local_pop_ready));
        
        // Wait for ptr_ram_rd_addr_valid to be asserted
        wait (ptr_ram_rd_addr_valid[0] == 1'b1);
        
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PointerRamReadWrite - Observed ","ptr_ram_rd_addr_valid=1"}, $time));
        
        // Wait for ptr_ram_rd_data_valid to be asserted
        wait (ptr_ram_rd_data_valid[0] == 1'b1);
        expected_ptr_ram_rd_data = ptr_ram_rd_data[0];
        
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PointerRamReadWrite - Observed ","ptr_ram_rd_data_valid=1, ","ptr_ram_rd_data=0x%h"}, $time, expected_ptr_ram_rd_data));
        
        // Verify the expected pointer data
        if (expected_ptr_ram_rd_data != expected_ptr_ram_wr_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_PointerRamReadWrite - Check failed."," Expected ptr_ram_rd_data=0x%h, got 0x%h"}, $time, expected_ptr_ram_wr_data, expected_ptr_ram_rd_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_PointerRamReadWrite - Check passed."," Expected value for ptr_ram_rd_data is ","the same as the observed value (both are"," 0x%h)."}, $time, expected_ptr_ram_rd_data));
        end
        
        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_PointerRamReadWrite"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_PointerRamReadWrite"}, $time));
          err_count_arr[test_PointerRamReadWriteIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  
endmodule
  