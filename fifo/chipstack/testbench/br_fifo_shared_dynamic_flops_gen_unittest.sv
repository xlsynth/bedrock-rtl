
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_fifo_shared_dynamic_flops
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-17 19:39:07
// Description: Unit test for br_fifo_shared_dynamic_flops
//=============================================================



module br_fifo_shared_dynamic_flops_gen_tb;
  timeunit 1ns;
  timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;     // Clock frequency in MHz
  parameter int RESET_DURATION = 100;    // Reset duration in ns
  parameter int TIMEOUT = 10000000;          // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000; // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;        // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000; // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks


  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int NumWritePorts = 2;
  parameter int NumReadPorts = 2;
  parameter int NumFifos = 2;
  parameter int Depth = 6;
  parameter int Width = 1;
  parameter int StagingBufferDepth = 1;
  parameter bit RegisterPopOutputs = 0;
  parameter bit RegisterDeallocation = 0;
  parameter int DataRamDepthTiles = 1;
  parameter int DataRamWidthTiles = 1;
  parameter int DataRamAddressDepthStages = 0;
  parameter int DataRamReadDataDepthStages = 0;
  parameter int DataRamReadDataWidthStages = 0;
  parameter int PointerRamDepthTiles = 1;
  parameter int PointerRamWidthTiles = 1;
  parameter int PointerRamAddressDepthStages = 0;
  parameter int PointerRamReadDataDepthStages = 0;
  parameter int PointerRamReadDataWidthStages = 0;
  parameter bit EnableCoverPushBackpressure = 1;
  parameter bit EnableAssertPushValidStability = EnableCoverPushBackpressure;
  parameter bit EnableAssertPushDataStability = EnableAssertPushValidStability;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int FifoIdWidth = br_math::clamped_clog2(NumFifos);
  localparam int AddrWidth = br_math::clamped_clog2(Depth);

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic clk;
  logic rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic[NumWritePorts-1:0] push_valid;
  logic[NumWritePorts-1:0][Width-1:0] push_data;
  logic[NumWritePorts-1:0][FifoIdWidth-1:0] push_fifo_id;
  logic[NumFifos-1:0] pop_ready;
  logic[NumWritePorts-1:0] push_ready;
  logic[NumFifos-1:0] pop_valid;
  logic[NumFifos-1:0][Width-1:0] pop_data;

  //===========================================================
  // DUT Instantiation
  //===========================================================
// Clock to DUT is inverted to avoid race condition between DUT and TB
  br_fifo_shared_dynamic_flops
      #(
          .NumWritePorts(NumWritePorts),
          .NumReadPorts(NumReadPorts),
          .NumFifos(NumFifos),
          .Depth(Depth),
          .Width(Width),
          .StagingBufferDepth(StagingBufferDepth),
          .RegisterPopOutputs(RegisterPopOutputs),
          .RegisterDeallocation(RegisterDeallocation),
          .DataRamDepthTiles(DataRamDepthTiles),
          .DataRamWidthTiles(DataRamWidthTiles),
          .DataRamAddressDepthStages(DataRamAddressDepthStages),
          .DataRamReadDataDepthStages(DataRamReadDataDepthStages),
          .DataRamReadDataWidthStages(DataRamReadDataWidthStages),
          .PointerRamDepthTiles(PointerRamDepthTiles),
          .PointerRamWidthTiles(PointerRamWidthTiles),
          .PointerRamAddressDepthStages(PointerRamAddressDepthStages),
          .PointerRamReadDataDepthStages(PointerRamReadDataDepthStages),
          .PointerRamReadDataWidthStages(PointerRamReadDataWidthStages),
          .EnableCoverPushBackpressure(EnableCoverPushBackpressure),
          .EnableAssertPushValidStability(EnableAssertPushValidStability),
          .EnableAssertPushDataStability(EnableAssertPushDataStability),
          .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
      )  dut (
          .clk(~clk),
          .rst(rst),
          .push_valid(push_valid),
          .push_data(push_data),
          .push_fifo_id(push_fifo_id),
          .pop_ready(pop_ready),
          .push_ready(push_ready),
          .pop_valid(pop_valid),
          .pop_data(pop_data)
      );


  //===========================================================
  // Clock Generation
  //===========================================================
  initial begin
    clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR/(2*CLOCK_FREQ)) clk = ~clk;
  end


  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_valid <= 'h0;
    push_data <= 'h0;
    push_fifo_id <= 'h0;
    pop_ready <= 'h0;

    // Wiggling the reset signal.
    rst = 1'bx;
    #RESET_DURATION;
    rst = 1'b1;
    #RESET_DURATION;
    rst = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushAndPopIdx,
    test_PushWithBackpressureIdx,
    test_ConcurrentPushAndPopIdx,
    test_BoundaryConditionPushIdx,
    test_PopWithStagingBufferIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

  `ifdef WAVES_AS_FSDB
     bit enable_fsdb;
  `endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
      if (NO_ASSERTS_ON_RESET) $assertoff;
      #(TIMEOUT);
      $display("Error: Testbench timeout!");
      $finish;
  end

  `ifdef WAVES_AS_FSDB
    initial begin
      // Enable FSDB dump for TB and DUT
      if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
        $fsdbDumpfile("tb.fsdb");
        $fsdbDumpvars(0, br_fifo_shared_dynamic_flops_gen_tb, "+all");
      end
    end
  `endif


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushAndPop();

    reset_dut();
    test_PushWithBackpressure();

    reset_dut();
    test_ConcurrentPushAndPop();

    reset_dut();
    test_BoundaryConditionPush();

    reset_dut();
    test_PopWithStagingBuffer();

    if (err_count_arr[test_BasicPushAndPopIdx] == 0) begin
      $display("Test test_BasicPushAndPop PASSED");
    end else if (err_count_arr[test_BasicPushAndPopIdx] == -1) begin
      $display("Test test_BasicPushAndPop TIMEOUT");
    end else begin
      $display("Test test_BasicPushAndPop FAILED");
    end

    if (err_count_arr[test_PushWithBackpressureIdx] == 0) begin
      $display("Test test_PushWithBackpressure PASSED");
    end else if (err_count_arr[test_PushWithBackpressureIdx] == -1) begin
      $display("Test test_PushWithBackpressure TIMEOUT");
    end else begin
      $display("Test test_PushWithBackpressure FAILED");
    end

    if (err_count_arr[test_ConcurrentPushAndPopIdx] == 0) begin
      $display("Test test_ConcurrentPushAndPop PASSED");
    end else if (err_count_arr[test_ConcurrentPushAndPopIdx] == -1) begin
      $display("Test test_ConcurrentPushAndPop TIMEOUT");
    end else begin
      $display("Test test_ConcurrentPushAndPop FAILED");
    end

    if (err_count_arr[test_BoundaryConditionPushIdx] == 0) begin
      $display("Test test_BoundaryConditionPush PASSED");
    end else if (err_count_arr[test_BoundaryConditionPushIdx] == -1) begin
      $display($sformatf({"Test test_BoundaryConditionPush TIMEOUT"}));
    end else begin
      $display("Test test_BoundaryConditionPush FAILED");
    end

    if (err_count_arr[test_PopWithStagingBufferIdx] == 0) begin
      $display("Test test_PopWithStagingBuffer PASSED");
    end else if (err_count_arr[test_PopWithStagingBufferIdx] == -1) begin
      $display("Test test_PopWithStagingBuffer TIMEOUT");
    end else begin
      $display("Test test_PopWithStagingBuffer FAILED");
    end


    if ( err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end


  task automatic test_BasicPushAndPop;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: test_BasicPushAndPop"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_BasicPushAndPop. Stimuli is not ","observed or it needs more time to finish"," this test."}, $time));
        err_count_arr[test_BasicPushAndPopIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // Task to verify basic push and pop operations in the FIFO, ensuring data integrity and correct functionality.

        // Local variables declaration
        int test_failed = 0;
        logic[NumWritePorts-1:0] local_push_valid;
        logic[NumWritePorts-1:0][Width-1:0] local_push_data;
        logic[NumWritePorts-1:0][FifoIdWidth-1:0] local_push_fifo_id;
        logic[NumFifos-1:0] local_pop_ready;
        logic[NumFifos-1:0] expected_pop_valid;
        logic[NumFifos-1:0][Width-1:0] expected_pop_data;

        // Initialize expected values
        expected_pop_valid = '0;
        expected_pop_data = '0;

        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);

        // Release reset and wait for the DUT to stabilize
        rst = 1'b0;
        @(posedge clk);

        // Drive push signals to push data into the FIFO
        local_push_valid = 1'b1;
        local_push_data[0] = 8'hA5;
        local_push_fifo_id = 2'b00;
        push_valid = local_push_valid;
        push_data[0] = local_push_data[0];
        push_fifo_id = local_push_fifo_id;

        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","Driving push_valid=0x%h, push_data=0x%h,"," push_fifo_id=0x%h"}, $time, local_push_valid, local_push_data[0], local_push_fifo_id));

        // Wait for push_ready to be asserted
        wait (push_ready[0] == 1'b1);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","push_ready asserted"}, $time));

        // Drive pop_ready to pop data from the FIFO
        local_pop_ready = 1'b1;
        pop_ready = local_pop_ready;

        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","Driving pop_ready=0x%h"}, $time, local_pop_ready));

        // Wait for pop_valid to be asserted
        wait (pop_valid[0] == 1'b1);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","pop_valid asserted"}, $time));

        // Check pop_data for expected value
        expected_pop_data[0] = 8'hA5;
        if (pop_data[0] !== expected_pop_data[0]) begin
          $display($sformatf({"Time: %0t, ERROR: test_BasicPushAndPop -"," Check failed. Expected pop_data=0x%h, ","got 0x%h"}, $time, expected_pop_data[0], pop_data[0]));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: test_BasicPushAndPop - ","Check passed. Expected value for ","pop_data is the same as the observed ","value (both are 0x%h)."}, $time, pop_data[0]));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: test_BasicPushAndPop"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: test_BasicPushAndPop"}, $time));
          err_count_arr[test_BasicPushAndPopIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PushWithBackpressure;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_PushWithBackpressure"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_PushWithBackpressure. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_PushWithBackpressureIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the FIFO's handling of backpressure during push operations, ensuring data integrity and proper management of push requests when the FIFO is full.

        // Local variables declaration
        int test_failed = 0;
        int push_data_sequence[Depth];
        int push_fifo_id_sequence[Depth];
        int data_index = 0;
        int fifo_id_index = 0;
        logic[NumWritePorts-1:0] local_push_valid;
        logic[NumWritePorts-1:0][Width-1:0] local_push_data;
        logic[NumWritePorts-1:0][FifoIdWidth-1:0] local_push_fifo_id;
        logic backpressure_detected = 0;

        // Initialize push data and FIFO ID sequences
        for (int i = 0; i < Depth; i++) begin
          push_data_sequence[i] = $urandom_range(0, (1 << Width) - 1);
          push_fifo_id_sequence[i] = i % NumFifos;
        end

        // Wait for reset deassertion
        @(negedge rst);

        // Drive push_valid, push_data, and push_fifo_id continuously
        fork
          begin
            while (!backpressure_detected) begin
              for (int i = 0; i < NumWritePorts; i++) begin
                local_push_valid[i] = 1'b1;
                local_push_data[i] = push_data_sequence[data_index];
                local_push_fifo_id[i] = push_fifo_id_sequence[fifo_id_index];
                data_index = (data_index + 1) % Depth;
                fifo_id_index = (fifo_id_index + 1) % Depth;
              end
              push_valid = local_push_valid;
              push_data = local_push_data;
              push_fifo_id = local_push_fifo_id;
              @(posedge clk);
              if (ENABLE_INFO_MESSAGES == 1)
                $display($sformatf({"Time: %0t, INFO: ","test_PushWithBackpressure - Driving ","push_valid=0x%h, push_data=0x%h, ","push_fifo_id=0x%h"}, $time, push_valid, push_data, push_fifo_id));
            end
          end
        join_none

        // Monitor push_ready for backpressure detection
        while (!backpressure_detected) begin
          @(posedge clk);
          if (push_ready !== {NumWritePorts{1'b1}}) begin
            backpressure_detected = 1;
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_PushWithBackpressure - Backpressure"," detected, push_ready=0x%h"}, $time, push_ready));
          end
        end

        // Hold push_valid, push_data, and push_fifo_id stable during backpressure
        while (push_ready !== {NumWritePorts{1'b1}}) begin
          @(posedge clk);
        end

        // Resume driving push_valid, push_data, and push_fifo_id after backpressure
        fork
          begin
            for (int i = 0; i < NumWritePorts; i++) begin
              local_push_valid[i] = 1'b1;
              local_push_data[i] = push_data_sequence[data_index];
              local_push_fifo_id[i] = push_fifo_id_sequence[fifo_id_index];
              data_index = (data_index + 1) % Depth;
              fifo_id_index = (fifo_id_index + 1) % Depth;
            end
            push_valid = local_push_valid;
            push_data = local_push_data;
            push_fifo_id = local_push_fifo_id;
            @(posedge clk);
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_PushWithBackpressure - Resumed ","driving push_valid=0x%h, push_data=0x%h,"," push_fifo_id=0x%h"}, $time, push_valid, push_data, push_fifo_id));
          end
        join_none

        // Check if no data was lost during backpressure
        if (test_failed != 1) test_failed = 0;

        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_PushWithBackpressure"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_PushWithBackpressure"}, $time));
          err_count_arr[test_PushWithBackpressureIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_ConcurrentPushAndPop;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_ConcurrentPushAndPop"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_ConcurrentPushAndPop. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_ConcurrentPushAndPopIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task tests concurrent push and pop operations across multiple logical FIFOs, ensuring data integrity and order.

        // Local variables declaration
        int test_failed = 0;
        int fifo_id;
        int expected_data[NumFifos];
        int data;
        int wport;

        // Initialize expected data array
        for (int i = 0; i < NumFifos; i++) begin
          expected_data[i] = 0;
        end

        // Wait for reset to complete
        @(negedge rst);
        @(posedge clk);

        // Drive push_valid, push_data, and push_fifo_id
        fork
          for (int i = 0; i < NumWritePorts; i++) begin
            data = $urandom();
            fifo_id = $urandom_range(0, NumFifos - 1);
            push_valid[i] = 1'b1;
            push_data[i] = (data << FifoIdWidth) | i;
            push_fifo_id[i] = fifo_id;
            expected_data[fifo_id] = push_data[i];
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - Driving ","push_valid[%0d]=1, push_data[%0d]=0x%h, ","push_fifo_id[%0d]=%0d"}, $time, i, i, push_data[i], i, fifo_id));
          end
        join

        // Wait for push_ready to be high for all write ports
        wait (push_ready == {NumWritePorts{1'b1}});
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - All ","push_ready signals are high"}, $time));

        // Drive pop_ready for all FIFOs
        pop_ready = {NumFifos{1'b1}};
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - Driving ","pop_ready=0x%h"}, $time, pop_ready));

        // Wait for pop_valid to be high for all FIFOs
        wait (pop_valid == {NumFifos{1'b1}});
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - All ","pop_valid signals are high"}, $time));

        // Check pop_data for each FIFO
        for (int i = 0; i < NumFifos; i++) begin
          if (pop_data[i] !== expected_data[i]) begin
            $display($sformatf({"Time: %0t, ERROR: ","test_ConcurrentPushAndPop - Check failed"," for FIFO %0d. Expected 0x%h, got 0x%h"}, $time, i, expected_data[i], pop_data[i]));
            test_failed = 1;
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_ConcurrentPushAndPop - Check passed"," for FIFO %0d. Expected and observed ","value is 0x%h"}, $time, i, pop_data[i]));
          end
        end

        // Report test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_ConcurrentPushAndPop"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_ConcurrentPushAndPop"}, $time));
          err_count_arr[test_ConcurrentPushAndPopIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_BoundaryConditionPush;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_BoundaryConditionPush"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_BoundaryConditionPush. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_BoundaryConditionPushIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the FIFO's ability to handle boundary conditions without data loss or corruption when pushed to its maximum capacity.

        // Local variables declaration
        int test_failed = 0;
        int data_counter;
        int expected_data[Depth];
        int fifo_id_counter;
        int pop_counter;
        logic [Width-1:0] temp_data;
        logic [FifoIdWidth-1:0] temp_fifo_id;

        // Initialize expected data sequence
        for (int i = 0; i < Depth; i++) begin
          expected_data[i] = i;
        end

        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);

        // Deassert reset and start normal operation
        rst = 1'b0;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_BoundaryConditionPush - Reset ","deasserted, starting normal operation."}, $time));

        // Drive push_valid, push_data, and push_fifo_id until FIFO is full
        data_counter = 0;
        fifo_id_counter = 0;
        while (push_ready != 0) begin
          for (int i = 0; i < NumWritePorts; i++) begin
            temp_data = expected_data[data_counter % Depth];
            temp_fifo_id = fifo_id_counter % NumFifos;
            push_valid[i] = 1'b1;
            push_data[i] = temp_data;
            push_fifo_id[i] = temp_fifo_id;
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_BoundaryConditionPush - Driving ","push_valid[%0d]=1, push_data[%0d]=0x%h, ","push_fifo_id[%0d]=0x%h"}, $time, i, i, temp_data, i, temp_fifo_id));
          end
          @(posedge clk);
          data_counter++;
          fifo_id_counter++;
        end

        // Check if FIFO is full
        if (push_ready == 0) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BoundaryConditionPush - FIFO is ","full, push_ready=0"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BoundaryConditionPush - FIFO is not"," full as expected, push_ready=%b"}, $time, push_ready));
          test_failed = 1;
        end

        // Verify data integrity using pop operations
        pop_counter = 0;
        while (pop_counter < Depth) begin
          for (int i = 0; i < NumFifos; i++) begin
            pop_ready[i] = 1'b1;
          end
          @(posedge clk);
          for (int i = 0; i < NumFifos; i++) begin
            if (pop_valid[i]) begin
              if (pop_data[i] !== expected_data[pop_counter]) begin
                $display($sformatf({"Time: %0t, ERROR: ","test_BoundaryConditionPush - Data ","mismatch at FIFO %0d. Expected 0x%h, got"," 0x%h"}, $time, i, expected_data[pop_counter], pop_data[i]));
                test_failed = 1;
              end else if (ENABLE_INFO_MESSAGES == 1) begin
                $display($sformatf({"Time: %0t, INFO: ","test_BoundaryConditionPush - Data match ","at FIFO %0d. Expected and got 0x%h"}, $time, i, pop_data[i]));
              end
              pop_counter++;
            end
          end
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_BoundaryConditionPush"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_BoundaryConditionPush"}, $time));
          err_count_arr[test_BoundaryConditionPushIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PopWithStagingBuffer;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_PopWithStagingBuffer"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_PopWithStagingBuffer. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_PopWithStagingBufferIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the FIFO's pop operation with staging buffer, ensuring correct data retrieval and expected latency.

        // Local variables declaration
        int test_failed = 0;
        int constant_push_data;
        int expected_latency;
        int observed_latency;
        int fifo_id;
        int cycle_count;
        logic [Width-1:0] observed_data;

        // Calculate expected latency
        localparam int latency_divisor = PointerRamAddressDepthStages + PointerRamReadDataDepthStages + PointerRamReadDataWidthStages + 1;
        expected_latency = StagingBufferDepth / latency_divisor;
        if (RegisterPopOutputs) expected_latency += 1;

        // Initialize variables
        constant_push_data = $urandom_range(0, (1 << Width) - 1);
        fifo_id = $urandom_range(0, NumFifos - 1);
        cycle_count = 0;

        // Release reset and start normal operation
        @(posedge clk);
        rst = 1'b0;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PopWithStagingBuffer - Reset ","released, starting normal operation."}, $time));

        // Drive push_valid, push_data, and push_fifo_id to preload FIFO
        push_valid[0] = 1'b1;
        push_data[0] = constant_push_data;
        push_fifo_id[0] = fifo_id;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PopWithStagingBuffer - Driving ","push_valid=0x%h, push_data=0x%h, ","push_fifo_id=0x%h."}, $time, push_valid, push_data, push_fifo_id));

        // Wait for push_ready to be asserted
        while (!push_ready[0]) @(posedge clk);

        // Drive pop_ready for the corresponding FIFO ID
        pop_ready[fifo_id] = 1'b1;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PopWithStagingBuffer - Driving ","pop_ready=0x%h for FIFO ID %0d."}, $time, pop_ready, fifo_id));

        // Wait for pop_valid to be asserted
        while (!pop_valid[fifo_id]) begin
          @(posedge clk);
          cycle_count++;
        end

        // Capture observed data
        observed_data = pop_data[fifo_id];

        // Verify data integrity
        if (observed_data !== constant_push_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_PopWithStagingBuffer - Data ","integrity check failed. Expected 0x%h, ","got 0x%h."}, $time, constant_push_data, observed_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_PopWithStagingBuffer - Data ","integrity check passed. Expected and ","observed data are both 0x%h."}, $time, observed_data));
        end

        // Verify latency
        observed_latency = cycle_count;
        if (observed_latency !== expected_latency) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_PopWithStagingBuffer - Latency ","check failed. Expected %0d cycles, got ","%0d cycles."}, $time, expected_latency, observed_latency));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_PopWithStagingBuffer - Latency ","check passed. Expected and observed ","latency are both %0d cycles."}, $time, observed_latency));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_PopWithStagingBuffer"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_PopWithStagingBuffer"}, $time));
          err_count_arr[test_PopWithStagingBufferIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
