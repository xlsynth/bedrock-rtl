
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_fifo_ctrl_1r1w
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-18 22:04:33
// Description: Unit test for br_fifo_ctrl_1r1w
//=============================================================

module br_fifo_ctrl_1r1w_gen_tb;
  timeunit 1ns;
  timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;     // Clock frequency in MHz
  parameter int RESET_DURATION = 100;    // Reset duration in ns
  parameter int TIMEOUT = 10000000;          // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000; // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;        // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000; // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks

  //===========================================================
  // DUT Imports and Includes
  //===========================================================

  `include "br_asserts_internal.svh"

  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int Depth = 4;
  parameter int Width = 4;
  parameter bit EnableBypass = 1;
  parameter bit RegisterPopOutputs = 0;
  parameter int RamReadLatency = 0;
  parameter int RamDepth = Depth;
  parameter bit EnableCoverPushBackpressure = 1;
  parameter bit EnableAssertPushValidStability = EnableCoverPushBackpressure;
  parameter bit EnableAssertPushDataStability = EnableAssertPushValidStability;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int AddrWidth = br_math::clamped_clog2(RamDepth);
  localparam int CountWidth = $clog2((Depth + 1));

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic clk;
  logic rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic push_valid;
  logic[Width-1:0] push_data;
  logic pop_ready;
  logic ram_rd_data_valid;
  logic[    Width-1:0] ram_rd_data;
  logic push_ready;
  logic pop_valid;
  logic[Width-1:0] pop_data;
  logic full;
  logic full_next;
  logic[CountWidth-1:0] slots;
  logic[CountWidth-1:0] slots_next;
  logic empty;
  logic empty_next;
  logic[CountWidth-1:0] items;
  logic[CountWidth-1:0] items_next;
  logic ram_wr_valid;
  logic[AddrWidth-1:0] ram_wr_addr;
  logic[    Width-1:0] ram_wr_data;
  logic ram_rd_addr_valid;
  logic[AddrWidth-1:0] ram_rd_addr;

  //===========================================================
  // DUT Instantiation
  //===========================================================
// Clock to DUT is inverted to avoid race condition between DUT and TB
  br_fifo_ctrl_1r1w
      #(
          .Depth(Depth),
          .Width(Width),
          .EnableBypass(EnableBypass),
          .RegisterPopOutputs(RegisterPopOutputs),
          .RamReadLatency(RamReadLatency),
          .RamDepth(RamDepth),
          .EnableCoverPushBackpressure(EnableCoverPushBackpressure),
          .EnableAssertPushValidStability(EnableAssertPushValidStability),
          .EnableAssertPushDataStability(EnableAssertPushDataStability),
          .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
      )  dut (
          .clk(~clk),
          .rst(rst),
          .push_valid(push_valid),
          .push_data(push_data),
          .pop_ready(pop_ready),
          .ram_rd_data_valid(ram_rd_data_valid),
          .ram_rd_data(ram_rd_data),
          .push_ready(push_ready),
          .pop_valid(pop_valid),
          .pop_data(pop_data),
          .full(full),
          .full_next(full_next),
          .slots(slots),
          .slots_next(slots_next),
          .empty(empty),
          .empty_next(empty_next),
          .items(items),
          .items_next(items_next),
          .ram_wr_valid(ram_wr_valid),
          .ram_wr_addr(ram_wr_addr),
          .ram_wr_data(ram_wr_data),
          .ram_rd_addr_valid(ram_rd_addr_valid),
          .ram_rd_addr(ram_rd_addr)
      );
  //===========================================================
  // Clock Generation
  //===========================================================
  initial begin
    clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR/(2*CLOCK_FREQ)) clk = ~clk;
  end
  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_valid <= 'h0;
    push_data <= 'h0;
    pop_ready <= 'h0;
    ram_rd_data_valid <= 'h0;
    ram_rd_data <= 'h0;

    // Wiggling the reset signal.
    rst = 1'bx;
    #RESET_DURATION;
    rst = 1'b1;
    #RESET_DURATION;
    rst = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask
  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushPopFunctionalityIdx,
    test_BypassModeVerificationIdx,
    test_BackpressureHandlingIdx,
    test_RamReadLatencyVerificationIdx,
    test_PushDataStabilityUnderBackpressureIdx,
    test_PopDataStabilityUnderPressureIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

  `ifdef WAVES_AS_FSDB
     bit enable_fsdb;
  `endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
      if (NO_ASSERTS_ON_RESET) $assertoff;
      #(TIMEOUT);
      $display("Error: Testbench timeout!");
      $finish;
  end

  `ifdef WAVES_AS_FSDB
    initial begin
      // Enable FSDB dump for TB and DUT
      if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
        $fsdbDumpfile("tb.fsdb");
        $fsdbDumpvars(0, br_fifo_ctrl_1r1w_gen_tb, "+all");
      end
    end
  `endif
  //===========================================================
  // Memory Model
  //===========================================================
  // Simple synchronous 1R1W memory model with parameterizable read latency.
  // Writes happen on rising edge if `ram_wr_valid` is asserted.
  // Reads are pipelined by `RamReadLatency` cycles. When `ram_rd_addr_valid` is asserted,
  // the data will come out `RamReadLatency` cycles later with `ram_rd_data_valid`.

  logic [Width-1:0] mem [0:RamDepth-1];

  // For pipeline read latencies, we keep a small pipeline for the read data & valid.
  // The pipeline depth is `RamReadLatency + 1`, with stage 0 capturing the memory read.
  // The last stage is the final output to the DUT.

  // Pipeline signals
  logic [Width-1:0]        rdata_pipe     [0:RamReadLatency];
  logic                    rvalid_pipe    [0:RamReadLatency];
  logic [AddrWidth-1:0]    raddr_pipe     [0:RamReadLatency]; // (Sometimes helpful if needed)

  // Write operation (synchronous)
  always_ff @(posedge clk) begin
    if (ram_wr_valid) begin
      mem[ram_wr_addr] <= ram_wr_data;
    end
  end

  // Read pipeline
  generate
    if (RamReadLatency == 0) begin : no_latency
      // For zero latency, we model a purely "combinational" read below.
      // You could also do a synchronous read that returns data in the *same* clock,
      // but typically that is more of an asynchronous read approach in real hardware.
      // We'll tie ram_rd_data and ram_rd_data_valid combinationally:
      always_comb begin
        ram_rd_data_valid = ram_rd_addr_valid;
        ram_rd_data       = ram_rd_addr_valid ? mem[ram_rd_addr] : '0;
      end

    end else begin : with_latency
      // If RamReadLatency > 0, set up a small pipeline:
      integer i;
      always_ff @(posedge clk) begin
        // Stage 0: capture the memory read
        rdata_pipe[0]  <= mem[ram_rd_addr];
        rvalid_pipe[0] <= ram_rd_addr_valid;
        raddr_pipe[0]  <= ram_rd_addr;

        // Shift down the pipeline
        for (i = 1; i <= RamReadLatency; i++) begin
          rdata_pipe[i]  <= rdata_pipe[i-1];
          rvalid_pipe[i] <= rvalid_pipe[i-1];
          raddr_pipe[i]  <= raddr_pipe[i-1];
        end
      end

      // Assign the last pipeline stage to outputs
      always_comb begin
        ram_rd_data_valid = rvalid_pipe[RamReadLatency];
        ram_rd_data       = rdata_pipe[RamReadLatency];
      end
    end
  endgenerate


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushPopFunctionality();

    reset_dut();
    test_BypassModeVerification();

    reset_dut();
    test_BackpressureHandling();

    reset_dut();
    test_RamReadLatencyVerification();

    if (err_count_arr[test_BasicPushPopFunctionalityIdx] == 0) begin
      $display("Test test_BasicPushPopFunctionality PASSED");
    end else if (err_count_arr[test_BasicPushPopFunctionalityIdx] == -1) begin
      $display("Test test_BasicPushPopFunctionality TIMEOUT");
    end else begin
      $display("Test test_BasicPushPopFunctionality FAILED");
    end

    if (err_count_arr[test_BypassModeVerificationIdx] == 0) begin
      $display("Test test_BypassModeVerification PASSED");
    end else if (err_count_arr[test_BypassModeVerificationIdx] == -1) begin
      $display("Test test_BypassModeVerification TIMEOUT");
    end else begin
      $display("Test test_BypassModeVerification FAILED");
    end

    if (err_count_arr[test_BackpressureHandlingIdx] == 0) begin
      $display("Test test_BackpressureHandling PASSED");
    end else if (err_count_arr[test_BackpressureHandlingIdx] == -1) begin
      $display("Test test_BackpressureHandling TIMEOUT");
    end else begin
      $display("Test test_BackpressureHandling FAILED");
    end

    if (err_count_arr[test_RamReadLatencyVerificationIdx] == 0) begin
      $display("Test test_RamReadLatencyVerification PASSED");
    end else if (err_count_arr[test_RamReadLatencyVerificationIdx] == -1) begin
      $display("Test test_RamReadLatencyVerification TIMEOUT");
    end else begin
      $display("Test test_RamReadLatencyVerification FAILED");
    end


    if ( err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end
  task automatic test_BasicPushPopFunctionality;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display("Time: %0t, FAILED: test_BasicPushPopFunctionality", $time);
        $display("Time: %0t, INFO: Timeout: test_BasicPushPopFunctionality. Stimuli is not observed or it needs more time to finish this test.", $time);
        err_count_arr[test_BasicPushPopFunctionalityIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the basic push and pop functionality of the FIFO, ensuring it handles data correctly until full and then empties correctly.

        // Local variables declaration
        int test_failed = 0;
        int push_data_sequence[Depth];
        int pop_data_sequence[Depth];
        int push_index;
        int pop_index;
        int random_data;
        pop_ready = 0;
        // Initialize push data sequence with random values
        for (int i = 0; i < Depth; i++) begin
          push_data_sequence[i] = $urandom_range(0, (1 << Width) - 1);
        end

        // Wait for reset to complete and FIFO to be empty
        @(posedge clk);
        while (!empty) @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_BasicPushPopFunctionality - FIFO is empty after reset.", $time);

        // Push data into the FIFO until full
        push_index = 0;
        while (!full) begin
          push_valid = 1;
          push_data = push_data_sequence[push_index];
          if (push_ready) begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display("Time: %0t, INFO: test_BasicPushPopFunctionality - Pushed data: 0x%h", $time, push_data);
            push_index++;
          end
          @(posedge clk);
        end
        push_valid = 0;
        if (full) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display("Time: %0t, INFO: test_BasicPushPopFunctionality - FIFO is full.", $time);
        end else begin
          $display("Time: %0t, ERROR: test_BasicPushPopFunctionality - FIFO did not become full as expected.", $time);
          test_failed = 1;
        end

        // Pop data from the FIFO until empty
        pop_ready = 1;
        pop_index = 0;
        while (!empty) begin
           @ (posedge clk)
          if (pop_valid) begin
            pop_data_sequence[pop_index] = pop_data;
            if (ENABLE_INFO_MESSAGES == 1)
              $display("Time: %0t, INFO: test_BasicPushPopFunctionality - Popped data: 0x%h", $time, pop_data);
            pop_index++;
          end
        end
        pop_data_sequence[pop_index] = pop_data;
        pop_ready = 0;
        if (empty) begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display("Time: %0t, INFO: test_BasicPushPopFunctionality - FIFO is empty.", $time);
        end else begin
          $display("Time: %0t, ERROR: test_BasicPushPopFunctionality - FIFO did not become empty as expected.", $time);
          test_failed = 1;
        end

        // Verify that the pushed and popped data sequences match
        for (int i = 0; i < Depth; i++) begin
          if (push_data_sequence[i] !== pop_data_sequence[i]) begin
            $display("Time: %0t, ERROR: test_BasicPushPopFunctionality - Data mismatch at index %0d. Pushed: 0x%h, Popped: 0x%h", $time, i, push_data_sequence[i], pop_data_sequence[i]);
            test_failed = 1;
          end
        end

        if (test_failed == 0) begin
          $display("Time: %0t, PASSED: test_BasicPushPopFunctionality", $time);
        end else begin
          $display("Time: %0t, FAILED: test_BasicPushPopFunctionality", $time);
          err_count_arr[test_BasicPushPopFunctionalityIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  task automatic test_BypassModeVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display("Time: %0t, FAILED: test_BypassModeVerification", $time);
        $display("Time: %0t, INFO: Timeout: test_BypassModeVerification. Stimuli is not observed or it needs more time to finish this test.", $time);
        err_count_arr[test_BypassModeVerificationIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the bypass mode functionality, ensuring data is transferred directly from push to pop interface with zero-cycle latency when the FIFO is empty.

        // Local variables declaration
        int test_failed = 0;
        logic [Width-1:0] expected_data;
        logic [Width-1:0] observed_data;

        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);
        // Generate random data for push_data
        expected_data = $urandom_range(0, (1 << Width) - 1);

        // Drive push_valid and push_data
        push_valid = 1'b1;
        push_data = expected_data;
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_BypassModeVerification - Driving push_valid=1, push_data=0x%h", $time, push_data);

        // Wait for empty signal to be asserted
        while (!empty) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_BypassModeVerification - FIFO is empty", $time);

        // Assert pop_ready
        pop_ready = 1'b1;
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_BypassModeVerification - Asserting pop_ready=1", $time);

        // Wait for pop_valid to be asserted
        while (!pop_valid) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_BypassModeVerification - pop_valid is asserted", $time);

        // Capture observed data from pop_data
        observed_data = pop_data;

        // Verify that the observed data matches the expected data
        if (observed_data !== expected_data) begin
          $display("Time: %0t, ERROR: test_BypassModeVerification - Check failed. Expected 0x%h, got 0x%h", $time, expected_data, observed_data);
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display("Time: %0t, INFO: test_BypassModeVerification - Check passed. Expected value for pop_data is the same as the observed value (both are 0x%h).", $time, observed_data);
        end

        // Reset push_valid and pop_ready
        push_valid = 1'b0;
        pop_ready = 1'b0;

        // Final test status
        if (test_failed == 0) begin
          $display("Time: %0t, PASSED: test_BypassModeVerification", $time);
        end else begin
          $display("Time: %0t, FAILED: test_BypassModeVerification", $time);
          err_count_arr[test_BypassModeVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  task automatic test_BackpressureHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display("Time: %0t, FAILED: test_BackpressureHandling", $time);
        $display("Time: %0t, INFO: Timeout: test_BackpressureHandling. Stimuli is not observed or it needs more time to finish this test.", $time);
        err_count_arr[test_BackpressureHandlingIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the FIFO correctly handles backpressure by deasserting `push_ready` when the FIFO is full, preventing further data from being pushed.

        // Local variables declaration
        int test_failed = 0;
        int data;
        int cycle_count = 0;
        int max_cycles = Depth + 2; // Maximum cycles to fill the FIFO and check backpressure

        // Wait for a positive edge of the clock to ensure proper stimulus propagation
        @(posedge clk);

        // Step 1: Assert reset
        rst = 1'b1;
        @(posedge clk);
        rst = 1'b0;
        @(posedge clk);

        // Step 2: Assert push_valid and provide data on push_data
        push_valid = 1'b1;
        data = $urandom_range(0, (1 << Width) - 1);
        push_data = data;
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_BackpressureHandling - Driving push_valid=1, push_data=0x%h", $time, push_data);

        // Wait for push_ready to be asserted
        while (!push_ready) begin
          @(posedge clk);
        end

        // Step 3: Continue asserting push_valid and provide new data while monitoring full_next
        while (cycle_count < max_cycles) begin
          data = $urandom_range(0, (1 << Width) - 1);
          push_data = data;
          if (ENABLE_INFO_MESSAGES == 1)
            $display("Time: %0t, INFO: test_BackpressureHandling - Driving push_valid=1, push_data=0x%h", $time, push_data);

          @(posedge clk);

          if (full_next) begin
            // Step 4: Wait for push_ready to be deasserted, confirming FIFO is full
            while (push_ready) begin
              @(posedge clk);
            end
            if (ENABLE_INFO_MESSAGES == 1)
              $display("Time: %0t, INFO: test_BackpressureHandling - push_ready deasserted, FIFO is full", $time);

            // Step 5: Continue asserting push_valid and ensure push_ready remains deasserted
            for (int i = 0; i < 3; i++) begin
              @(posedge clk);
              if (push_ready) begin
                $display("Time: %0t, ERROR: test_BackpressureHandling - push_ready unexpectedly asserted", $time);
                test_failed = 1;
              end
            end
            break;
          end

          cycle_count++;
        end

        // Check if the test passed or failed
        if (test_failed == 0) begin
          $display("Time: %0t, PASSED: test_BackpressureHandling", $time);
        end else begin
          $display("Time: %0t, FAILED: test_BackpressureHandling", $time);
          err_count_arr[test_BackpressureHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask
  task automatic test_RamReadLatencyVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display("Time: %0t, FAILED: test_RamReadLatencyVerification", $time);
        $display("Time: %0t, INFO: Timeout: test_RamReadLatencyVerification. Stimuli is not observed or it needs more time to finish this test.", $time);
        err_count_arr[test_RamReadLatencyVerificationIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the FIFO correctly handles a RamReadLatency of 0, ensuring immediate data availability at the pop interface.

        // Local variables declaration
        int test_failed = 0;
        logic[Width-1:0] expected_data;
        logic[Width-1:0] observed_data;
        logic[Width-1:0] random_data;

        // Initial delay to ensure proper stimulus propagation
        @(posedge clk);

        // Step 1: Assert reset and then deassert it
        rst = 1'b1;
        @(posedge clk);
        rst = 1'b0;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_RamReadLatencyVerification - Reset deasserted, starting normal operation.", $time);

        // Step 2: Assert push_valid and provide data on push_data
        random_data = $urandom_range(0, (1 << Width) - 1);
        push_valid = 1'b1;
        push_data = random_data;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_RamReadLatencyVerification - Driving push_valid=1, push_data=0x%h", $time, push_data);

        // Wait for push_ready to be asserted
        while (!push_ready) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_RamReadLatencyVerification - push_ready asserted, FIFO is ready to accept data.", $time);

        // Step 3: Assert pop_ready
        pop_ready = 1'b1;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_RamReadLatencyVerification - Driving pop_ready=1", $time);

        // Wait for pop_valid to be asserted
        while (!pop_valid) begin
          @(posedge clk);
        end
        if (ENABLE_INFO_MESSAGES == 1)
          $display("Time: %0t, INFO: test_RamReadLatencyVerification - pop_valid asserted, data is available at pop interface.", $time);

        // Step 4: Read data from pop_data and verify
        observed_data = pop_data;
        expected_data = random_data;
        if (observed_data !== expected_data) begin
          $display("Time: %0t, ERROR: test_RamReadLatencyVerification - Check failed. Expected 0x%h, got 0x%h", $time, expected_data, observed_data);
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display("Time: %0t, INFO: test_RamReadLatencyVerification - Check passed. Expected value for pop_data is the same as the observed value (both are 0x%h).", $time, observed_data);
        end

        // Final test status
        if (test_failed == 0) begin
          $display("Time: %0t, PASSED: test_RamReadLatencyVerification", $time);
        end else begin
          $display("Time: %0t, FAILED: test_RamReadLatencyVerification", $time);
          err_count_arr[test_RamReadLatencyVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
