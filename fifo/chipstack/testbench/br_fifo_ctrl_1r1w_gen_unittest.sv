
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_fifo_ctrl_1r1w
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-17 19:39:07
// Description: Unit test for br_fifo_ctrl_1r1w
//=============================================================



module br_fifo_ctrl_1r1w_gen_tb;
  timeunit 1ns;
  timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;     // Clock frequency in MHz
  parameter int RESET_DURATION = 100;    // Reset duration in ns
  parameter int TIMEOUT = 10000000;          // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000; // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;        // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000; // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks

  //===========================================================
  // DUT Imports and Includes
  //===========================================================

  `include "br_asserts_internal.svh"

  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int Depth = 2;
  parameter int Width = 1;
  parameter bit EnableBypass = 1;
  parameter bit RegisterPopOutputs = 0;
  parameter int RamReadLatency = 0;
  parameter int RamDepth = Depth;
  parameter bit EnableCoverPushBackpressure = 1;
  parameter bit EnableAssertPushValidStability = EnableCoverPushBackpressure;
  parameter bit EnableAssertPushDataStability = EnableAssertPushValidStability;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int AddrWidth = br_math::clamped_clog2(RamDepth);
  localparam int CountWidth = $clog2((Depth + 1));

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic clk;
  logic rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic push_valid;
  logic[Width-1:0] push_data;
  logic pop_ready;
  logic ram_rd_data_valid;
  logic[    Width-1:0] ram_rd_data;
  logic push_ready;
  logic pop_valid;
  logic[Width-1:0] pop_data;
  logic full;
  logic full_next;
  logic[CountWidth-1:0] slots;
  logic[CountWidth-1:0] slots_next;
  logic empty;
  logic empty_next;
  logic[CountWidth-1:0] items;
  logic[CountWidth-1:0] items_next;
  logic ram_wr_valid;
  logic[AddrWidth-1:0] ram_wr_addr;
  logic[    Width-1:0] ram_wr_data;
  logic ram_rd_addr_valid;
  logic[AddrWidth-1:0] ram_rd_addr;

  //===========================================================
  // DUT Instantiation
  //===========================================================
// Clock to DUT is inverted to avoid race condition between DUT and TB
  br_fifo_ctrl_1r1w
      #(
          .Depth(Depth),
          .Width(Width),
          .EnableBypass(EnableBypass),
          .RegisterPopOutputs(RegisterPopOutputs),
          .RamReadLatency(RamReadLatency),
          .RamDepth(RamDepth),
          .EnableCoverPushBackpressure(EnableCoverPushBackpressure),
          .EnableAssertPushValidStability(EnableAssertPushValidStability),
          .EnableAssertPushDataStability(EnableAssertPushDataStability),
          .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
      )  dut (
          .clk(~clk),
          .rst(rst),
          .push_valid(push_valid),
          .push_data(push_data),
          .pop_ready(pop_ready),
          .ram_rd_data_valid(ram_rd_data_valid),
          .ram_rd_data(ram_rd_data),
          .push_ready(push_ready),
          .pop_valid(pop_valid),
          .pop_data(pop_data),
          .full(full),
          .full_next(full_next),
          .slots(slots),
          .slots_next(slots_next),
          .empty(empty),
          .empty_next(empty_next),
          .items(items),
          .items_next(items_next),
          .ram_wr_valid(ram_wr_valid),
          .ram_wr_addr(ram_wr_addr),
          .ram_wr_data(ram_wr_data),
          .ram_rd_addr_valid(ram_rd_addr_valid),
          .ram_rd_addr(ram_rd_addr)
      );


  //===========================================================
  // Clock Generation
  //===========================================================
  initial begin
    clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR/(2*CLOCK_FREQ)) clk = ~clk;
  end


  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_valid <= 'h0;
    push_data <= 'h0;
    pop_ready <= 'h0;
    ram_rd_data_valid <= 'h0;
    ram_rd_data <= 'h0;

    // Wiggling the reset signal.
    rst = 1'bx;
    #RESET_DURATION;
    rst = 1'b1;
    #RESET_DURATION;
    rst = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushPopFunctionalityIdx,
    test_BypassModeVerificationIdx,
    test_FullAndEmptyStatusUpdateIdx,
    test_PushBackpressureHandlingIdx,
    test_RamReadLatencyVerificationIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

  `ifdef WAVES_AS_FSDB
     bit enable_fsdb;
  `endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
      if (NO_ASSERTS_ON_RESET) $assertoff;
      #(TIMEOUT);
      $display("Error: Testbench timeout!");
      $finish;
  end

  `ifdef WAVES_AS_FSDB
    initial begin
      // Enable FSDB dump for TB and DUT
      if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
        $fsdbDumpfile("tb.fsdb");
        $fsdbDumpvars(0, br_fifo_ctrl_1r1w_gen_tb, "+all");
      end
    end
  `endif


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushPopFunctionality();

    reset_dut();
    test_BypassModeVerification();

    reset_dut();
    test_FullAndEmptyStatusUpdate();

    reset_dut();
    test_PushBackpressureHandling();

    reset_dut();
    test_RamReadLatencyVerification();

    if (err_count_arr[test_BasicPushPopFunctionalityIdx] == 0) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ","PASSED"}));
    end else if (err_count_arr[test_BasicPushPopFunctionalityIdx] == -1) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ","TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ","FAILED"}));
    end

    if (err_count_arr[test_BypassModeVerificationIdx] == 0) begin
      $display($sformatf({"Test test_BypassModeVerification PASSED"}));
    end else if (err_count_arr[test_BypassModeVerificationIdx] == -1) begin
      $display($sformatf({"Test test_BypassModeVerification TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BypassModeVerification FAILED"}));
    end

    if (err_count_arr[test_FullAndEmptyStatusUpdateIdx] == 0) begin
      $display($sformatf({"Test test_FullAndEmptyStatusUpdate ","PASSED"}));
    end else if (err_count_arr[test_FullAndEmptyStatusUpdateIdx] == -1) begin
      $display($sformatf({"Test test_FullAndEmptyStatusUpdate ","TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_FullAndEmptyStatusUpdate ","FAILED"}));
    end

    if (err_count_arr[test_PushBackpressureHandlingIdx] == 0) begin
      $display($sformatf({"Test test_PushBackpressureHandling ","PASSED"}));
    end else if (err_count_arr[test_PushBackpressureHandlingIdx] == -1) begin
      $display($sformatf({"Test test_PushBackpressureHandling ","TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_PushBackpressureHandling ","FAILED"}));
    end

    if (err_count_arr[test_RamReadLatencyVerificationIdx] == 0) begin
      $display($sformatf({"Test test_RamReadLatencyVerification ","PASSED"}));
    end else if (err_count_arr[test_RamReadLatencyVerificationIdx] == -1) begin
      $display($sformatf({"Test test_RamReadLatencyVerification ","TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_RamReadLatencyVerification ","FAILED"}));
    end


    if ( err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end


  task automatic test_BasicPushPopFunctionality;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_BasicPushPopFunctionality"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_BasicPushPopFunctionality. Stimuli ","is not observed or it needs more time to"," finish this test."}, $time));
        err_count_arr[test_BasicPushPopFunctionalityIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task tests the basic push and pop functionality of the FIFO by pushing data until full and then popping until empty.

        // Local variables declaration
        int test_failed = 0;
        int data_pushed;
        int data_popped;
        logic[Width-1:0] random_data;

        // Wait for the positive edge of the clock to ensure proper stimulus propagation
        @(posedge clk);

        // Initialize variables
        data_pushed = 0;
        data_popped = 0;

        // Push data into the FIFO until it is full
        while (!full) begin
          random_data = $urandom();
          push_valid = 1;
          push_data = random_data;
          @(posedge clk);
          if (push_ready) begin
            data_pushed++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - Pushed ","data: 0x%h, Total pushed: %0d"}, $time, random_data, data_pushed));
          end
        end

        // Check if FIFO is full
        if (!full) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - FIFO ","not full as expected."}, $time));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - FIFO is"," full as expected."}, $time));
        end

        // Deassert push_valid and start popping data
        push_valid = 0;
        pop_ready = 1;

        // Pop data from the FIFO until it is empty
        while (!empty) begin
          @(posedge clk);
          if (pop_valid) begin
            data_popped++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - Popped ","data: 0x%h, Total popped: %0d"}, $time, pop_data, data_popped));
          end
        end

        // Check if FIFO is empty
        if (!empty) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - FIFO ","not empty as expected."}, $time));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - FIFO is"," empty as expected."}, $time));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_BasicPushPopFunctionality"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_BasicPushPopFunctionality"}, $time));
          err_count_arr[test_BasicPushPopFunctionalityIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_BypassModeVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_BypassModeVerification"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_BypassModeVerification. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_BypassModeVerificationIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // Task to verify the FIFO's bypass mode functionality with minimal latency when empty
        // Local variables declaration
        int test_failed = 0;
        logic[Width-1:0] expected_data;
        logic[Width-1:0] observed_data;
        logic bypass_ready;

        // Initial delay to ensure proper stimulus propagation
        @(posedge clk);

        // Step 1: Set EnableBypass to 1 and assert push_valid with data on push_data
        push_valid = 1'b1;
        push_data = $urandom_range(0, (1 << Width) - 1);
        expected_data = push_data;
        $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - Driving ","push_valid=1, push_data=0x%h"}, $time, push_data));

        // Wait for bypass_ready to be driven high by the design
        wait (push_ready == 1'b1);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - Bypass ","ready detected"}, $time));

        // Step 2: Assert pop_ready and monitor pop_valid
        pop_ready = 1'b1;
        $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - Driving ","pop_ready=1"}, $time));

        // Wait for pop_valid to be driven high by the design
        wait (pop_valid == 1'b1);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - pop_valid ","asserted"}, $time));

        // Step 3: Read pop_data and verify it matches push_data
        observed_data = pop_data;
        if (observed_data !== expected_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BypassModeVerification - Data ","mismatch. Expected 0x%h, got 0x%h"}, $time, expected_data, observed_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - Data match"," confirmed. Expected and observed data: ","0x%h"}, $time, observed_data));
        end

        // Reset signals
        push_valid = 1'b0;
        pop_ready = 1'b0;

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_BypassModeVerification"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_BypassModeVerification"}, $time));
          err_count_arr[test_BypassModeVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_FullAndEmptyStatusUpdate;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_FullAndEmptyStatusUpdate"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_FullAndEmptyStatusUpdate. Stimuli ","is not observed or it needs more time to"," finish this test."}, $time));
        err_count_arr[test_FullAndEmptyStatusUpdateIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the FIFO accurately updates its full and empty status flags based on push and pop operations, reflecting its occupancy state.

        // Local variables declaration
        int test_failed = 0;
        int data_to_push;
        int push_count = 0;
        int pop_count = 0;
        int max_push_count = Depth;

        // Initial delay to ensure reset is complete
        @(posedge clk);

        // Step 1: Drive `push_valid` high and provide data on `push_data`
        while (push_count < max_push_count) begin
          data_to_push = $urandom_range(0, (1 << Width) - 1);
          push_valid = 1;
          push_data = data_to_push;

          if (push_ready) begin
            push_count++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_FullAndEmptyStatusUpdate - Pushed ","data: 0x%h, push_count: %0d"}, $time, data_to_push, push_count));
          end
          @(posedge clk);
        end

        // Wait for `full` to be asserted
        while (!full) begin
          @(posedge clk);
        end

        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_FullAndEmptyStatusUpdate - FIFO is ","full"}, $time));

        // Step 2: Deassert `push_valid` and assert `pop_ready`
        push_valid = 0;
        pop_ready = 1;
        @(posedge clk);

        // Wait for `empty` to be asserted
        if (EnableBypass) begin
          while (!empty) begin
            @(posedge clk);
          end
        end else begin
          repeat (RamReadLatency) @(posedge clk);
          while (!empty) begin
            @(posedge clk);
          end
        end

        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_FullAndEmptyStatusUpdate - FIFO is ","empty"}, $time));

        // Step 3: Verify `full_next` and `empty_next` signals
        if (full_next != 0) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FullAndEmptyStatusUpdate - Expected"," full_next to be 1, got %0b"}, $time, full_next));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ","test_FullAndEmptyStatusUpdate - ","full_next is correctly 1"}, $time));
        end

        if (empty_next != 1) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FullAndEmptyStatusUpdate - Expected"," empty_next to be 1, got %0b"}, $time, empty_next));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ","test_FullAndEmptyStatusUpdate - ","empty_next is correctly 1"}, $time));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_FullAndEmptyStatusUpdate"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_FullAndEmptyStatusUpdate"}, $time));
          err_count_arr[test_FullAndEmptyStatusUpdateIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PushBackpressureHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_PushBackpressureHandling"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_PushBackpressureHandling. Stimuli ","is not observed or it needs more time to"," finish this test."}, $time));
        err_count_arr[test_PushBackpressureHandlingIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the FIFO correctly handles backpressure on the push interface by managing data flow when it is full and cannot accept new data.

        // Local variables declaration
        int test_failed = 0;
        logic[Width-1:0] random_data;

        // Initial delay to ensure proper stimulus propagation
        @(posedge clk);

        // Step 1: Drive push_valid high and push_data with random values until FIFO is full
        while (!full) begin
          random_data = $urandom_range(0, (1 << Width) - 1);
          push_valid = 1'b1;
          push_data = random_data;
          @(posedge clk);
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - Driving ","push_valid=1, push_data=0x%h"}, $time, random_data));
        end

        // Step 2: Continue asserting push_valid and monitor push_ready for backpressure
        while (push_ready) begin
          @(posedge clk);
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - ","Monitoring push_ready for backpressure"}, $time));
        end

        // Step 3: Verify push_valid remains high and push_data remains stable during backpressure
        if (push_valid !== 1'b1 || push_data !== random_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_PushBackpressureHandling - Check ","failed. Expected push_valid=1, ","push_data=0x%h, got push_valid=%b, ","push_data=0x%h"}, $time, random_data, push_valid, push_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_PushBackpressureHandling - Check ","passed. push_valid and push_data are ","stable during backpressure."}, $time));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_PushBackpressureHandling"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_PushBackpressureHandling"}, $time));
          err_count_arr[test_PushBackpressureHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_RamReadLatencyVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_RamReadLatencyVerification"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_RamReadLatencyVerification. Stimuli"," is not observed or it needs more time ","to finish this test."}, $time));
        err_count_arr[test_RamReadLatencyVerificationIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the FIFO correctly handles RAM read latency and synchronizes data availability at the pop interface based on the `RamReadLatency` parameter, which is set to 0.

        // Local variables declaration
        int test_failed = 0;
        logic[Width-1:0] expected_data;
        logic[Width-1:0] observed_data;
        logic[Width-1:0] random_data;

        // Initial delay to ensure proper stimulus propagation
        @(posedge clk);

        // Generate random data for push_data
        random_data = $urandom();

        // Drive push_valid high with random data on push_data
        push_valid = 1'b1;
        push_data = random_data;
        $display($sformatf({"Time: %0t, INFO: ","test_RamReadLatencyVerification - ","Driving push_valid=1, push_data=0x%h"}, $time, push_data));

        // Wait for ram_rd_addr_valid to be driven high by the design
        @(posedge clk);
        while (!ram_wr_valid) begin
          @(posedge clk);
        end
        $display($sformatf({"Time: %0t, INFO: ","test_RamReadLatencyVerification - ","Detected ram_wr_valid=1"}, $time));

        // Assert pop_ready and wait for pop_valid to be driven high
        pop_ready = 1'b1;
        @(posedge clk);
        while (!pop_valid) begin
          @(posedge clk);
        end
        $display($sformatf({"Time: %0t, INFO: ","test_RamReadLatencyVerification - ","Detected pop_valid=1"}, $time));

        // Read pop_data and verify it matches push_data
        observed_data = pop_data;
        expected_data = random_data;
        if (observed_data !== expected_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_RamReadLatencyVerification - Check ","failed. Expected pop_data=0x%h, got 0x%h"}, $time, expected_data, observed_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_RamReadLatencyVerification - Check ","passed. Expected value for pop_data is ","the same as the observed value (both are"," 0x%h)."}, $time, observed_data));
        end

        // Reset signals
        push_valid = 1'b0;
        pop_ready = 1'b0;

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_RamReadLatencyVerification"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_RamReadLatencyVerification"}, $time));
          err_count_arr[test_RamReadLatencyVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
