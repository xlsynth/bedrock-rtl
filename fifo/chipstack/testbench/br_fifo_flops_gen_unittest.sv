
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

//=============================================================
// Testbench for Module: br_fifo_flops
//=============================================================
// Author: ChipStack AI
// Date: 2025-03-16 20:07:33
// Description: Unit test for br_fifo_flops
//=============================================================



module br_fifo_flops_gen_tb;
  timeunit 1ns;
  timeprecision 100ps;

  //===========================================================
  // Testbench Parameters
  //===========================================================
  parameter int CLOCK_FREQ = 100;     // Clock frequency in MHz
  parameter int RESET_DURATION = 100;    // Reset duration in ns
  parameter int TIMEOUT = 10000000;          // Timeout value in ns
  parameter int PER_TASK_TIMEOUT = 1000000; // Timeout value for each task in ns
  parameter int ENABLE_INFO_MESSAGES = 1;  // Enable info messages (to control verbosity)
  parameter int DRAIN_TIME = 10000;        // Time to observe all results in ns
  parameter int CLOCK_FREQ_NS_CONVERSION_FACTOR = 1000; // Conversion factor to nanoseconds
  parameter int NO_ASSERTS_ON_RESET = 1;  // Disable assertions during reset
  parameter int ENABLE_CHECKS = 1;  // Enable checks


  //===========================================================
  // DUT Parameters
  //===========================================================
  parameter int Depth = 2;
  parameter int Width = 1;
  parameter bit EnableBypass = 1;
  parameter bit RegisterPopOutputs = 0;
  parameter int FlopRamDepthTiles = 1;
  parameter int FlopRamWidthTiles = 1;
  parameter int FlopRamAddressDepthStages = 0;
  parameter int FlopRamReadDataDepthStages = 0;
  parameter int FlopRamReadDataWidthStages = 0;
  parameter bit EnableCoverPushBackpressure = 1;
  parameter bit EnableAssertPushValidStability = EnableCoverPushBackpressure;
  parameter bit EnableAssertPushDataStability = EnableAssertPushValidStability;
  parameter bit EnableAssertFinalNotValid = 1;
  localparam int CountWidth = $clog2((Depth + 1));

  //===========================================================
  // Clock and Reset Signals
  //===========================================================
  logic clk;
  logic rst;

  //===========================================================
  // Other Signals and Variables
  //===========================================================
  logic push_valid;
  logic[Width-1:0] push_data;
  logic pop_ready;
  logic push_ready;
  logic pop_valid;
  logic[Width-1:0] pop_data;
  logic full;
  logic full_next;
  logic[CountWidth-1:0] slots;
  logic[CountWidth-1:0] slots_next;
  logic empty;
  logic empty_next;
  logic[CountWidth-1:0] items;
  logic[CountWidth-1:0] items_next;

  //===========================================================
  // DUT Instantiation
  //===========================================================
// Clock to DUT is inverted to avoid race condition between DUT and TB
  br_fifo_flops
      #(
          .Depth(Depth),
          .Width(Width),
          .EnableBypass(EnableBypass),
          .RegisterPopOutputs(RegisterPopOutputs),
          .FlopRamDepthTiles(FlopRamDepthTiles),
          .FlopRamWidthTiles(FlopRamWidthTiles),
          .FlopRamAddressDepthStages(FlopRamAddressDepthStages),
          .FlopRamReadDataDepthStages(FlopRamReadDataDepthStages),
          .FlopRamReadDataWidthStages(FlopRamReadDataWidthStages),
          .EnableCoverPushBackpressure(EnableCoverPushBackpressure),
          .EnableAssertPushValidStability(EnableAssertPushValidStability),
          .EnableAssertPushDataStability(EnableAssertPushDataStability),
          .EnableAssertFinalNotValid(EnableAssertFinalNotValid)
      )  dut (
          .clk(~clk),
          .rst(rst),
          .push_valid(push_valid),
          .push_data(push_data),
          .pop_ready(pop_ready),
          .push_ready(push_ready),
          .pop_valid(pop_valid),
          .pop_data(pop_data),
          .full(full),
          .full_next(full_next),
          .slots(slots),
          .slots_next(slots_next),
          .empty(empty),
          .empty_next(empty_next),
          .items(items),
          .items_next(items_next)
      );


  //===========================================================
  // Clock Generation
  //===========================================================
  initial begin
    clk = 1'b0;
    forever #(CLOCK_FREQ_NS_CONVERSION_FACTOR/(2*CLOCK_FREQ)) clk = ~clk;
  end


  //===========================================================
  // Reset Generation
  //===========================================================
  task automatic reset_dut;
    if (NO_ASSERTS_ON_RESET) $assertoff;
    // Set all the DUT inputs to zero, making sure there are no X/Z at the inputs.
    push_valid <= 'h0;
    push_data <= 'h0;
    pop_ready <= 'h0;

    // Wiggling the reset signal.
    rst = 1'bx;
    #RESET_DURATION;
    rst = 1'b1;
    #RESET_DURATION;
    rst = 1'b0;
    #RESET_DURATION;
    if (NO_ASSERTS_ON_RESET) $asserton;
  endtask


  //===========================================================
  // Helper testbench variables
  //===========================================================
  typedef enum {
    test_BasicPushPopFunctionalityIdx,
    test_BypassModeVerificationIdx,
    test_FullConditionHandlingIdx,
    test_PushDataStabilityUnderBackpressureIdx,
    test_FinalStateAssertionIdx,
    TotalTestsIdx
  } test_names_e;
  int err_count_arr[TotalTestsIdx] = '{default: '0};

  `ifdef WAVES_AS_FSDB
     bit enable_fsdb;
  `endif
  //===========================================================
  // Timeout Control
  //===========================================================
  initial begin
      if (NO_ASSERTS_ON_RESET) $assertoff;
      #(TIMEOUT);
      $display("Error: Testbench timeout!");
      $finish;
  end

  `ifdef WAVES_AS_FSDB
    initial begin
      // Enable FSDB dump for TB and DUT
      if ($value$plusargs("ENABLE_FSDB_DUMP=%0d", enable_fsdb)) begin
        $fsdbDumpfile("tb.fsdb");
        $fsdbDumpvars(0, br_fifo_flops_gen_tb, "+all");
      end
    end
  `endif


  //===========================================================
  // Initial Block to Call Tasks
  //===========================================================
  initial begin
    reset_dut();
    test_BasicPushPopFunctionality();

    reset_dut();
    test_BypassModeVerification();

    reset_dut();
    test_FullConditionHandling();

    reset_dut();
    test_PushDataStabilityUnderBackpressure();

    reset_dut();
    test_FinalStateAssertion();

    if (err_count_arr[test_BasicPushPopFunctionalityIdx] == 0) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ","PASSED"}));
    end else if (err_count_arr[test_BasicPushPopFunctionalityIdx] == -1) begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ","TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BasicPushPopFunctionality ","FAILED"}));
    end

    if (err_count_arr[test_BypassModeVerificationIdx] == 0) begin
      $display($sformatf({"Test test_BypassModeVerification PASSED"}));
    end else if (err_count_arr[test_BypassModeVerificationIdx] == -1) begin
      $display($sformatf({"Test test_BypassModeVerification TIMEOUT"}));
    end else begin
      $display($sformatf({"Test test_BypassModeVerification FAILED"}));
    end

    if (err_count_arr[test_FullConditionHandlingIdx] == 0) begin
      $display("Test test_FullConditionHandling PASSED");
    end else if (err_count_arr[test_FullConditionHandlingIdx] == -1) begin
      $display($sformatf({"Test test_FullConditionHandling TIMEOUT"}));
    end else begin
      $display("Test test_FullConditionHandling FAILED");
    end

    if (err_count_arr[test_PushDataStabilityUnderBackpressureIdx] == 0) begin
      $display($sformatf({"Test ","test_PushDataStabilityUnderBackpressure ","PASSED"}));
    end else if (err_count_arr[test_PushDataStabilityUnderBackpressureIdx] == -1) begin
      $display($sformatf({"Test ","test_PushDataStabilityUnderBackpressure ","TIMEOUT"}));
    end else begin
      $display($sformatf({"Test ","test_PushDataStabilityUnderBackpressure ","FAILED"}));
    end

    if (err_count_arr[test_FinalStateAssertionIdx] == 0) begin
      $display("Test test_FinalStateAssertion PASSED");
    end else if (err_count_arr[test_FinalStateAssertionIdx] == -1) begin
      $display("Test test_FinalStateAssertion TIMEOUT");
    end else begin
      $display("Test test_FinalStateAssertion FAILED");
    end


    if ( err_count_arr.or() !== 0) begin
      $display("TEST FAILED");
      $finish(1);
    end else begin
      $display("TEST PASSED");
      $finish(0);
    end
  end


  task automatic test_BasicPushPopFunctionality;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_BasicPushPopFunctionality"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_BasicPushPopFunctionality. Stimuli ","is not observed or it needs more time to"," finish this test."}, $time));
        err_count_arr[test_BasicPushPopFunctionalityIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task tests the basic push and pop functionality of the FIFO, ensuring it adheres to the ready-valid handshake protocol and updates status flags accurately.

        // Local variables declaration
        int test_failed = 0;
        int data_sequence[Depth];
        int data_index;
        int pushed_data;
        int popped_data;
        int error_count = 0;

        // Initialize the data sequence with random values
        for (int i = 0; i < Depth; i++) begin
          data_sequence[i] = $urandom_range(0, (1 << Width) - 1);
        end

        // Wait for a positive edge of the clock to ensure proper stimulus propagation
        @(posedge clk);


        // Check initial conditions
        if (full !== 1'b0 || empty !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - Initial"," condition check failed. Expected ","full=0, empty=1, got full=%b, empty=%b"}, $time, full, empty));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - Initial"," condition check passed. full=0, empty=1"}, $time));
        end

        // Step 2: Push data into the FIFO
        for (data_index = 0; data_index < Depth; data_index++) begin
          push_valid = 1'b1;
          push_data = data_sequence[data_index];

          if (push_ready !== 1'b1) begin
            $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - Push ","ready check failed. Expected ","push_ready=1, got push_ready=%b"}, $time, push_ready));
            test_failed = 1;
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - Push ","ready check passed. push_ready=1"}, $time));
          end
           @(posedge clk);
        end

        // Deassert push_valid after pushing all data
        push_valid = 1'b0;
        @(posedge clk);

        // Check if FIFO is full
        if (full !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - FIFO ","full check failed. Expected full=1, got ","full=%b"}, $time, full));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - FIFO ","full check passed. full=1"}, $time));
        end

        // Step 3: Pop data from the FIFO
        pop_ready = 1'b1;
        for (data_index = 0; data_index < Depth; data_index++) begin

          if (pop_valid !== 1'b1) begin
            $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - Pop ","valid check failed. Expected ","pop_valid=1, got pop_valid=%b"}, $time, pop_valid));
            test_failed = 1;
          end else begin
            popped_data = pop_data;
            if (popped_data !== data_sequence[data_index]) begin
              $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - Data ","mismatch. Expected pop_data=0x%h, got ","pop_data=0x%h"}, $time, data_sequence[data_index], popped_data));
              test_failed = 1;
            end else begin
              if (ENABLE_INFO_MESSAGES == 1)
                $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - Data ","match. pop_data=0x%h"}, $time, popped_data));
            end
          end
          @(posedge clk);
        end

        // Deassert pop_ready after popping all data
        pop_ready = 1'b0;
        @(posedge clk);

        // Check if FIFO is empty
        if (empty !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - FIFO ","empty check failed. Expected empty=1, ","got empty=%b"}, $time, empty));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - FIFO ","empty check passed. empty=1"}, $time));
        end

        // Final check for no valid bits asserted
        if (pop_valid !== 1'b0) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BasicPushPopFunctionality - Final ","valid bit check failed. Expected ","pop_valid=0, got pop_valid=%b"}, $time, pop_valid));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BasicPushPopFunctionality - Final ","valid bit check passed. pop_valid=0"}, $time));
        end

        // Report test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_BasicPushPopFunctionality"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_BasicPushPopFunctionality"}, $time));
          error_count += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_BypassModeVerification;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_BypassModeVerification"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_BypassModeVerification. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_BypassModeVerificationIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the bypass mode allows data to be transferred directly from the push interface to the pop interface with zero-cycle latency when the FIFO is empty and bypass is enabled.

        // Local variables declaration
        int test_failed = 0;
        logic[Width-1:0] random_data;

        // Wait for a clock edge to ensure proper stimulus propagation
        @(posedge clk);

        // Step 1: Drive push_valid high with random data on push_data and wait for empty signal
        random_data = $urandom_range(0, (1 << Width) - 1);
        push_valid = 1'b1;
        push_data = random_data;
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - Driving ","push_valid=1, push_data=0x%h"}, $time, random_data));

        #1; // Allow for 0-cycle combinational delay from TB to DUT to TB

        // Step 2: Verify that pop_valid == 1 and pop_data matches push_data
        if (pop_valid !== 1'b1) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BypassModeVerification - Check ","failed. Expected pop_valid=1, got pop_valid=%b"}, $time, pop_valid));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - Check ","passed. Expected value for pop_valid is ","the same as the observed value (both are"," 0x%h)."}, $time, pop_valid));
        end

        if (pop_data !== random_data) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_BypassModeVerification - Check ","failed. Expected pop_data=0x%h, got 0x%h"}, $time, random_data, pop_data));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_BypassModeVerification - Check ","passed. Expected value for pop_data is ","the same as the observed value (both are"," 0x%h)."}, $time, pop_data));
        end

        // Reset the signals
        push_valid = 1'b0;
        pop_ready = 1'b0;

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_BypassModeVerification"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_BypassModeVerification"}, $time));
          err_count_arr[test_BypassModeVerificationIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_FullConditionHandling;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_FullConditionHandling"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_FullConditionHandling. Stimuli is ","not observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_FullConditionHandlingIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies the FIFO's handling of full conditions and backpressure, ensuring no additional data is accepted until space is available.

        // Local variables declaration
        int test_failed = 0;
        int data;
        int cycle_count = 0;
        localparam int MAX_CYCLES = 1000; // Maximum cycles to prevent infinite loops

        // Step 1: Drive `push_valid` high and provide data until `full` is asserted
        while (!full && cycle_count < MAX_CYCLES) begin
          data = $urandom_range(0, (1 << Width) - 1);
          push_valid = 1'b1;
          push_data = data;
          @(posedge clk);
          cycle_count++;
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_FullConditionHandling - Driving ","push_valid=1, push_data=0x%h"}, $time, data));
        end

        // Check if `full` is asserted
        if (!full) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FullConditionHandling - FIFO did ","not become full as expected."}, $time));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ","test_FullConditionHandling - FIFO is ","full as expected."}, $time));
        end

        // Step 2: Continue driving `push_valid` high and monitor `push_ready` for backpressure
        cycle_count = 0;
        while (push_ready && cycle_count < MAX_CYCLES) begin
          @(posedge clk);
          cycle_count++;
        end

        // Check if `push_ready` is de-asserted
        if (push_ready) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FullConditionHandling - push_ready ","was not de-asserted as expected."}, $time));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ","test_FullConditionHandling - push_ready ","is de-asserted due to backpressure."}, $time));
        end

        // Step 3: Assert `pop_ready` high to initiate a pop operation
        pop_ready = 1'b1;
        @(posedge clk);

        // Wait for `full` to be de-asserted
        cycle_count = 0;
        while (full && cycle_count < MAX_CYCLES) begin
          @(posedge clk);
          cycle_count++;
        end

        // Check if `full` is de-asserted
        if (full) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FullConditionHandling - full was ","not de-asserted after pop operation."}, $time));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ","test_FullConditionHandling - full is ","de-asserted, space is available in FIFO."}, $time));
        end

        // Step 4: Verify `push_ready` is driven high after `full` is de-asserted
        @(posedge clk);
        if (!push_ready) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FullConditionHandling - push_ready ","was not asserted after space became ","available."}, $time));
          test_failed = 1;
        end else if (ENABLE_INFO_MESSAGES == 1) begin
          $display($sformatf({"Time: %0t, INFO: ","test_FullConditionHandling - push_ready ","is asserted, FIFO can accept new data."}, $time));
        end

        // Reset `pop_ready` to low
        pop_ready = 1'b0;

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_FullConditionHandling"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_FullConditionHandling"}, $time));
          err_count_arr[test_FullConditionHandlingIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_PushDataStabilityUnderBackpressure;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_PushDataStabilityUnderBackpressure"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_PushDataStabilityUnderBackpressure."," Stimuli is not observed or it needs ","more time to finish this test."}, $time));
        err_count_arr[test_PushDataStabilityUnderBackpressureIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task verifies that the `push_data` signal remains stable during backpressure conditions.

        // Local variables declaration
        int test_failed = 0;
        logic[Width-1:0] constant_push_data;
        logic[Width-1:0] observed_push_data;
        int backpressure_cycles = 0;

        // Initialize constant push data
        constant_push_data = $urandom_range(0, (1 << Width) - 1);

        // Drive push_valid high and constant value on push_data
        push_valid = 1'b1;
        push_data = constant_push_data;
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_PushDataStabilityUnderBackpressure ","- Driving push_valid=1, push_data=0x%h"}, $time, constant_push_data));

        // Wait for FIFO to become full
        while (!full) begin
          @(posedge clk);
        end

        // Wait for push_ready to go low indicating backpressure
        while (push_ready) begin
          @(posedge clk);
        end

        // Monitor push_data stability during backpressure
        while (!push_ready) begin
          observed_push_data = push_data;
          if (observed_push_data !== constant_push_data) begin
            $display($sformatf({"Time: %0t, ERROR: ","test_PushDataStabilityUnderBackpressure ","- push_data changed during backpressure."," Expected 0x%h, got 0x%h"}, $time, constant_push_data, observed_push_data));
            test_failed = 1;
          end else begin
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_PushDataStabilityUnderBackpressure ","- push_data remains stable at 0x%h ","during backpressure"}, $time, observed_push_data));
          end
          backpressure_cycles++;
          pop_ready = 1'b1;
          @(posedge clk);
        end

        // Check if backpressure was observed
        if (backpressure_cycles == 0) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_PushDataStabilityUnderBackpressure ","- No backpressure observed"}, $time));
          test_failed = 1;
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_PushDataStabilityUnderBackpressure"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_PushDataStabilityUnderBackpressure"}, $time));
          err_count_arr[test_PushDataStabilityUnderBackpressureIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask


  task automatic test_FinalStateAssertion;
    fork
      begin
        #(PER_TASK_TIMEOUT);
        $display($sformatf({"Time: %0t, FAILED: ","test_FinalStateAssertion"}, $time));
        $display($sformatf({"Time: %0t, INFO: Timeout: ","test_FinalStateAssertion. Stimuli is not"," observed or it needs more time to ","finish this test."}, $time));
        err_count_arr[test_FinalStateAssertionIdx] = -1; // For timeout, set the error count to -1
      end
      begin
        // This task checks that the FIFO is empty and no valid bits are asserted at the end of the test, ensuring all data has been processed correctly.

        // Local variables declaration
        int test_failed = 0;
        int data_to_push;
        int push_count = 0;
        int pop_count = 0;
        localparam int MAX_PUSHES = Depth;

        @(posedge clk);

        // Push data into the FIFO until it is full
        for (int i = 0; i < MAX_PUSHES; i++) begin
          data_to_push = $urandom_range(0, (1 << Width) - 1);
          push_valid = 1;
          push_data = data_to_push;
          @(posedge clk);
          if (push_ready) begin
            push_count++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_FinalStateAssertion - Pushed data: ","0x%h"}, $time, data_to_push));
          end
        end

        // Deassert push_valid after the last push
        push_valid = 0;
        @(posedge clk);
        if (ENABLE_INFO_MESSAGES == 1)
          $display($sformatf({"Time: %0t, INFO: ","test_FinalStateAssertion - push_valid ","deasserted"}, $time));

        // Assert pop_ready and pop data until FIFO is empty
        pop_ready = 1;
        while (items > 0) begin
          @(posedge clk);
          if (pop_valid && pop_ready) begin
            pop_count++;
            if (ENABLE_INFO_MESSAGES == 1)
              $display($sformatf({"Time: %0t, INFO: ","test_FinalStateAssertion - Popped data: ","0x%h"}, $time, pop_data));
          end
        end

        // Check if FIFO is empty
        @(posedge clk);
        if (empty !== 1) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FinalStateAssertion - FIFO not ","empty. Expected empty=1, got empty=%b"}, $time, empty));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_FinalStateAssertion - FIFO is empty"," as expected."}, $time));
        end

        // Check if FIFO is not full
        if (full !== 0) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FinalStateAssertion - FIFO is full."," Expected full=0, got full=%b"}, $time, full));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_FinalStateAssertion - FIFO is not ","full as expected."}, $time));
        end

        // Check if items count is zero
        if (items !== 0) begin
          $display($sformatf({"Time: %0t, ERROR: ","test_FinalStateAssertion - Items count ","not zero. Expected items=0, got ","items=%0d"}, $time, items));
          test_failed = 1;
        end else begin
          if (ENABLE_INFO_MESSAGES == 1)
            $display($sformatf({"Time: %0t, INFO: ","test_FinalStateAssertion - Items count ","is zero as expected."}, $time));
        end

        // Final test status
        if (test_failed == 0) begin
          $display($sformatf({"Time: %0t, PASSED: ","test_FinalStateAssertion"}, $time));
        end else begin
          $display($sformatf({"Time: %0t, FAILED: ","test_FinalStateAssertion"}, $time));
          err_count_arr[test_FinalStateAssertionIdx] += 1;
        end
      end
    join_any
    disable fork;
  endtask

endmodule
