## Simulation Unit Test Scenarios
### File: ./fifo/rtl/br_fifo_shared_dynamic_ctrl.sv

|Name|Description|
|---|---|
|BasicPushAndPop|Check that the FIFO correctly handles push and pop operations, maintaining data integrity and proper operation.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` low to release the reset and start normal operation. The testbench monitors the transition to normal operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid[0]` high for the first write port, provides a valid `push_data` value within the range defined by `Width`, and specifies a `push_fifo_id`. The testbench monitors the `push_valid` and `push_data` signals.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `push_ready` and waits for the design to drive it high, indicating readiness to accept data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `pop_ready` high for the corresponding FIFO ID to initiate a pop operation. The testbench monitors the `pop_ready` signal.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_valid` and waits for the design to drive it high, indicating valid data is available.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_data` and waits for the design to drive it with the expected data value, verifying data integrity.  <br><br>|
|PushBackpressureHandling|Check that the FIFO correctly handles backpressure conditions and maintains data integrity when full.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state of the DUT.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `rst` low to release the reset and start normal operation. The testbench monitors the transition to normal operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench continuously asserts `push_valid` high for all write ports, driving valid `push_data` and `push_fifo_id` values generated by the `random_push` task. The testbench monitors these values to ensure they are correctly driven.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `push_ready` and waits for the design to drive it low, indicating backpressure is applied due to the FIFO being full. The testbench ensures that `push_ready` transitions to low eventually.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench ensures that `push_valid` remains stable as per the `EnableAssertPushValidStability` parameter, verifying that data integrity is maintained under backpressure. The testbench monitors the stability of `push_valid`.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` high for one FIFO to create space and monitors `push_ready` to wait for the design to drive it high again, indicating the FIFO can accept new data. The testbench ensures that `push_ready` transitions to high eventually.  <br><br>|
|ConcurrentPushAndPop|Check that the FIFO correctly handles concurrent push and pop operations across multiple ports, ensuring data integrity and correct functionality.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `rst` low to release the reset and start normal operation. The testbench monitors the transition to normal operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `push_valid` high for multiple write ports, driving valid `push_data` and `push_fifo_id` values for each port. The testbench monitors the `push_data` and `push_fifo_id` values being driven.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive `push_ready` high for each port, indicating readiness to accept data. The testbench monitors `push_ready` for each port.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` high for multiple FIFOs to initiate concurrent pop operations. The testbench monitors the `pop_ready` signals being driven.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive `pop_valid` high for each FIFO, indicating valid data is available. The testbench monitors `pop_valid` for each FIFO.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive `pop_data` with the expected data values for each FIFO, verifying data integrity. The testbench compares `pop_data` against expected values stored in a scoreboard or expected data variable.  <br><br>|
|DynamicFifoAllocation|Check that the FIFO's dynamic allocation capability allows data to be pushed to and popped from different logical FIFOs without fixed allocation.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` low and waits for 20 nanoseconds before starting normal operation. The testbench monitors the reset release timing.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` high for a specific write port, provides valid `push_data`, and specifies a `push_fifo_id` for one FIFO. The testbench monitors the design's response.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `push_ready` and waits for the design to drive it high, indicating readiness to accept data for the specified write port.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench changes `push_fifo_id` to a different FIFO and repeats the push operation, verifying dynamic allocation. The testbench monitors `push_ready` for the new FIFO.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `pop_ready` high for the first FIFO and monitors `pop_valid` to wait for the design to drive it high, indicating valid data is available.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_data` and waits for the design to drive it with the expected `push_data` value, verifying data integrity.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench repeats the pop operation for the second FIFO, verifying correct data retrieval from dynamically allocated FIFOs. The testbench monitors `pop_valid` and `pop_data` for the second FIFO.  <br><br>|
|PointerRamReadWrite|Check that the pointer RAM read and write processes operate correctly, ensuring accurate management of FIFO pointers.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state of the DUT.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` low and waits for `<h1>RESET_DURATION` to ensure the DUT is properly initialized and ready for normal operation. The testbench monitors the DUT's readiness for normal operation.</h1><br>&nbsp;&nbsp;&nbsp; - The testbench invokes the `random_push` task with a specific `wport`, driving `push_valid[wport]` high, provides valid `push_data`, and specifies a `push_fifo_id`. The testbench monitors the design's response to the push operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `ptr_ram_wr_valid` and waits for the design to drive it high, indicating a pointer RAM write operation is initiated. The testbench ensures that the design initiates the write operation correctly.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `ptr_ram_wr_addr` and `ptr_ram_wr_data` to wait for the design to drive them with the expected address and data values, verifying correct pointer updates. The testbench checks that the address and data values are as expected based on the FIFO's internal logic.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench ensures the downstream logic is ready and drives `pop_ready` high for the corresponding FIFO to initiate a pop operation. The testbench monitors the FIFO's readiness for data transfer.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `ptr_ram_rd_addr_valid` and waits for the design to drive it high, indicating a pointer RAM read operation is initiated. The testbench verifies that the read operation is correctly initiated.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `ptr_ram_rd_data_valid` and waits for the design to drive it high, indicating valid pointer data is available. The testbench checks that the data is valid and ready for use.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `ptr_ram_rd_data` to wait for the design to drive it with the expected pointer data, verifying correct pointer retrieval. The testbench ensures that the retrieved data matches the expected linked list structure.  <br><br>|
