## Simulation Unit Test Scenarios
### File: ./fifo/rtl/br_fifo_shared_dynamic_flops.sv

|Name|Description|
|---|---|
|BasicPushAndPop|Check that the FIFO correctly handles data push and pop operations, maintaining data integrity and proper functionality under normal conditions.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` low to release the reset, allowing the DUT to begin normal operation. The testbench monitors the transition to normal operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` with `1'b1`, `push_data` with `8'hA5`, and `push_fifo_id` with `2'b00` to target the first logical FIFO for data push. The testbench monitors these signals to ensure they are correctly driven.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `push_ready` and waits for the design to drive it high, indicating the FIFO is ready to accept data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `pop_ready` with `1'b1` for the FIFO ID `2'b00` to indicate readiness to pop data from the first logical FIFO. The testbench monitors this signal to ensure it is correctly driven.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_valid` and waits for the design to drive it high, indicating valid data is available to be popped.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_data` and waits for the design to drive it with the expected value `8'hA5`, verifying data integrity.  <br><br>|
|PushWithBackpressure|Check that the FIFO correctly handles backpressure during push operations, ensuring data integrity and proper management of push requests when the FIFO is full.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `rst` to an unknown state (`1'bx`), then high (`1'b1`) for `RESET_DURATION` cycles to reset the DUT, ensuring all internal states are initialized.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `rst` to low (`1'b0`) for `RESET_DURATION` cycles, allowing the DUT to begin normal operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench continuously drives `push_valid` with `1'b1`, `push_data` with a sequence of known values, and `push_fifo_id` with valid FIFO IDs (`0`, `1`, `2`, `3`) for all write ports.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `push_ready` and waits for the design to drive it low, indicating backpressure due to the FIFO being full.  <br><br>&nbsp;&nbsp;&nbsp; - During backpressure, the testbench holds `push_valid`, `push_data`, and `push_fifo_id` signals stable, ensuring data stability.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive `push_ready` high again, indicating the FIFO is ready to accept more data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench resumes driving `push_valid`, `push_data`, and `push_fifo_id` to push data into the FIFO, verifying that no data was lost during backpressure.  <br><br>|
|ConcurrentPushAndPop|Check that the FIFO can handle concurrent push and pop operations across multiple logical FIFOs while maintaining data integrity and order.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `rst` low to release the reset, allowing the DUT to begin normal operation. The testbench monitors the transition to normal operation.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` with `1'b1` for each bit in `logic[NumWritePorts-1:0]`, `push_data` with known values calculated as `(data << WritePortIdWidth) | wport` for each entry in `logic[NumWritePorts-1:0][Width-1:0]`, and `push_fifo_id` with valid FIFO IDs generated by `fifo_id = $urandom_range(0, NumFifos - 1)` for each entry in `logic[NumWritePorts-1:0][FifoIdWidth-1:0]`. The testbench monitors these signals.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `push_ready` and waits for the design to drive it high for each write port in the same cycle, indicating readiness to accept data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `pop_ready` with `1'b1` for each logical FIFO, indicating readiness to pop data. The testbench monitors this signal.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_valid` and waits for the design to drive it high for each logical FIFO in the same cycle, indicating valid data is available to be popped.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_data` and waits for the design to drive it with the expected values for each logical FIFO, verifying data integrity and order. The expected values are based on the known `push_data` values and the FIFO order.  <br><br>|
|BoundaryConditionPush|Check that the FIFO correctly handles boundary conditions without data loss or corruption when pushed to its maximum capacity.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state to confirm initialization.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `rst` low to release the reset, allowing the DUT to begin normal operation. The testbench monitors the transition to confirm normal operation commencement.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench continuously drives `push_valid` with `1'b1` for all write ports, `push_data` with a sequence of known values, and `push_fifo_id` with valid FIFO IDs (e.g., `00` to `11` for `NumFifos` = 4) until the FIFO reaches its maximum capacity. The testbench monitors the sequence to ensure correct data and ID are driven.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench waits for the design to drive `push_ready` low, indicating the FIFO is full and cannot accept more data. The testbench monitors `push_ready` to confirm this condition.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench verifies that no data is lost or corrupted by using the `br_fifo_shared_dynamic_basic_fpv_monitor` module to compare `pop_data` with the expected data sequence stored in the scoreboard. The testbench waits for the design to eventually drive the correct sequence on `pop_data` and logs any mismatches to ensure data integrity.  <br><br>|
|PopWithStagingBuffer|Check that the FIFO's pop operation correctly stages and retrieves data with the expected latency when using a staging buffer.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` high to reset the DUT, ensuring all internal states are initialized. The testbench monitors the reset state to confirm initialization.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `rst` low to release the reset, allowing the DUT to begin normal operation. The testbench monitors the reset state to confirm normal operation commencement.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid[0]` with `1'b1`, `push_data[0]` with `constant_push_data`, and `push_fifo_id[0]` with a valid FIFO ID to preload the FIFO with data. The testbench monitors these signals to ensure correct data loading.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench drives `pop_ready` with `1'b1` for the corresponding FIFO ID to indicate readiness to pop data. The testbench monitors `pop_ready` to confirm readiness indication.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_valid` and waits for the design to drive it high, indicating valid data is available to be popped.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench monitors `pop_data` and waits for the design to drive it with `constant_push_data`, verifying data integrity.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench verifies that the latency introduced by the staging buffer matches the expected value calculated using the formula: Latency = StagingBufferDepth / (PointerRamAddressDepthStages + PointerRamReadDataDepthStages + PointerRamReadDataWidthStages + 1). If `RegisterPopOutputs` is set to 1, an additional cycle of latency is expected.  <br><br>|
