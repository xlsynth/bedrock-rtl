## Simulation Unit Test Scenarios
### File: ./fifo/rtl/br_fifo_ctrl_1r1w.sv

|Name|Description|
|---|---|
|BasicPushPopFunctionality|Check that the FIFO correctly handles data flow by pushing data until it is full and then popping data until it is empty, updating status flags accordingly.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `push_valid` high and drives random data on `push_data` using `$urandom()`. It monitors `push_ready` and waits for the design to drive it high, indicating readiness to accept data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench continues to assert `push_valid` and drive random data on `push_data` until the design drives `full` high, indicating the FIFO is full.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `push_valid` and asserts `pop_ready` high to indicate readiness to receive data. It monitors `pop_valid` and waits for the design to drive it high, indicating valid data is available.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench reads `pop_data` when `pop_valid` is high and continues to assert `pop_ready` until the design drives `empty` high, indicating the FIFO is empty.  <br><br>|
|BypassModeVerification|Check that when the FIFO is configured with `EnableBypass` set to 1, data is transferred with minimal latency when the FIFO is empty and bypass conditions are met.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench sets `EnableBypass` to 1 and asserts `push_valid` with data on `push_data`. The testbench monitors `bypass_ready` and waits for the design to drive it high, indicating readiness to accept bypass data.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` and monitors `pop_valid`, waiting for the design to drive it high, indicating valid data is available.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench reads `pop_data` when `pop_valid` is high and verifies that the data matches `push_data`, confirming zero-cycle latency.  <br><br>|
|FullAndEmptyStatusUpdate|Check that the FIFO accurately updates its full and empty status flags based on push and pop operations, reflecting its occupancy state.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench drives `push_valid` high and provides data on `push_data` with a value within the range determined by the `Width` parameter. The testbench monitors `full` and waits for the design to drive `full` high, indicating the FIFO is full.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench deasserts `push_valid` and asserts `pop_ready`. If `EnableBypass` is enabled, the testbench waits for the design to drive `empty` high in the same cycle. Otherwise, the testbench waits for the design to drive `empty` high after a delay corresponding to the `RamReadLatency` parameter.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench verifies that `full_next` is driven high by the design before a push operation if the FIFO will become full, and `empty_next` is driven high by the design before a pop operation if the FIFO will become empty. The testbench monitors these signals to ensure they are correctly updated based on the current operations.  <br><br>|
|PushBackpressureHandling|Check that the FIFO correctly handles backpressure on the push interface by managing data flow when it is full and cannot accept new data.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `push_valid` high and drives data on `push_data` with a width equal to the `Width` parameter until the design asserts `full` high, indicating the FIFO is full.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench continues to assert `push_valid` and monitors `push_ready`, waiting for the design to assert `push_ready` low, indicating backpressure.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench verifies that `push_valid` remains high and `push_data` remains stable during backpressure conditions, ensuring data integrity.  <br><br>|
|RamReadLatencyVerification|Check that the FIFO correctly handles RAM read latency and synchronizes data availability at the pop interface based on the `RamReadLatency` parameter, which is set to 0.  <br><br> <h3>Steps</h3><br>&nbsp;&nbsp;&nbsp; - The testbench sets `RamReadLatency` to 0 and drives `push_valid` high with data on `push_data`. It monitors `ram_rd_addr_valid` and waits for the design to drive it high, indicating a read request.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench asserts `pop_ready` and monitors `pop_valid`, waiting for the design to drive it high immediately, as `RamReadLatency` is 0.  <br><br>&nbsp;&nbsp;&nbsp; - The testbench reads `pop_data` when `pop_valid` is high and verifies that the data matches `push_data`, confirming correct latency handling.  <br><br>|
