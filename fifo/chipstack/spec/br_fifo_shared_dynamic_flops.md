## Design Mental Model

### File: ./fifo/rtl/br_fifo_shared_dynamic_flops.sv

### SUMMARY

#### Module Instantiation Hierarchy:

- br_fifo_shared_dynamic_flops
  - br_fifo_shared_dynamic_ctrl
    - br_fifo_shared_dynamic_ptr_mgr
      - br_delay_valid
      - br_demux_bin
      - br_mux_onehot
      - br_tracker_linked_list_ctrl
        - br_counter
          - br_misc_unused
        - br_enc_countones
        - br_enc_priority_encoder
          - br_misc_unused
        - br_flow_checks_valid_data_impl
          - br_misc_unused
        - br_mux_onehot
    - br_fifo_shared_dynamic_push_ctrl
      - br_demux_bin
      - br_multi_xfer_distributor_rr
        - br_arb_multi_rr
          - br_enc_countones
          - br_enc_priority_dynamic
            - br_enc_priority_encoder
              - br_misc_unused
          - br_mux_bin
        - br_multi_xfer_distributor_core
          - br_flow_checks_valid_data_impl
            - br_misc_unused
          - br_misc_tieoff_one
          - br_multi_xfer_checks_sendable_data_intg
            - br_misc_unused
          - br_mux_onehot
      - br_tracker_freelist
        - br_delay
        - br_enc_bin2onehot
        - br_enc_countones
        - br_enc_onehot2bin
        - br_enc_priority_encoder
          - br_misc_unused
        - br_multi_xfer_reg_fwd
          - br_multi_xfer_checks_sendable_data_impl
            - br_misc_unused
          - br_multi_xfer_checks_sendable_data_intg
            - br_misc_unused
          - br_shift_left
          - br_shift_right
    - br_fifo_shared_pop_ctrl
      - br_fifo_shared_read_xbar
        - br_delay_valid
        - br_demux_bin
        - br_flow_demux_select_unstable
          - br_flow_checks_valid_data_impl
            - br_misc_unused
          - br_flow_checks_valid_data_intg
            - br_misc_unused
        - br_flow_mux_lru
          - br_arb_lru_internal
            - br_misc_unused
          - br_flow_mux_core
            - br_flow_arb_core
              - br_flow_checks_valid_data_impl
                - br_misc_unused
              - br_flow_checks_valid_data_intg
                - br_misc_unused
              - br_misc_unused
            - br_flow_checks_valid_data_impl
              - br_misc_unused
            - br_flow_checks_valid_data_intg
              - br_misc_unused
            - br_mux_onehot
        - br_misc_unused
        - br_mux_onehot
      - br_flow_checks_valid_data_impl
        - br_misc_unused
      - br_flow_join
        - br_flow_checks_valid_data_impl
          - br_misc_unused
        - br_flow_checks_valid_data_intg
          - br_misc_unused
      - br_misc_unused
  - br_ram_flops
    - br_misc_unused
    - br_ram_addr_decoder
      - br_delay_valid
      - br_misc_tieoff_zero
      - br_misc_unused
    - br_ram_data_rd_pipe
      - br_delay_valid
    - br_ram_flops_tile
      - br_enc_bin2onehot
      - br_misc_unused
      - br_mux_onehot

#### Module Summary Table:

| Module                                   | Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| br_fifo_shared_dynamic_flops (Top Level) | The "br_fifo_shared_dynamic_flops" module is designed to implement a shared storage multi-FIFO system with dynamic allocation using flop-based RAM. Its primary functionality includes managing multiple logical FIFOs with dynamic space allocation, supporting multiple write and read ports, and optimizing data flow through a valid/ready interface, thereby enhancing resource utilization and data management in complex FIFO configurations.                                                                                      |
| br_tracker_linked_list_ctrl              | The "br_tracker_linked_list_ctrl" module is designed to manage the head and tail pointers of a linked list stored in external RAM. Its primary functionality includes handling multiple write ports to update tail pointers, supporting a variable number of sub-linked lists, and cycling through these lists in a round-robin fashion to form a single logical linked list. This approach enhances bandwidth on the head interface, especially when there is latency in the pointer RAM.                                                |
| br_fifo_shared_dynamic_ptr_mgr           | The "br_fifo_shared_dynamic_ptr_mgr" module is designed to manage multiple FIFO (First-In-First-Out) queues with shared dynamic pointers, allowing for efficient handling of read and write operations across multiple ports. Its primary functionality includes coordinating the head and tail pointers for each FIFO, ensuring no conflicts occur during simultaneous read operations, and integrating with linked list controllers to manage the pointers dynamically, thereby optimizing the use of external RAM for FIFO operations. |
| br_ram_data_rd_pipe                      | The "br_ram_data_rd_pipe" module is designed to manage the read data pipeline for a RAM system, ensuring efficient data handling and processing. Its primary functionality is to concatenate and multiplex tile data across specified width and depth dimensions, with configurable pipeline stages for both dimensions, while maintaining data validity and integrity through various checks and assertions.                                                                                                                             |
| br_fifo_shared_pop_ctrl                  | The "br_fifo_shared_pop_ctrl" module is designed to manage the pop control logic for multiple FIFOs (First-In, First-Out queues) that share read ports. Its primary functionality is to coordinate the reading and deallocation of data from these FIFOs, ensuring that data is correctly retrieved and managed according to the specified parameters, such as read latency and buffer depth. The module supports configurations for staging buffers and registered outputs to optimize data flow and resource utilization.               |
| br_fifo_shared_dynamic_push_ctrl         | The "br_fifo_shared_dynamic_push_ctrl" module is designed to manage the push control for a shared dynamic multi-FIFO system. Its primary functionality is to handle multiple write ports and logical FIFOs, coordinating the allocation and deallocation of FIFO entries while ensuring data integrity and stability under various conditions, such as backpressure.                                                                                                                                                                      |
| br_ram_addr_decoder                      | The "br_ram_addr_decoder" module is designed to decode and direct an input address and data to a specific output tile based on the most-significant bits of the address. Its primary functionality is to support any RAM depth of 2 or more and any number of output tiles that evenly divide the RAM depth, optimizing the implementation if the RAM depth is a power of 2. The module can be configured to include a datapath and supports pipelining with a specified number of stages.                                                |
| br_ram_flops_tile                        | The "br_ram_flops_tile" module is a flop-based RAM tile designed to support multiple read and write ports, with the capability for the read and write ports to be clocked by different clocks. Its primary functionality includes providing zero-cycle read latency and one-cycle write latency, with an optional bypass feature that allows for zero-cycle write-to-read latency when the read and write clocks are the same. The module also supports partial writes and can be configured to clear memory elements upon reset.         |
| br_ram_flops                             | The "br_ram_flops" module is a highly parameterized, flop-based RAM designed to support multiple read and write ports with separate clock domains. Its primary functionality includes managing multi-read/multi-write operations through pipelined tiles, supporting partial writes, and providing configurable pipeline stages for both address and data paths, with optional features like memory reset and read-after-write hazard bypassing.                                                                                          |
| br_fifo_shared_dynamic_ctrl              | The "br_fifo_shared_dynamic_ctrl" module is designed to manage a shared storage multi-FIFO system with dynamic allocation, supporting multiple logical FIFOs. Its primary functionality includes coordinating push and pop operations across multiple write and read ports, dynamically allocating space in shared data RAM, and managing linked lists for FIFO order tracking, thereby optimizing data flow and resource utilization in complex FIFO configurations.                                                                     |

### Clock Ports

| Name | Description                         |
| ---- | ----------------------------------- |
| clk  | <br> **Clock active edge:** posedge |

### Reset Ports

| Name | Description                          |
| ---- | ------------------------------------ |
| rst  | <br> **Reset polarity:** active-high |

### Input Ports

| Name         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| push_valid   | **Type:** `logic[NumWritePorts-1:0]`.<br><br> **Purpose**: The `push_valid` port indicates whether the data being pushed into the FIFO is valid for each write port.<br><br>**Interaction**: Users or other modules set the `push_valid` signal to high (`1`) for each write port to indicate that the corresponding `push_data` and `push_fifo_id` are valid and should be processed by the FIFO.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid[i]` is high for a specific write port `i`, it signals that the data on `push_data[i]` and the FIFO ID on `push_fifo_id[i]` are ready to be written into the FIFO.<br>&nbsp;&nbsp;- If `push_ready[i]` is also high, the data is successfully written into the FIFO for that cycle.<br>&nbsp;&nbsp;- If `push_ready[i]` is low, the data is not written, and the user may need to retry in subsequent cycles.<br>&nbsp;&nbsp;- For example, if `NumWritePorts` is 2 and `push_valid` is `2'b11`, it indicates that both write ports have valid data ready to be pushed.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `push_valid` signal can be independently controlled for each write port, allowing simultaneous data pushes to different logical FIFOs.<br>&nbsp;&nbsp;- The behavior of `push_valid` in conjunction with `push_ready` can be influenced by parameters like `EnableCoverPushBackpressure`, which may assert conditions on the stability of `push_valid` during backpressure scenarios.                                                                                                                                                                                                                                                                                                                                                                      |
| push_data    | **Type:** `logic[NumWritePorts-1:0][Width-1:0]`.<br><br> **Purpose**: The `push_data` port is used to input data into the multi-FIFO system. It represents the data being pushed into the logical FIFOs.<br><br>**Interaction**: Users or other modules interact with the `push_data` port by providing data that corresponds to each write port. The data is associated with a specific logical FIFO, as indicated by the `push_fifo_id`.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid` is asserted for a particular write port, the data on the corresponding `push_data` line is considered valid and ready to be written into the FIFO.<br>&nbsp;&nbsp;- The data width is determined by the `Width` parameter, and there are `NumWritePorts` lines of data, allowing multiple data entries to be pushed simultaneously.<br>&nbsp;&nbsp;- For example, if `NumWritePorts` is 2 and `Width` is 8, `push_data` might look like `{{8'hA5, 8'h3C}}`, indicating two separate data entries being pushed in parallel.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The system can handle simultaneous data pushes to different logical FIFOs, or even to the same FIFO, as long as there is sufficient space.<br>&nbsp;&nbsp;- The stability of `push_data` during backpressure conditions is controlled by the `EnableAssertPushDataStability` parameter, which, if enabled, ensures that `push_data` remains stable when `push_ready` is not asserted.                                                                                                                                                                                                                                                                                                                                                                             |
| push_fifo_id | **Type:** `logic[NumWritePorts-1:0][FifoIdWidth-1:0]`.<br><br> **Purpose**: The `push_fifo_id` port is used to specify the target logical FIFO for each data push operation. It identifies which logical FIFO within the shared multi-FIFO structure the incoming data should be appended to.<br><br>**Interaction**: Users or other modules interact with the `push_fifo_id` port by providing a binary-encoded identifier for each write operation. This identifier corresponds to one of the logical FIFOs managed by the design. The width of this port is determined by `FifoIdWidth`, which is calculated based on the number of logical FIFOs (`NumFifos`).<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When a user wants to push data into a specific logical FIFO, they must provide a valid `push_fifo_id` that corresponds to the desired FIFO.<br>&nbsp;&nbsp;- For example, if there are 4 logical FIFOs (`NumFifos = 4`), the `push_fifo_id` would be a 2-bit wide signal (`FifoIdWidth = 2`), allowing values from `00` to `11` to select one of the four FIFOs.<br>&nbsp;&nbsp;- The design expects that the `push_fifo_id` is stable and correctly identifies the target FIFO whenever `push_valid` is asserted.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `push_fifo_id` allows multiple write ports (`NumWritePorts`) to simultaneously target different logical FIFOs, or even the same FIFO, depending on the provided identifiers.<br>&nbsp;&nbsp;- The ability to dynamically allocate space in the shared data RAM based on the `push_fifo_id` enables efficient use of storage resources across multiple logical FIFOs.<br>&nbsp;&nbsp;- If `push_fifo_id` is incorrectly specified (e.g., out of range), it could lead to undefined behavior, as the design assumes valid identifiers within the specified range. |
| pop_ready    | **Type:** `logic[NumFifos-1:0]`.<br><br> **Purpose**: The `pop_ready` port indicates the readiness of each logical FIFO to accept a pop operation, allowing data to be removed from the FIFO.<br><br>**Interaction**: Users or other modules interact with the `pop_ready` port by setting its bits to '1' for the specific logical FIFOs they wish to pop data from. Each bit corresponds to a different logical FIFO, with the total number of bits equal to `NumFifos`.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When a bit in `pop_ready` is set to '1', it signals that the corresponding logical FIFO is ready to perform a pop operation.<br>&nbsp;&nbsp;- If `pop_ready[i]` is '1' and there is data available in the FIFO, `pop_valid[i]` will be asserted, and `pop_data[i]` will contain the data being popped.<br>&nbsp;&nbsp;- If `pop_ready[i]` is '0', no pop operation will occur for the corresponding FIFO, regardless of the data availability.<br>&nbsp;&nbsp;- For example, if `NumFifos` is 4 and `pop_ready` is set to `4'b1010`, FIFOs 1 and 3 are ready to pop data, while FIFOs 0 and 2 are not.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `pop_ready` port allows for selective popping from multiple logical FIFOs simultaneously, depending on which bits are set.<br>&nbsp;&nbsp;- The interaction with `pop_ready` can be used to control the flow of data out of the FIFOs, potentially balancing the read bandwidth across multiple FIFOs.<br>&nbsp;&nbsp;- The behavior of `pop_ready` can be influenced by parameters like `StagingBufferDepth` and `RegisterPopOutputs`, which affect the latency and bandwidth of pop operations.                                                                                                                                                                   |

### Output Ports

| Name       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| push_ready | **Type:** `logic[NumWritePorts-1:0]`.<br><br> **Purpose**: The `push_ready` port indicates whether the FIFO is ready to accept new data for each write port.<br><br>**Interaction**: Users or other modules check the `push_ready` signal to determine if they can send data to the FIFO. If `push_ready` is high for a specific write port, the corresponding `push_valid` and `push_data` can be asserted to push data into the FIFO.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `push_ready` = 0.<br>&nbsp;&nbsp;- When `push_ready[i]` is high, it indicates that the FIFO can accept data on the `i-th` write port.<br>&nbsp;&nbsp;- If `push_ready[i]` is low, the FIFO is not ready to accept data on the `i-th` write port, and the user should wait before asserting `push_valid[i]`.<br>&nbsp;&nbsp;- For example, if `NumWritePorts` is 2 and `push_ready` = 2'b11, both write ports are ready to accept data.<br>&nbsp;&nbsp;- The `push_ready` signal is influenced by the availability of space in the FIFO and the current state of the FIFO's internal logic.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `push_ready` signal can change dynamically each clock cycle based on the FIFO's internal state and the number of write ports (`NumWritePorts`).<br>&nbsp;&nbsp;- The design allows for multiple write ports, and `push_ready` provides independent readiness signals for each port, enabling concurrent data pushes if multiple ports are ready.<br>&nbsp;&nbsp;- The behavior of `push_ready` is also affected by parameters like `Depth`, which determines the total capacity of the FIFO, and `EnableCoverPushBackpressure`, which may influence how backpressure is handled. |
| pop_valid  | **Type:** `logic[NumFifos-1:0]`.<br><br> **Purpose**: `pop_valid` indicates the availability of valid data for each logical FIFO in the multi-FIFO system.<br><br>**Interaction**: Users or other modules monitor `pop_valid` to determine when data can be read from the FIFO. Each bit in `pop_valid` corresponds to a specific logical FIFO, signaling whether data is ready to be popped.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `pop_valid` = 0.<br>&nbsp;&nbsp;- When `pop_valid[i]` is high, it indicates that the logical FIFO with ID `i` has valid data available for reading.<br>&nbsp;&nbsp;- If `pop_ready[i]` is asserted and `pop_valid[i]` is high, the data for FIFO `i` is read and `pop_valid[i]` may be de-asserted in the next cycle if no more data is available.<br>&nbsp;&nbsp;- The behavior of `pop_valid` is influenced by the `StagingBufferDepth` and `RegisterPopOutputs` parameters, which affect the latency and registration of the pop data.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- `pop_valid` can be high for multiple logical FIFOs simultaneously, allowing concurrent data reads if `pop_ready` is also asserted for those FIFOs.<br>&nbsp;&nbsp;- The parameter `RegisterPopOutputs` can introduce a cycle of latency, affecting when `pop_valid` transitions from high to low after a read operation.                                                                                                                                                                                                                                                                                                                                                        |
| pop_data   | **Type:** `logic[NumFifos-1:0][Width-1:0]`.<br><br> **Purpose**: `pop_data` provides the output data from the logical FIFOs when a pop operation is performed.<br><br>**Interaction**: Users or other modules interact with `pop_data` by monitoring it to receive data from the FIFO when `pop_valid` is asserted and `pop_ready` is high.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- `pop_data` outputs the data from the logical FIFO specified by the `pop_ready` signal.<br>&nbsp;&nbsp;- When `pop_valid` is high, it indicates that the data on `pop_data` is valid and can be consumed by the receiving module.<br>&nbsp;&nbsp;- The width of `pop_data` is determined by the `Width` parameter, and it provides data for each logical FIFO, indexed by `NumFifos`.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `pop_data` = 0, as it is not assigned a specific value during reset.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The data output on `pop_data` is influenced by the `StagingBufferDepth` and `RegisterPopOutputs` parameters, which can introduce latency or register the output data.<br>&nbsp;&nbsp;- The bandwidth of data output is affected by the `PointerRamReadLatency`, which can limit the rate at which data is popped from the FIFO.                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |

### Design Parameters

| Name                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NumWritePorts                  | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`NumWritePorts` defines the number of independent write interfaces available for pushing data into the FIFO. It determines how many simultaneous write operations can occur in a single clock cycle. Users interact with the design by asserting `push_valid` signals on these ports, along with corresponding `push_data` and `push_fifo_id`. The parameter ensures that the design can handle multiple data inputs concurrently, enhancing throughput. For example, if `NumWritePorts` is set to a higher value, the design can accept more data entries at once, provided there is sufficient space in the FIFO. This parameter must be configured to be at least one, ensuring at least one write operation can be performed.                                                                                                      |
| NumReadPorts                   | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`NumReadPorts` determines the number of read ports available in the design, allowing multiple logical FIFOs to be accessed simultaneously. This parameter influences the read bandwidth, as each logical FIFO can utilize any of the available read ports. Users can configure `NumReadPorts` to optimize data retrieval based on their system's requirements. For instance, with more read ports, multiple FIFOs can be read concurrently, enhancing throughput. However, the number of logical FIFOs should be at least equal to `NumReadPorts` to fully utilize the available read bandwidth.                                                                                                                                                                                                                                       |
| NumFifos                       | **Type:** `int`.<br><br> **Purpose of the Parameter**:<br>The `NumFifos` parameter defines the number of logical FIFOs within the shared dynamic multi-FIFO design. It determines how many separate FIFO queues can be managed simultaneously within the system. Users interact with the design by specifying a FIFO ID through the `push_fifo_id` signal when pushing data, which corresponds to one of the logical FIFOs. The parameter affects how data is organized and accessed, allowing for multiple independent data streams to be handled concurrently. For example, if `NumFifos` is set to a higher value, more distinct data queues can be managed, enabling greater parallelism in data handling. This parameter is crucial for applications requiring multiple independent data paths, as it directly impacts the design's capacity to handle diverse data flows.                   |
| Depth                          | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `Depth` parameter defines the total storage capacity of the multi-FIFO system. It determines how many data elements can be stored across all logical FIFOs combined. Users interact with the design by pushing data into the FIFOs using the `push_valid`, `push_data`, and `push_fifo_id` signals, and retrieving data using the `pop_ready` and `pop_data` signals. The `Depth` must be configured to be greater than twice the number of write ports (`NumWritePorts`) to ensure there is enough space to accommodate simultaneous writes. This parameter directly influences the maximum number of elements that can be stored and managed dynamically within the system, affecting how the design handles data allocation and deallocation across multiple logical FIFOs.                                                     |
| Width                          | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `Width` parameter defines the bit-width of the data elements that can be pushed into and popped from the FIFO. It determines the size of each data unit that the FIFO can handle, impacting how users interact with the design by specifying the data size for operations. For example, if `Width` is set to a larger value, each data element can contain more information, allowing for more complex data structures to be stored in the FIFO. Conversely, a smaller `Width` would limit the amount of data per element, suitable for simpler data types. This parameter is crucial for tailoring the FIFO to specific application requirements, ensuring compatibility with the data format used in the system.                                                                                                                 |
| StagingBufferDepth             | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `StagingBufferDepth` parameter determines the depth of the buffer used on the pop side of the FIFO. It directly influences the pop bandwidth of each logical FIFO by affecting how many items can be staged for output. A larger buffer depth allows for higher throughput, enabling more data to be popped in a given cycle, especially when the pointer RAM read latency is a limiting factor. Users can adjust this parameter to balance between resource usage and performance, ensuring that the FIFO can meet specific bandwidth requirements. For instance, setting the buffer depth to a value that matches the pointer RAM read latency plus one can achieve optimal pop throughput, allowing one item to be popped per cycle.                                                                                            |
| RegisterPopOutputs             | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `RegisterPopOutputs` parameter controls whether the `pop_valid` and `pop_data` signals are registered at the output of the staging buffer. When enabled, it ensures that these signals are stable and synchronized with the clock, adding a cycle of latency to the pop operation. This is particularly useful when users require the pop data to be registered for timing closure or to meet specific design constraints. For example, in scenarios where the downstream logic expects registered data, enabling this parameter provides a consistent and predictable interface.                                                                                                                                                                                                                                                  |
| RegisterDeallocation           | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `RegisterDeallocation` parameter is used to control the timing of the deallocation path from the pop-side staging buffer to the freelist. When enabled, it introduces a register in this path, which helps improve timing performance by reducing critical path delays. This comes at the cost of adding a cycle of backpressure latency, meaning that the system may take an additional clock cycle to process deallocation requests. Users can enable this parameter to optimize timing in designs where meeting timing constraints is challenging, especially in high-frequency applications. For example, if a user is experiencing timing violations due to the deallocation path, enabling `RegisterDeallocation` can help alleviate these issues by allowing the design to meet its timing requirements more easily.        |
| DataRamDepthTiles              | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`DataRamDepthTiles` is used to configure the depth dimension tiling of the data flop RAM in the design. It allows users to partition the depth of the data RAM into multiple tiles, which can be beneficial for optimizing memory layout and access patterns. By adjusting this parameter, users can influence how the data is stored and accessed within the RAM, potentially improving performance or meeting specific design constraints. For example, increasing the number of depth tiles might help in scenarios where parallel access to different sections of the RAM is required, thereby enhancing throughput.                                                                                                                                                                                                               |
| DataRamWidthTiles              | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`DataRamWidthTiles` is a configuration parameter that determines the tiling in the width dimension of the data flop RAM. This parameter affects how the data is organized and accessed within the RAM, potentially influencing the design's performance and resource utilization. Users can adjust `DataRamWidthTiles` to optimize the design for specific applications, balancing between data width and the number of tiles to achieve desired throughput and efficiency. For example, increasing the number of width tiles might allow for more parallel data processing, enhancing the design's ability to handle multiple data streams simultaneously.                                                                                                                                                                            |
| DataRamAddressDepthStages      | **Type:** `int`.<br><br> **Purpose of the Parameter**:<br>The `DataRamAddressDepthStages` parameter is used to configure the number of pipeline stages in the address path of the data RAM. This parameter affects the latency of address processing within the data RAM, which can influence the overall timing and performance of the FIFO operations. Users can adjust this parameter to optimize the balance between speed and resource usage, particularly in designs where timing closure is challenging. For example, increasing the number of stages can help meet timing requirements by allowing more time for address signals to propagate, but it may also introduce additional latency in accessing data.                                                                                                                                                                            |
| DataRamReadDataDepthStages     | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`DataRamReadDataDepthStages` is a configuration parameter that determines the number of pipeline stages in the depth dimension for reading data from the data RAM. This parameter affects the read latency of the data RAM, influencing how quickly data can be retrieved after a read request is made. Users can adjust this parameter to balance between read latency and timing closure, particularly in designs where the data RAM's read path needs to meet specific timing requirements. For example, increasing the number of stages can help achieve timing closure in high-frequency designs by allowing more time for data to propagate through the pipeline, albeit at the cost of increased latency.                                                                                                                       |
| DataRamReadDataWidthStages     | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`DataRamReadDataWidthStages` is a configuration parameter that determines the number of pipeline stages in the width dimension of the data RAM's read path. This parameter affects the latency of reading data from the RAM, influencing how quickly data can be retrieved after a read request. Users interact with this parameter by setting it to optimize the trade-off between read latency and timing closure, especially in designs where the width of the data RAM is significant. For example, increasing `DataRamReadDataWidthStages` can help meet timing requirements by allowing more time for data to propagate through the read path, but it also increases the overall read latency. This parameter is crucial for users aiming to balance performance and timing constraints in their specific application scenarios. |
| PointerRamDepthTiles           | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`PointerRamDepthTiles` is used to configure the depth dimension tiling of the pointer RAM within the design. This parameter allows users to adjust how the pointer RAM is partitioned in the depth dimension, which can influence the memory organization and potentially impact the performance and resource utilization of the design. By modifying `PointerRamDepthTiles`, users can optimize the design for specific applications, balancing between memory access efficiency and hardware resource constraints.                                                                                                                                                                                                                                                                                                                   |
| PointerRamWidthTiles           | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`PointerRamWidthTiles` is a configuration parameter that determines the tiling in the width dimension for the pointer flop RAM. This parameter affects how the pointer RAM is organized and can influence the efficiency of data access and storage. Users interact with this parameter by setting it to optimize the design for specific use cases, such as balancing between area and performance. For example, adjusting `PointerRamWidthTiles` can help manage the trade-off between the complexity of the pointer RAM and the speed at which pointers are accessed, which is crucial for maintaining the desired pop bandwidth and latency characteristics in the multi-FIFO system.                                                                                                                                              |
| PointerRamAddressDepthStages   | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`PointerRamAddressDepthStages` is used to configure the number of pipeline stages in the address path of the pointer RAM. This parameter affects the read latency of the pointer RAM, which in turn influences the pop bandwidth of each logical FIFO. By adjusting `PointerRamAddressDepthStages`, users can manage the trade-off between latency and throughput, ensuring that the design meets specific timing and performance requirements. For example, increasing the number of stages can help meet timing constraints in high-frequency designs, while potentially adding latency to the pointer RAM access.                                                                                                                                                                                                                   |
| PointerRamReadDataDepthStages  | **Type:** `int`.<br><br> **Purpose of the Parameter**:<br>`PointerRamReadDataDepthStages` is used to configure the number of pipeline stages in the depth dimension for reading data from the pointer RAM. This parameter affects the read latency of the pointer RAM, which in turn influences the pop bandwidth of each logical FIFO. Users can adjust this parameter to optimize the timing and performance of the FIFO operations, particularly when managing multiple logical FIFOs with varying read requirements. For example, increasing the number of stages can help meet timing constraints in designs with high-frequency operations, while potentially adding latency to the pointer read process.                                                                                                                                                                                   |
| PointerRamReadDataWidthStages  | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`PointerRamReadDataWidthStages` is a configuration parameter that determines the number of pipeline stages in the width dimension for reading data from the pointer RAM. This parameter affects the read latency of the pointer RAM, which in turn influences the overall pop bandwidth of the logical FIFOs. Users can adjust this parameter to optimize the timing and performance of the FIFO operations, particularly when dealing with high-frequency designs or when aiming to balance latency and throughput. For example, increasing the number of stages can help meet timing requirements by allowing more time for data to propagate through the pipeline, but it may also introduce additional latency in accessing the pointer RAM data.                                                                                  |
| EnableCoverPushBackpressure    | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableCoverPushBackpressure` parameter is used to configure the behavior of the design regarding backpressure on the push interface. When enabled, it allows the design to cover scenarios where the push side experiences backpressure, meaning that the `push_ready` signal may not always be asserted, even if `push_valid` is high. This parameter is crucial for testing and verifying that the design can handle situations where the FIFO cannot immediately accept new data due to resource constraints or other conditions. For example, if multiple write ports are active and the FIFO is nearing its capacity, enabling this parameter ensures that the design can manage and respond to such backpressure situations effectively.                                                                                    |
| EnableAssertPushValidStability | **Type:** `bit`.<br><br> **Purpose of the Parameter**:<br>The `EnableAssertPushValidStability` parameter is used to control the stability of the `push_valid` signal when the design experiences backpressure. When enabled, it ensures that the `push_valid` signal remains stable during cycles where backpressure is applied, preventing any changes or fluctuations. This is particularly important in scenarios where consistent signaling is required for reliable data handling. For example, if backpressure is applied due to a full FIFO, enabling this parameter ensures that `push_valid` does not toggle unexpectedly, maintaining the integrity of the data transfer process. Users can configure this parameter to assert the stability of `push_valid`, aligning with specific design requirements for signal consistency under backpressure conditions.                          |
| EnableAssertPushDataStability  | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableAssertPushDataStability` parameter is used to control the stability of the `push_data` signal when the system experiences backpressure. When enabled, it ensures that `push_data` remains stable and does not change while backpressure is applied, which is indicated by the `push_ready` signal being deasserted. This is crucial for maintaining data integrity during periods when the FIFO cannot accept new data. For example, if multiple write ports are trying to push data simultaneously and the FIFO is full, enabling this parameter ensures that the data being pushed does not fluctuate, preventing potential data corruption. Users interact with this parameter by setting it according to their system's requirements for data stability under backpressure conditions.                                  |
| EnableAssertFinalNotValid      | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableAssertFinalNotValid` parameter is used to ensure that the FIFO is empty and no valid bits are asserted at the end of a test. When enabled, it asserts that all data has been successfully popped and no residual data remains in the FIFO. This parameter is crucial for verifying the complete deallocation of resources and ensuring that the FIFO operates correctly without leaving any data unprocessed. Users interact with this parameter by enabling it to validate the final state of the FIFO after all operations are completed, ensuring that the design meets the expected behavior of being empty at the end of a test scenario.                                                                                                                                                                              |
| FifoIdWidth                    | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `FifoIdWidth` parameter determines the bit-width required to uniquely identify each logical FIFO within the design. It is calculated based on the number of logical FIFOs (`NumFifos`) and ensures that the `push_fifo_id` signal can accurately specify which FIFO to interact with during push operations. This parameter is crucial for routing data to the correct FIFO, especially when multiple logical FIFOs are managed within the same shared storage. For example, if there are four logical FIFOs, `FifoIdWidth` will be set to accommodate the binary representation needed to distinguish between them. This allows users to interact with the design by specifying the target FIFO for each data push, ensuring data is correctly allocated and retrieved from the intended logical FIFO.                            |
| AddrWidth                      | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`AddrWidth` determines the bit-width required to address the total depth of the FIFO. It is calculated based on the `Depth` parameter, ensuring that all memory locations within the FIFO can be uniquely addressed. This parameter is crucial for managing how data is stored and retrieved, as it directly impacts the addressing capability of both the data and pointer RAMs. Users interact with this parameter indirectly by setting the `Depth`, which in turn influences the `AddrWidth`. For example, if the FIFO depth is increased, `AddrWidth` must also increase to accommodate the additional addressable locations. This ensures that the design can handle the specified number of entries efficiently.                                                                                                                |

### Basic Functionality

| Function                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Push Data Handling with Backpressure   | Description: This function manages the process of pushing data into the FIFO system while handling backpressure scenarios. It ensures that data is correctly written to the FIFO based on the provided FIFO ID and that the system is ready to accept new data. The function also ensures data integrity and stability when backpressure is applied.<br>Input Signals: push_valid, push_data, push_fifo_id<br>Output Signals: push_ready<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that valid data is available for pushing.<br>2. The testbench provides data on `push_data` and specifies the target FIFO using `push_fifo_id`.<br>3. The design monitors `push_ready` to determine if it can accept the data.<br>4. If `push_ready` is asserted by the design, the data is successfully pushed into the FIFO.<br><br><br><br>Transaction 2:<br>1. The testbench asserts `push_valid` to indicate that data is ready to be pushed.<br>2. The design monitors `push_ready` to check if it can accept the data.<br>3. If `push_ready` is deasserted by the design, indicating backpressure, the testbench should hold the data and retry when `push_ready` is asserted again.<br> |
| FIFO Pop Operation with Staging Buffer | Description: This function manages the pop operation from the FIFO, ensuring data is correctly retrieved when the FIFO is ready to be read. It coordinates the readiness of the FIFO and the availability of data to be popped, taking into account the staging buffer depth and whether pop outputs are registered.<br>Input Signals: pop_ready<br>Output Signals: pop_valid, pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench sets `pop_ready` to indicate readiness to receive data.<br>2. The design monitors `pop_ready` and, if data is available, asserts `pop_valid` to indicate valid data is present.<br>3. The design provides the data on `pop_data` when `pop_valid` is asserted.<br>4. The testbench reads the data from `pop_data`.<br><br><br><br>Transaction 2:<br>1. The testbench sets `pop_ready` to indicate readiness to receive data.<br>2. The design monitors `pop_ready` and, if the staging buffer is used, ensures data is available in the buffer before asserting `pop_valid`.<br>3. The design provides the data on `pop_data` when `pop_valid` is asserted.<br>4. The testbench reads the data from `pop_data`.<br>                                                              |

### End-to-End Functionality

| Function                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Dynamic Multi-FIFO Operations | The design facilitates a sequence of push and pop operations across multiple logical FIFOs with dynamic allocation. It utilizes control signals `push_valid`, `push_data`, and `push_fifo_id` to push data into the FIFO system, while monitoring `push_ready` to determine data acceptance. The system supports multiple write ports, allowing simultaneous data pushes if space permits. Each logical FIFO is identified by `push_fifo_id`, and the pop operation is managed by `pop_ready`, with `pop_valid` asserted when data is ready to be read. Data retrieval occurs through `pop_data` when `pop_valid` is asserted. The design dynamically allocates space in shared data RAM to optimize resource utilization. The staging buffer depth influences pop bandwidth, ensuring efficient data retrieval. Multiple read ports enable concurrent data reads from different logical FIFOs. The design maintains data integrity and stability, with optional features like `RegisterPopOutputs` and `RegisterDeallocation` to manage latency and backpressure. Operations occur over multiple clock cycles, with coordinated push and pop operations to optimize throughput and resource allocation. |
