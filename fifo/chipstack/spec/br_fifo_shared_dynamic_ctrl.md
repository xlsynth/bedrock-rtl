## Design Mental Model

### File: ./fifo/rtl/br_fifo_shared_dynamic_ctrl.sv

### SUMMARY

#### Module Instantiation Hierarchy:

- br_fifo_shared_dynamic_ctrl
  - br_fifo_shared_dynamic_ptr_mgr
    - br_delay_valid
    - br_demux_bin
    - br_mux_onehot
    - br_tracker_linked_list_ctrl
      - br_counter
        - br_misc_unused
      - br_enc_countones
      - br_enc_priority_encoder
        - br_misc_unused
      - br_flow_checks_valid_data_impl
        - br_misc_unused
      - br_mux_onehot
  - br_fifo_shared_dynamic_push_ctrl
    - br_demux_bin
    - br_multi_xfer_distributor_rr
      - br_arb_multi_rr
        - br_enc_countones
        - br_enc_priority_dynamic
          - br_enc_priority_encoder
            - br_misc_unused
        - br_mux_bin
      - br_multi_xfer_distributor_core
        - br_flow_checks_valid_data_impl
          - br_misc_unused
        - br_misc_tieoff_one
        - br_multi_xfer_checks_sendable_data_intg
          - br_misc_unused
        - br_mux_onehot
    - br_tracker_freelist
      - br_delay
      - br_enc_bin2onehot
      - br_enc_countones
      - br_enc_onehot2bin
      - br_enc_priority_encoder
        - br_misc_unused
      - br_multi_xfer_reg_fwd
        - br_multi_xfer_checks_sendable_data_impl
          - br_misc_unused
        - br_multi_xfer_checks_sendable_data_intg
          - br_misc_unused
        - br_shift_left
        - br_shift_right
  - br_fifo_shared_pop_ctrl
    - br_fifo_shared_read_xbar
      - br_delay_valid
      - br_demux_bin
      - br_flow_demux_select_unstable
        - br_flow_checks_valid_data_impl
          - br_misc_unused
        - br_flow_checks_valid_data_intg
          - br_misc_unused
      - br_flow_mux_lru
        - br_arb_lru_internal
          - br_misc_unused
        - br_flow_mux_core
          - br_flow_arb_core
            - br_flow_checks_valid_data_impl
              - br_misc_unused
            - br_flow_checks_valid_data_intg
              - br_misc_unused
            - br_misc_unused
          - br_flow_checks_valid_data_impl
            - br_misc_unused
          - br_flow_checks_valid_data_intg
            - br_misc_unused
          - br_mux_onehot
      - br_misc_unused
      - br_mux_onehot
    - br_flow_checks_valid_data_impl
      - br_misc_unused
    - br_flow_join
      - br_flow_checks_valid_data_impl
        - br_misc_unused
      - br_flow_checks_valid_data_intg
        - br_misc_unused
    - br_misc_unused

#### Module Summary Table:

| Module                                  | Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| br_fifo_shared_dynamic_ctrl (Top Level) | The "br_fifo_shared_dynamic_ctrl" RTL module is designed to manage a shared storage multi-FIFO system with dynamic allocation, supporting multiple logical FIFOs. Its primary functionality includes coordinating push and pop operations across multiple write and read ports, dynamically allocating space in shared data RAM, and managing linked lists for tracking FIFO entries, while ensuring data integrity and stability under various conditions.                                        |
| br_counter                              | The "br_counter" RTL module is designed to implement a configurable increment/decrement counter with overflow and underflow handling. Its primary functionality includes incrementing or decrementing the counter by a variable amount each cycle, with configurable wrapping or saturation behavior at specified maximum and minimum values, and the ability to reinitialize the counter to an initial value.                                                                                     |
| br_tracker_freelist                     | The "br_tracker_freelist" module is designed to manage a set of entries that can be dynamically allocated and deallocated. Its primary functionality is to allow multiple entries to be allocated and deallocated per cycle, ensuring that once an entry is allocated, it cannot be reallocated until it has been properly deallocated. The module supports a multi-transfer interface for allocations and includes mechanisms to handle cut-through latency and bypassing of deallocated entries. |
| br_flow_join                            | The "br_flow_join" RTL module is designed to merge multiple upstream dataflow pipelines into a single downstream pipeline using a ready-valid handshake protocol inspired by AMBA. Its primary functionality is to synchronize pipeline stages and manage backpressure hazards, ensuring that data flows smoothly from multiple sources to a single destination without implementing the actual datapath.                                                                                          |
| br_multi_xfer_distributor_rr            | The "br_multi_xfer_distributor_rr" module is designed to distribute data from a multi-transfer sendable/receivable interface to multiple ready/valid flows using a round-robin arbitration mechanism. Its primary functionality is to manage the distribution of data symbols to available flows, ensuring efficient data transfer by selecting flows based on readiness and using multi-grant round-robin arbitration when there are more ready flows than available data.                        |
| br_fifo_shared_read_xbar                | The "br_fifo_shared_read_xbar" module is designed to manage read operations across multiple FIFOs (First-In, First-Out queues) using a shared read crossbar architecture. Its primary functionality is to handle the demultiplexing and multiplexing of read addresses and data between multiple FIFOs and read ports, ensuring efficient data flow and arbitration while supporting configurable parameters such as the number of FIFOs, read ports, address width, and data width.               |
| br_tracker_linked_list_ctrl             | The "br_tracker_linked_list_ctrl" RTL module is designed to manage the head and tail pointers of a linked list stored in external RAM, supporting multiple write ports and sub-linked lists. Its primary functionality includes updating and reading back tail pointers in a round-robin fashion to form a single logical linked list, improving bandwidth on the head interface, and handling variable read latencies from the pointer RAM.                                                       |
| br_fifo_shared_dynamic_push_ctrl        | The "br_fifo_shared_dynamic_push_ctrl" module is designed to manage the push control for a shared dynamic multi-FIFO system. Its primary functionality is to handle multiple write ports and logical FIFOs, coordinating the allocation and deallocation of FIFO entries while ensuring data integrity and stability under backpressure conditions.                                                                                                                                                |
| br_fifo_shared_dynamic_ptr_mgr          | The "br_fifo_shared_dynamic_ptr_mgr" RTL module is designed to manage multiple FIFO queues with shared dynamic pointers, supporting multiple read and write ports. Its primary functionality includes coordinating the read and write operations across these FIFOs, ensuring no conflicts occur on read ports, and efficiently managing head and tail pointers using linked list controllers for each FIFO.                                                                                       |
| br_fifo_shared_pop_ctrl                 | The "br_fifo_shared_pop_ctrl" module is designed to manage the pop operations for multiple FIFOs in a shared environment. Its primary functionality is to control the reading and deallocation of data from these FIFOs, coordinating with other modules to handle data flow, address management, and synchronization across multiple read ports and FIFOs, while supporting configurable parameters such as the number of FIFOs, read ports, and data width.                                      |

### Clock Ports

| Name | Description                         |
| ---- | ----------------------------------- |
| clk  | <br> **Clock active edge:** posedge |

### Reset Ports

| Name | Description                          |
| ---- | ------------------------------------ |
| rst  | <br> **Reset polarity:** active-high |

### Input Ports

| Name                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| push_valid             | **Type:** `logic[NumWritePorts-1:0]`.<br><br> **Purpose**: The `push_valid` port indicates whether the data being pushed into the FIFO is valid for each write port.<br><br>**Interaction**: Users or other modules set the `push_valid` signal to high (1) for a specific write port to indicate that the data on the corresponding `push_data` and `push_fifo_id` lines is valid and should be written to the FIFO.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid[i]` is high for a specific write port `i`, the module checks if there is space available in the FIFO for the data associated with that port.<br>&nbsp;&nbsp;- If `push_ready[i]` is also high, it means the FIFO can accept the data, and the data is written to the FIFO.<br>&nbsp;&nbsp;- If `push_ready[i]` is low, it indicates backpressure, and the data is not written, even if `push_valid[i]` is high.<br>&nbsp;&nbsp;- For example, if `NumWritePorts` is 2 and `push_valid` is `2'b11`, both write ports are attempting to push valid data into the FIFO.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `push_valid` signal can be used in conjunction with `EnableCoverPushBackpressure` to test scenarios where the FIFO experiences backpressure.<br>&nbsp;&nbsp;- If `EnableAssertPushValidStability` is enabled, `push_valid` must remain stable when backpressure is applied, ensuring that the data remains valid until it can be successfully written.                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| push_data              | **Type:** `logic[NumWritePorts-1:0][Width-1:0]`.<br><br> **Purpose**: The `push_data` port is used to input data into the multi-FIFO system. It represents the data being pushed into the logical FIFOs.<br><br>**Interaction**: Users or other modules interact with the `push_data` port by providing data that needs to be stored in the FIFO. The data is provided in conjunction with the `push_valid` signal, which indicates when the data is valid and ready to be pushed into the FIFO.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid` is asserted for a particular write port, the corresponding data on `push_data` is considered valid and will be pushed into the FIFO associated with the specified `push_fifo_id`.<br>&nbsp;&nbsp;- The data width is determined by the `Width` parameter, and there are `NumWritePorts` independent data inputs, allowing multiple data entries to be pushed simultaneously if multiple `push_valid` signals are asserted.<br>&nbsp;&nbsp;- For example, if `NumWritePorts` is 2 and `Width` is 8, `push_data` will be a 2x8 array, allowing two 8-bit data entries to be pushed in parallel.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The design allows for dynamic allocation of data to different logical FIFOs, meaning that data can be pushed to any FIFO specified by `push_fifo_id` without a fixed allocation of space.<br>&nbsp;&nbsp;- If `push_valid` is not asserted, the data on `push_data` is ignored, and no data is pushed into the FIFO.<br>&nbsp;&nbsp;- The system can handle simultaneous pushes to multiple FIFOs, as long as there is sufficient space, demonstrating the flexibility and efficiency of the multi-FIFO design.                                                                                                                                                                               |
| push_fifo_id           | **Type:** `logic[NumWritePorts-1:0][FifoIdWidth-1:0]`.<br><br> **Purpose**: The `push_fifo_id` port is used to specify the target logical FIFO for each write operation. It identifies which logical FIFO within the multi-FIFO structure should receive the incoming data.<br><br>**Interaction**: Users or other modules interact with the `push_fifo_id` port by providing a binary-encoded identifier for each write operation. This identifier corresponds to one of the logical FIFOs managed by the controller. The width of this port is determined by the number of write ports (`NumWritePorts`) and the number of logical FIFOs (`FifoIdWidth`).<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When a write operation is initiated, the `push_fifo_id` port should be set to the identifier of the logical FIFO that is intended to receive the data.<br>&nbsp;&nbsp;- For example, if there are four logical FIFOs, the `push_fifo_id` might take values from 0 to 3, depending on which FIFO is targeted.<br>&nbsp;&nbsp;- The controller uses this identifier to dynamically allocate space in the shared storage and manage the linked lists that track the order of entries for each logical FIFO.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `push_fifo_id` allows multiple write operations to target different logical FIFOs simultaneously, leveraging the multi-FIFO structure's ability to handle concurrent writes.<br>&nbsp;&nbsp;- If multiple write ports are used, each can specify a different `push_fifo_id`, enabling parallel data insertion into different logical FIFOs.<br>&nbsp;&nbsp;- The design supports dynamic allocation, meaning that the same `push_fifo_id` can be used in consecutive cycles to push data into the same logical FIFO, as long as there is sufficient space.                                                                            |
| pop_ready              | **Type:** `logic[NumFifos-1:0]`.<br><br> **Purpose**: The `pop_ready` port indicates the readiness of each logical FIFO to accept a pop operation.<br><br>**Interaction**: Users or other modules interact with the `pop_ready` port by setting its bits to '1' for the logical FIFOs they wish to pop data from. Each bit corresponds to a specific logical FIFO, and setting a bit to '1' signals that the corresponding FIFO is ready to perform a pop operation.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When a bit in `pop_ready` is set to '1', it indicates that the corresponding logical FIFO is ready to pop data.<br>&nbsp;&nbsp;- If `pop_ready[i]` is '1' and `pop_valid[i]` is also '1', then `pop_data[i]` will contain valid data from the FIFO with ID `i`.<br>&nbsp;&nbsp;- If `pop_ready[i]` is '0', the FIFO with ID `i` will not perform a pop operation, regardless of the state of `pop_valid[i]`.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `pop_ready` port allows for selective popping from multiple logical FIFOs simultaneously, depending on which bits are set to '1'.<br>&nbsp;&nbsp;- The readiness of a FIFO to pop data can be influenced by the state of the staging buffer and the data RAM read latency, as controlled by parameters like `StagingBufferDepth` and `DataRamReadLatency`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| data_ram_rd_data_valid | **Type:** `logic[NumReadPorts-1:0]`.<br><br> **Purpose**: The `data_ram_rd_data_valid` port indicates the validity of the data read from the data RAM for each read port.<br><br>**Interaction**: Users or other modules monitor this port to determine when the data read from the data RAM is valid and can be used. Each bit in the `data_ram_rd_data_valid` vector corresponds to a specific read port, indicating whether the data from that port is currently valid.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `data_ram_rd_data_valid[i]` is high (1), it signifies that the data available on `data_ram_rd_data[i]` is valid and can be processed by the consuming logic.<br>&nbsp;&nbsp;- When `data_ram_rd_data_valid[i]` is low (0), it indicates that the data on `data_ram_rd_data[i]` is not valid, and the consuming logic should not use it.<br>&nbsp;&nbsp;- For example, if `NumReadPorts` is 2 and `data_ram_rd_data_valid` is `2'b10`, it means the data from the second read port is valid, while the data from the first read port is not.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The timing of `data_ram_rd_data_valid` is crucial, especially when `DataRamReadLatency` is greater than zero, as it will determine when the data becomes valid after a read request is issued.<br>&nbsp;&nbsp;- The port's behavior is closely tied to the read latency settings, which can affect how quickly data becomes available after a read address is provided on `data_ram_rd_addr`.                                                                                                                                                                                                                                                                                                                                                                                      |
| data_ram_rd_data       | **Type:** `logic[NumReadPorts-1:0][Width-1:0]`.<br><br> **Purpose**: The `data_ram_rd_data` port is used to receive data read from the data RAM, which is part of the shared storage for the multi-FIFO system.<br><br>**Interaction**: Users or other modules interact with the `data_ram_rd_data` port by monitoring it to receive the data that has been read from the data RAM. This port is driven by the data RAM and is typically used in conjunction with the `data_ram_rd_data_valid` signal to determine when valid data is available.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `data_ram_rd_data_valid` is asserted, the `data_ram_rd_data` port contains valid data read from the data RAM.<br>&nbsp;&nbsp;- The data is organized as an array with dimensions `[NumReadPorts-1:0][Width-1:0]`, meaning there is a separate data output for each read port, and each output is `Width` bits wide.<br>&nbsp;&nbsp;- For example, if `NumReadPorts` is 2 and `Width` is 8, `data_ram_rd_data` will provide two 8-bit data values, one for each read port.<br>&nbsp;&nbsp;- The data corresponds to the addresses specified by `data_ram_rd_addr` when the read request was made, considering any latency specified by `DataRamReadLatency`.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The behavior of `data_ram_rd_data` is closely tied to the `data_ram_rd_data_valid` signal. Users must ensure they check this validity signal to avoid using stale or invalid data.<br>&nbsp;&nbsp;- The port supports multiple read ports, allowing simultaneous data retrieval from different addresses, which can be particularly useful in high-throughput applications.<br>&nbsp;&nbsp;- The width of the data (`Width`) and the number of read ports (`NumReadPorts`) can be configured, providing flexibility in how much data can be read in parallel and the size of each data word. |
| ptr_ram_rd_data_valid  | **Type:** `logic[NumReadPorts-1:0]`.<br><br> **Purpose**: The `ptr_ram_rd_data_valid` port indicates the validity of the data read from the pointer RAM for each read port.<br><br>**Interaction**: Users or other modules monitor this port to determine when the data read from the pointer RAM is valid and can be used. It is typically used in conjunction with the `ptr_ram_rd_data` port to ensure that the data being read is current and accurate.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ptr_ram_rd_data_valid[i]` is asserted (logic high) for a specific read port `i`, it signifies that the data available on `ptr_ram_rd_data[i]` is valid and can be processed.<br>&nbsp;&nbsp;- If `ptr_ram_rd_data_valid[i]` is deasserted (logic low), the data on `ptr_ram_rd_data[i]` should not be considered valid or reliable.<br>&nbsp;&nbsp;- For example, if `NumReadPorts` is 2 and `ptr_ram_rd_data_valid` is `2'b10`, it means that the data from the second read port is valid, while the data from the first read port is not.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The timing of `ptr_ram_rd_data_valid` is crucial, especially when `PointerRamReadLatency` is greater than zero, as it accounts for the delay between issuing a read address and receiving valid data.<br>&nbsp;&nbsp;- The port's behavior can be influenced by the number of read ports (`NumReadPorts`), as each bit in `ptr_ram_rd_data_valid` corresponds to a specific read port, allowing for independent validation of data across multiple ports.                                                                                                                                                                                                                                                                                                                                        |
| ptr_ram_rd_data        | **Type:** `logic[NumReadPorts-1:0][AddrWidth-1:0]`.<br><br> **Purpose**: The `ptr_ram_rd_data` port is used to receive data from the pointer RAM, which contains the addresses of the next entries in the linked lists for each logical FIFO.<br><br>**Interaction**: Users or other modules interact with the `ptr_ram_rd_data` port by reading the data provided on this port after issuing a read request through the `ptr_ram_rd_addr_valid` and `ptr_ram_rd_addr` ports. The data received represents the next address in the linked list for a specific logical FIFO.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When a read request is made by asserting `ptr_ram_rd_addr_valid` with a valid address on `ptr_ram_rd_addr`, the `ptr_ram_rd_data` port will provide the corresponding data after a delay determined by `PointerRamReadLatency`.<br>&nbsp;&nbsp;- For example, if `PointerRamReadLatency` is set to 1, the data will be available on `ptr_ram_rd_data` one cycle after the read request.<br>&nbsp;&nbsp;- The data on `ptr_ram_rd_data` should match the expected address in the linked list for the logical FIFO specified by the read request.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `ptr_ram_rd_data` port can handle multiple read requests simultaneously, as determined by `NumReadPorts`. This allows for concurrent access to different logical FIFOs, enhancing the overall throughput of the FIFO controller.<br>&nbsp;&nbsp;- The width of the data provided on `ptr_ram_rd_data` is determined by `AddrWidth`, which is calculated based on the total depth of the FIFO (`Depth`). This ensures that the address space is adequately covered for all possible entries in the FIFO.                                                                                                                                                                        |

### Output Ports

| Name                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| push_ready             | **Type:** `logic[NumWritePorts-1:0]`.<br><br> **Purpose**: The `push_ready` port indicates whether the FIFO controller is ready to accept new data on each write port.<br><br>**Interaction**: Users or other modules interact with the `push_ready` port by checking its value before attempting to send data to the FIFO. If `push_ready[i]` is high, the corresponding write port `i` can accept data.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `push_ready` = 0.<br>&nbsp;&nbsp;- When `push_ready[i]` is high, it signals that the FIFO is ready to accept data on write port `i`.<br>&nbsp;&nbsp;- If `push_valid[i]` is high and `push_ready[i]` is also high, data from `push_data[i]` and the FIFO ID from `push_fifo_id[i]` are successfully written to the FIFO.<br>&nbsp;&nbsp;- If `push_ready[i]` is low, the FIFO cannot accept data on write port `i`, and the user must wait until it becomes high.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- `push_ready` can be high for multiple write ports simultaneously, allowing concurrent data writes if there is sufficient space in the FIFO.<br>&nbsp;&nbsp;- The behavior of `push_ready` is influenced by the parameters `NumWritePorts`, `Depth`, and `EnableCoverPushBackpressure`, which determine the number of write ports, the total FIFO depth, and whether backpressure is covered, respectively.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| pop_valid              | **Type:** `logic[NumFifos-1:0]`.<br><br> **Purpose**: The `pop_valid` port indicates the availability of valid data for each logical FIFO in the multi-FIFO system. It signals when data can be popped from the FIFO.<br><br>**Interaction**: Users or other modules interact with the `pop_valid` port by monitoring its signals to determine when data is ready to be read from the FIFO. Each bit in the `pop_valid` vector corresponds to a specific logical FIFO, indicating whether that FIFO has data available to be popped.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `pop_valid` = 0, indicating that no data is available for popping from any FIFO.<br>&nbsp;&nbsp;- When `pop_valid[i]` is asserted (set to 1), it indicates that the logical FIFO with ID `i` has valid data available for popping.<br>&nbsp;&nbsp;- The `pop_valid` signal for a specific FIFO will be asserted when there is data in the FIFO and the corresponding `pop_ready` signal is also asserted, allowing data to be read.<br>&nbsp;&nbsp;- If `pop_ready[i]` is not asserted, `pop_valid[i]` may remain high, indicating that data is still available but not yet read.<br>&nbsp;&nbsp;- The behavior of `pop_valid` is influenced by parameters such as `DataRamReadLatency` and `StagingBufferDepth`, which affect when data becomes available for popping.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `pop_valid` signal can be affected by the `RegisterPopOutputs` parameter. If `RegisterPopOutputs` is set to 1, there will be an additional cycle of latency before `pop_valid` is asserted after data becomes available.<br>&nbsp;&nbsp;- The `pop_valid` signal is also dependent on the arbitration logic within the FIFO controller, which manages access to the shared data RAM and pointer RAM, potentially affecting when data becomes available for popping.              |
| pop_data               | **Type:** `logic[NumFifos-1:0][Width-1:0]`.<br><br> **Purpose**: The `pop_data` port provides the data output from the logical FIFOs when a pop operation is performed.<br><br>**Interaction**: Users or other modules interact with the `pop_data` port by monitoring it to receive data that has been stored in the logical FIFOs. The data is available when the corresponding `pop_valid` signal is asserted, indicating that valid data is present on the `pop_data` port.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `pop_data` = 0.<br>&nbsp;&nbsp;- When `pop_valid` is asserted for a specific FIFO, the `pop_data` for that FIFO contains the data being popped from the FIFO.<br>&nbsp;&nbsp;- The data width of each FIFO is determined by the `Width` parameter, and there are `NumFifos` entries in the `pop_data` array, each corresponding to a logical FIFO.<br>&nbsp;&nbsp;- If `pop_ready` is asserted for a FIFO, it indicates that the consumer is ready to accept the data, and the data on `pop_data` should be considered consumed.<br>&nbsp;&nbsp;- If `RegisterPopOutputs` is set to 1, the `pop_data` may experience a cycle of latency due to being registered at the output.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `pop_data` port can provide data from multiple logical FIFOs simultaneously, as each entry in the array corresponds to a different FIFO.<br>&nbsp;&nbsp;- The bandwidth of data output is influenced by the `StagingBufferDepth` and `DataRamReadLatency` parameters, which determine how quickly data can be read and made available on `pop_data`.<br>&nbsp;&nbsp;- The design supports dynamic allocation of FIFO space, meaning the data output on `pop_data` can vary based on the current allocation and usage of the FIFOs.                                                                                                 |
| data_ram_wr_valid      | **Type:** `logic[NumWritePorts-1:0]`.<br><br> **Purpose**: `data_ram_wr_valid` indicates whether a write operation to the data RAM is valid for each write port.<br><br>**Interaction**: Users or other modules interact with `data_ram_wr_valid` by monitoring its signals to determine when a valid write operation should occur for each write port. Each bit in the vector corresponds to a specific write port.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid` is asserted for a particular write port and the corresponding `push_ready` is also asserted, `data_ram_wr_valid` for that port will be set to 1, indicating a valid write operation to the data RAM.<br>&nbsp;&nbsp;- If `push_valid` is not asserted or if `push_ready` is not asserted, `data_ram_wr_valid` for that port will be 0, indicating no valid write operation.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `data_ram_wr_valid` = 0, indicating no valid write operations are occurring.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- `data_ram_wr_valid` can be asserted for multiple write ports simultaneously if there is sufficient space in the FIFO, allowing concurrent write operations.<br>&nbsp;&nbsp;- The behavior of `data_ram_wr_valid` is directly influenced by the backpressure mechanism, where `push_ready` may not be asserted if the FIFO is full, preventing `data_ram_wr_valid` from being set.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| data_ram_wr_addr       | **Type:** `logic[NumWritePorts-1:0][AddrWidth-1:0]`.<br><br> **Purpose**: The `data_ram_wr_addr` port specifies the write addresses in the data RAM for each write port, indicating where the incoming data should be stored.<br><br>**Interaction**: Users or other modules interact with this port by providing address values that correspond to the locations in the data RAM where data from the `push_data` port will be written. The address is determined by the internal logic of the FIFO controller based on the current state of the FIFO and the incoming `push_fifo_id`.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Normal Operation**: During normal operation, `data_ram_wr_addr` provides valid addresses for each active write port when `data_ram_wr_valid` is asserted. These addresses are used to store the incoming data from `push_data` into the data RAM.<br>&nbsp;&nbsp;- **Multiple Write Ports**: If multiple write ports are active, each will have its own address specified in the `data_ram_wr_addr` array, allowing simultaneous writes to different locations.<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `data_ram_wr_addr` is typically set to 0 or an undefined state until the FIFO controller initializes and begins normal operation.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- **Dynamic Allocation**: The addresses provided by `data_ram_wr_addr` are dynamically allocated based on the current state of the FIFO and the specific logical FIFO being written to, as indicated by `push_fifo_id`.<br>&nbsp;&nbsp;- **Concurrent Writes**: The design allows for concurrent writes to the data RAM from multiple write ports, each with its own address, maximizing throughput and efficiency.                                                                                                                                                                     |
| data_ram_wr_data       | **Type:** `logic[NumWritePorts-1:0][Width-1:0]`.<br><br> **Purpose**: `data_ram_wr_data` is used to transfer data to be written into the data RAM, corresponding to each write port.<br><br>**Interaction**: Users or other modules interact with `data_ram_wr_data` by providing the data that needs to be stored in the data RAM. This port is driven by the logic that handles the push operations, and it works in conjunction with `data_ram_wr_valid` and `data_ram_wr_addr` to ensure data is correctly written to the specified addresses in the data RAM.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid` is asserted for a write port, and `push_ready` is also asserted, the data from `push_data` for that port is transferred to `data_ram_wr_data`.<br>&nbsp;&nbsp;- The data is written to the address specified by `data_ram_wr_addr` when `data_ram_wr_valid` is asserted.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `data_ram_wr_data` is set to 0, as it is not assigned a specific value during reset.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The width of `data_ram_wr_data` is determined by the `Width` parameter, allowing flexibility in the size of data being written.<br>&nbsp;&nbsp;- The number of elements in `data_ram_wr_data` corresponds to `NumWritePorts`, enabling simultaneous data writes to multiple locations in the data RAM.<br>&nbsp;&nbsp;- The port supports dynamic allocation, meaning data can be written to different logical FIFOs based on the `push_fifo_id`, allowing efficient use of shared storage resources.                                                                                                                                                                                                                                                                                                                             |
| data_ram_rd_addr_valid | **Type:** `logic[NumReadPorts-1:0]`.<br><br> **Purpose**: `data_ram_rd_addr_valid` indicates the validity of read addresses for the data RAM, signaling when the read addresses are ready to be used for fetching data.<br><br>**Interaction**: Users or other modules interact with `data_ram_rd_addr_valid` by monitoring its state to determine when the read addresses provided on `data_ram_rd_addr` are valid and can be used to initiate a read operation from the data RAM.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `data_ram_rd_addr_valid` = 0.<br>&nbsp;&nbsp;- When `data_ram_rd_addr_valid` is asserted (set to 1), it indicates that the read addresses on `data_ram_rd_addr` are valid and should be used to access the data RAM.<br>&nbsp;&nbsp;- The port is a vector of size `NumReadPorts`, meaning each bit corresponds to a specific read port. For example, if `NumReadPorts` is 2, `data_ram_rd_addr_valid[0]` and `data_ram_rd_addr_valid[1]` indicate the validity of read addresses for the first and second read ports, respectively.<br>&nbsp;&nbsp;- The port should be monitored in conjunction with `data_ram_rd_data_valid` to ensure that the data read from the RAM is valid and corresponds to the requested addresses.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The behavior of `data_ram_rd_addr_valid` is closely tied to the read latency specified by `DataRamReadLatency`. If the latency is non-zero, there may be a delay between when `data_ram_rd_addr_valid` is asserted and when the corresponding data becomes valid on `data_ram_rd_data`.<br>&nbsp;&nbsp;- The design allows for multiple read ports, and `data_ram_rd_addr_valid` can independently indicate the validity of read addresses for each port, enabling concurrent read operations if multiple ports are used.                                                          |
| data_ram_rd_addr       | **Type:** `logic[NumReadPorts-1:0][AddrWidth-1:0]`.<br><br> **Purpose**: The `data_ram_rd_addr` port is used to specify the read addresses for the data RAM, allowing the controller to retrieve data from specific locations in the shared storage.<br><br>**Interaction**: Users or other modules interact with the `data_ram_rd_addr` port by providing address values that correspond to the locations in the data RAM from which data needs to be read. This interaction is typically driven by the internal logic of the FIFO controller, which determines the appropriate addresses based on the current state of the FIFOs and the read requests.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- The `data_ram_rd_addr` port outputs the addresses for the data RAM read operations.<br>&nbsp;&nbsp;- The addresses are determined by the internal logic of the FIFO controller, which manages the allocation and deallocation of space in the shared data RAM.<br>&nbsp;&nbsp;- The port outputs valid addresses when `data_ram_rd_addr_valid` is asserted, indicating that the addresses are ready to be used for read operations.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `data_ram_rd_addr` = 0, as it is not explicitly assigned a value in the reset condition.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `data_ram_rd_addr` port can output multiple addresses simultaneously, as it is an array with a size determined by `NumReadPorts`. This allows for concurrent read operations from multiple ports, enhancing the read bandwidth of the system.<br>&nbsp;&nbsp;- The mapping of reads to ports is based on the lower bits of the read address, which can lead to efficient utilization of the available read ports when multiple logical FIFOs are active.                                                                                                                                  |
| ptr_ram_wr_valid       | **Type:** `logic[NumWritePorts-1:0]`.<br><br> **Purpose**: The `ptr_ram_wr_valid` port indicates the validity of write operations to the pointer RAM for each write port. It signals when the data on the corresponding `ptr_ram_wr_addr` and `ptr_ram_wr_data` ports should be written to the pointer RAM.<br><br>**Interaction**: Users or other modules interact with the `ptr_ram_wr_valid` port by monitoring its signals to determine when a write operation to the pointer RAM is valid. Each bit in the `ptr_ram_wr_valid` vector corresponds to a specific write port, allowing multiple write operations to be validated simultaneously.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ptr_ram_wr_valid[i]` is asserted (set to 1), it indicates that the data on `ptr_ram_wr_addr[i]` and `ptr_ram_wr_data[i]` is valid and should be written to the pointer RAM at the specified address for the `i-th` write port.<br>&nbsp;&nbsp;- If `ptr_ram_wr_valid[i]` is deasserted (set to 0), no write operation should occur for the `i-th` write port, and the data on `ptr_ram_wr_addr[i]` and `ptr_ram_wr_data[i]` should be ignored.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ptr_ram_wr_valid` = 0, indicating no valid write operations are pending.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `ptr_ram_wr_valid` port allows for concurrent write operations across multiple write ports, enabling efficient use of the pointer RAM's bandwidth.<br>&nbsp;&nbsp;- The behavior of `ptr_ram_wr_valid` is closely tied to the `push_valid` and `push_fifo_id` signals, as these determine when new entries are added to the FIFO, necessitating updates to the pointer RAM.<br>&nbsp;&nbsp;- The port's behavior is influenced by the `NumWritePorts` parameter, which defines the width of the `ptr_ram_wr_valid` vector and the number of concurrent write operations that can be validated. |
| ptr_ram_wr_addr        | **Type:** `logic[NumWritePorts-1:0][AddrWidth-1:0]`.<br><br> **Purpose**: The `ptr_ram_wr_addr` port is used to specify the write address for the pointer RAM, which manages the linked list structure of the FIFO entries.<br><br>**Interaction**: Users or other modules interact with the `ptr_ram_wr_addr` port by providing the address where the next pointer data should be written in the pointer RAM. This interaction is typically driven by the logic that manages the allocation and deallocation of FIFO entries.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- The `ptr_ram_wr_addr` port receives an address value whenever a write operation to the pointer RAM is initiated.<br>&nbsp;&nbsp;- The address provided corresponds to the location in the pointer RAM where the next pointer data will be stored.<br>&nbsp;&nbsp;- The width of the address is determined by `AddrWidth`, and there are `NumWritePorts` separate addresses, allowing multiple write operations to occur simultaneously.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ptr_ram_wr_addr` = 0, as it is not explicitly assigned a value in the reset condition.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `ptr_ram_wr_addr` port allows for concurrent write operations across multiple write ports, as indicated by `NumWritePorts`. This enables efficient management of multiple logical FIFOs within the shared storage.<br>&nbsp;&nbsp;- The address values are crucial for maintaining the integrity of the linked list structure, ensuring that each FIFO's entries are correctly linked and accessible.                                                                                                                                                                                                                                                                                                             |
| ptr_ram_wr_data        | **Type:** `logic[NumWritePorts-1:0][AddrWidth-1:0]`.<br><br> **Purpose**: The `ptr_ram_wr_data` port is used to provide the address data that will be written into the pointer RAM, which manages the linked list structure for the logical FIFOs.<br><br>**Interaction**: Users or other modules interact with the `ptr_ram_wr_data` port by providing address data that corresponds to the next entry in the linked list for a particular logical FIFO. This data is used in conjunction with `ptr_ram_wr_valid` to perform write operations to the pointer RAM.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ptr_ram_wr_valid` is asserted, the data on `ptr_ram_wr_data` is written to the pointer RAM at the address specified by `ptr_ram_wr_addr`.<br>&nbsp;&nbsp;- The data represents the next address in the linked list for a logical FIFO, facilitating dynamic allocation and deallocation of FIFO entries.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ptr_ram_wr_data` is typically set to 0 or an undefined state, as it is not explicitly assigned a value in the reset condition.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `ptr_ram_wr_data` port allows for dynamic management of FIFO entries, enabling efficient use of memory by linking entries in a flexible manner.<br>&nbsp;&nbsp;- The width of `ptr_ram_wr_data` is determined by `AddrWidth`, which is a function of the total FIFO depth, allowing it to address any entry within the allocated space.                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ptr_ram_rd_addr_valid  | **Type:** `logic[NumReadPorts-1:0]`.<br><br> **Purpose**: The `ptr_ram_rd_addr_valid` port indicates when a read address is valid and ready to be sent to the pointer RAM for reading operations.<br><br>**Interaction**: Users or other modules interact with this port by monitoring its signal to determine when the read address for the pointer RAM is valid. This ensures that the pointer RAM only processes read requests when they are correctly formed and ready.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ptr_ram_rd_addr_valid` = 0.<br>&nbsp;&nbsp;- When `ptr_ram_rd_addr_valid` is asserted (set to 1), it signifies that the read address on `ptr_ram_rd_addr` is valid and can be used by the pointer RAM to fetch data.<br>&nbsp;&nbsp;- The port is typically asserted in synchronization with the clock (`clk`) to ensure that the read address is captured correctly by the pointer RAM.<br>&nbsp;&nbsp;- If `ptr_ram_rd_addr_valid` is deasserted (set to 0), it indicates that no valid read address is currently available, and the pointer RAM should not attempt to read data.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The behavior of `ptr_ram_rd_addr_valid` is closely tied to the read operations of the FIFO controller. It is expected to toggle in response to the internal logic that manages read requests, ensuring efficient and correct data retrieval from the pointer RAM.<br>&nbsp;&nbsp;- The port's behavior can be influenced by the `NumReadPorts` parameter, as it determines the width of the signal and the number of concurrent read operations that can be managed.                                                                                                                                                                                                                                                                 |
| ptr_ram_rd_addr        | **Type:** `logic[NumReadPorts-1:0][AddrWidth-1:0]`.<br><br> **Purpose**: The `ptr_ram_rd_addr` port is used to specify the read addresses for the pointer RAM, which manages the linked lists for tracking the order of entries in each logical FIFO.<br><br>**Interaction**: Users or other modules interact with the `ptr_ram_rd_addr` port by providing the address from which the pointer RAM should read data. This interaction is typically controlled by the internal logic of the FIFO controller, which determines the appropriate address based on the current state of the FIFOs and the need to manage linked list pointers.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Normal Operation**: During normal operation, `ptr_ram_rd_addr` provides the addresses for reading from the pointer RAM. The addresses are determined by the internal logic to manage the linked lists that track the order of entries in each logical FIFO.<br>&nbsp;&nbsp;- **Multiple Read Ports**: Since the type is `logic[NumReadPorts-1:0][AddrWidth-1:0]`, each read port can independently specify an address, allowing simultaneous reads from multiple locations in the pointer RAM.<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `ptr_ram_rd_addr` is typically set to 0 or another default value, ensuring that no unintended reads occur until the system is properly initialized.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- **Round-Robin Access**: The port may exhibit round-robin behavior when accessing multiple linked lists per logical FIFO, cycling through addresses to manage multiple lists efficiently.<br>&nbsp;&nbsp;- **Latency Considerations**: The behavior of `ptr_ram_rd_addr` is influenced by the `PointerRamReadLatency` parameter, which affects how quickly the read data is available after an address is specified.                                                                |

### Design Parameters

| Name                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NumWritePorts                  | **Type:** `int`.<br><br> **Purpose of the Parameter**:<br>The `NumWritePorts` parameter specifies the number of write ports available in the multi-FIFO controller. It determines how many simultaneous write operations can be performed on the FIFO system. Users interact with the design by providing data through these write ports, each associated with a `push_valid`, `push_data`, and `push_fifo_id` signal. The controller manages these inputs and allocates space dynamically in the shared data RAM. The expected behavior is that the system can handle multiple write requests concurrently, up to the number specified by `NumWritePorts`. This allows for efficient data handling and maximizes throughput by enabling multiple data entries to be pushed into the FIFO system in a single clock cycle, provided there is sufficient space.                                                                                                                                                                                                                         |
| NumReadPorts                   | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `NumReadPorts` parameter defines the number of read ports available in the multi-FIFO controller. It determines how many simultaneous read operations can be performed from the FIFO system. Users interact with the design by configuring this parameter to match the desired read bandwidth requirements. The parameter must be set to a power of 2 and at least 1, ensuring efficient utilization of the read bandwidth. For example, if `NumReadPorts` is set to 2, the design can handle two concurrent read requests, allowing two different logical FIFOs to be accessed simultaneously. This configuration is crucial for applications requiring high throughput and parallel data retrieval from multiple FIFOs.                                                                                                                                                                                                                                                                                              |
| NumFifos                       | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `NumFifos` parameter defines the number of logical FIFOs within the shared dynamic multi-FIFO controller. It determines how many separate FIFO queues can be managed simultaneously by the design. Each logical FIFO is identified by a unique ID, which is used in conjunction with the `push_fifo_id` signal to direct incoming data (`push_data`) to the correct FIFO. The `pop_valid` and `pop_data` signals are used to retrieve data from these logical FIFOs, with each FIFO having its own dedicated pop interface. This parameter is crucial for configuring the design to handle multiple independent data streams, allowing users to allocate and manage storage dynamically across different FIFOs. For example, if `NumFifos` is set to a higher value, the design can accommodate more separate data queues, each operating independently within the shared storage space.                                                                                                                               |
| Depth                          | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `Depth` parameter defines the total storage capacity of the multi-FIFO system. It determines how many data entries can be stored across all logical FIFOs combined. Users interact with this parameter by configuring it to ensure sufficient space for their application's data storage needs. The parameter must be set to a value greater than twice the number of write ports to ensure proper operation. For example, if there are multiple write operations occurring simultaneously, `Depth` ensures that there is enough space to accommodate all incoming data without overflow. This parameter directly impacts the system's ability to handle concurrent data pushes and maintain efficient data flow.                                                                                                                                                                                                                                                                                                      |
| Width                          | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `Width` parameter defines the bit-width of the data elements that can be pushed into and popped from the FIFO. It determines the size of each data entry in the FIFO, affecting how much data can be stored and transferred in each operation. Users interact with the design by providing data of this specified width through the `push_data` signal when pushing data into the FIFO. Similarly, when popping data, the `pop_data` signal will output data of this width. The parameter ensures that the data RAM and pointer RAM operations, such as `data_ram_wr_data` and `data_ram_rd_data`, are consistent with the specified data width, allowing for efficient data handling and storage within the FIFO structure.                                                                                                                                                                                                                                                                                           |
| StagingBufferDepth             | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `StagingBufferDepth` parameter determines the depth of the buffer used on the pop side of each logical FIFO. It directly influences the pop bandwidth, dictating how many items can be popped per cycle relative to the pointer RAM read latency. A higher `StagingBufferDepth` allows for increased pop bandwidth, enabling more efficient data retrieval from the FIFO. Users can adjust this parameter to optimize performance based on the latency of the pointer RAM and the desired throughput. For instance, setting `StagingBufferDepth` to match the pointer RAM read latency plus one ensures that a single logical FIFO can achieve one pop per cycle, maximizing data flow efficiency.                                                                                                                                                                                                                                                                                                                     |
| RegisterPopOutputs             | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `RegisterPopOutputs` parameter controls whether the `pop_valid` and `pop_data` signals are registered at the output of the staging buffer. When enabled, this parameter introduces a cycle of cut-through latency, meaning that the data and valid signals are delayed by one clock cycle before being output. This can be useful for improving timing closure by reducing the critical path length, especially in designs where the staging buffer's output needs to meet specific timing requirements. Users can interact with this parameter by setting it according to their latency and timing needs. For example, enabling this parameter would be beneficial in scenarios where the design's clock frequency is high, and the additional cycle of latency is acceptable.                                                                                                                                                                                                                                        |
| RegisterDeallocation           | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `RegisterDeallocation` parameter is used to control the timing of the deallocation path in the FIFO controller. When enabled, it introduces a register on the path from the pop-side staging buffer to the freelist. This configuration improves the timing performance by reducing the critical path delay, which can be beneficial in high-frequency designs. However, it also introduces an additional cycle of backpressure latency, meaning that the deallocation of entries back to the freelist is delayed by one clock cycle. This trade-off allows users to optimize the design for either speed or latency, depending on their specific application requirements.                                                                                                                                                                                                                                                                                                                                            |
| DataRamReadLatency             | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`DataRamReadLatency` specifies the number of clock cycles between issuing a read address to the data RAM and receiving the corresponding read data. This parameter allows users to configure the design to accommodate varying data RAM access times. For example, if the data RAM has a latency of two cycles, setting `DataRamReadLatency` to two ensures that the `data_ram_rd_data` is correctly synchronized with the read request. This parameter is crucial for ensuring that the `pop_data` is available at the correct time, especially when `pop_ready` is asserted, and helps in managing the timing of data retrieval from the data RAM.                                                                                                                                                                                                                                                                                                                                                                       |
| PointerRamReadLatency          | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `PointerRamReadLatency` parameter defines the number of clock cycles required to read data from the pointer RAM. This latency affects how quickly the design can access the linked list pointers that manage the order of entries in each logical FIFO. Users interact with this parameter by setting it to match the actual read latency of the pointer RAM used in their system. The expected behavior is that the design will account for this latency when managing FIFO operations, ensuring that data is correctly accessed and processed. For example, if the pointer RAM has a read latency of two cycles, setting `PointerRamReadLatency` accordingly allows the design to synchronize operations and maintain correct FIFO behavior. This parameter is crucial for optimizing the performance and timing of the FIFO controller, especially in systems where pointer RAM access speed is a limiting factor.                                                                                                  |
| EnableCoverPushBackpressure    | **Type:** `bit`.<br><br> **Purpose of the Parameter**:<br>The `EnableCoverPushBackpressure` parameter is used to configure the behavior of the FIFO controller regarding backpressure on the push interface. When enabled, it allows the design to cover scenarios where the push interface experiences backpressure, meaning that the `push_ready` signal may not always be asserted, indicating that the FIFO cannot accept new data. This parameter is crucial for testing and verification purposes, as it ensures that the design can handle situations where the FIFO is full or unable to process incoming data immediately. Users interact with this parameter by setting it to enable or disable the coverage of backpressure scenarios, which can be particularly useful in environments where data flow control is critical. For example, in a system with multiple write ports, enabling this parameter helps verify that the design can manage simultaneous data pushes without data loss or corruption, even when the FIFO is temporarily unable to accept new entries. |
| EnableAssertPushValidStability | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableAssertPushValidStability` parameter is used to control the assertion behavior related to the stability of the `push_valid` signal during backpressure conditions. When enabled, it ensures that the `push_valid` signal remains stable (i.e., does not change) when the `push_ready` signal is not asserted, indicating that the FIFO cannot accept new data. This is crucial for maintaining data integrity and preventing erroneous data entries into the FIFO. For example, if a user attempts to push data into the FIFO when it is full, the `push_valid` signal should remain unchanged until the FIFO is ready to accept new data. This parameter is particularly useful in scenarios where maintaining a consistent data flow is critical, and it helps in debugging and verifying the design's behavior under backpressure conditions.                                                                                                                                                                 |
| EnableAssertPushDataStability  | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableAssertPushDataStability` parameter is used to control the assertion behavior related to the stability of `push_data` during backpressure conditions. When enabled, it ensures that `push_data` remains stable and does not change while the `push_ready` signal is de-asserted, indicating that the system cannot accept new data. This is crucial for maintaining data integrity when multiple write ports (`NumWritePorts`) are active. For example, if backpressure is applied, the data being pushed should not fluctuate until the system is ready to accept it again. This parameter is particularly useful in scenarios where data consistency is critical, and it helps in debugging and verifying the design's robustness under backpressure conditions.                                                                                                                                                                                                                                               |
| EnableAssertFinalNotValid      | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableAssertFinalNotValid` parameter is used to ensure that the FIFO is empty and no valid bits are asserted at the end of a test. When enabled, it asserts that all `pop_valid` signals are deasserted and the FIFO is completely empty after operations are completed. This parameter is crucial for verifying that the FIFO has been fully drained and no residual data remains, ensuring data integrity and proper operation. For example, in a test scenario where multiple data items are pushed and popped, enabling this parameter would check that after all operations, the FIFO is in a reset state with no pending data.                                                                                                                                                                                                                                                                                                                                                                                  |
| FifoIdWidth                    | **Type:** `int`.<br><br> **Purpose of the Parameter**:<br>The `FifoIdWidth` parameter determines the bit-width required to uniquely identify each logical FIFO within the multi-FIFO controller. It is calculated based on the number of logical FIFOs (`NumFifos`) and ensures that the `push_fifo_id` signal can accurately specify which FIFO is being targeted during a push operation. This parameter is crucial for routing data to the correct FIFO and managing the dynamic allocation of storage space within the shared data RAM. Users interact with this parameter indirectly by specifying the number of logical FIFOs, which in turn influences the bit-width of the FIFO ID used in push operations.                                                                                                                                                                                                                                                                                                                                                                   |
| AddrWidth                      | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`AddrWidth` determines the bit-width of the address signals used for accessing the data and pointer RAMs. It is calculated based on the total depth of the FIFO, ensuring that the address lines can uniquely identify each storage location within the RAM. This parameter is crucial for correctly indexing into the RAMs during read and write operations, allowing the design to handle the specified depth of the FIFO efficiently. Users interact with this parameter indirectly by configuring the `Depth` of the FIFO, which in turn influences the `AddrWidth`. For example, if the FIFO depth is increased, `AddrWidth` will also increase to accommodate the larger address space required.                                                                                                                                                                                                                                                                                                                     |

### Basic Functionality

| Function                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Push Data Handling            | Description: This function manages the push interface for writing data into the FIFO system. It ensures that data is correctly pushed into the FIFO based on the availability of space and the readiness of the system to accept new data.<br>Input Signals: push_valid, push_data, push_fifo_id<br>Output Signals: push_ready, data_ram_wr_valid, data_ram_wr_addr, data_ram_wr_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that data is available for pushing into the FIFO.<br>2. The testbench provides data on `push_data` and specifies the target FIFO using `push_fifo_id`.<br>3. The design monitors `push_valid` and checks if there is space available in the FIFO.<br>4. If space is available, the design asserts `push_ready` to indicate readiness to accept data.<br>5. The design asserts `data_ram_wr_valid` to initiate the write operation to the data RAM.<br>6. The design provides the write address on `data_ram_wr_addr` and the data on `data_ram_wr_data`.<br>7. The testbench monitors `push_ready` to confirm that the data has been accepted.<br> |
| Backpressure Management       | Description: This function manages backpressure conditions on the push interface, ensuring that data is not lost or corrupted when the FIFO is unable to accept new data due to being full or other constraints.<br>Input Signals: push_valid<br>Output Signals: push_ready<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that data is ready to be pushed.<br>2. The design monitors `push_valid` and evaluates the current state of the FIFO.<br>3. If the FIFO is unable to accept new data, the design deasserts `push_ready` to apply backpressure.<br>4. The testbench monitors `push_ready` to detect backpressure and may choose to retry the push operation later.<br>                                                                                                                                                                                                                                                                                                                                                                                                         |
| FIFO Entry Allocation         | Description: This function manages the allocation of FIFO entries for incoming data. It ensures that entries are allocated based on the availability and readiness of the FIFO system to accept new data.<br>Input Signals: push_valid, push_fifo_id<br>Output Signals: push_ready, data_ram_wr_addr<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that data is ready to be pushed into the FIFO.<br>2. The testbench provides the target FIFO ID on `push_fifo_id`.<br>3. The design monitors the availability of entries and asserts `push_ready` if entries are available for allocation.<br>4. The design provides the allocated entry address on `data_ram_wr_addr`.<br>                                                                                                                                                                                                                                                                                                                                                                                                          |
| Next Tail Update              | Description: This function updates the next tail pointers for each FIFO based on the data being written. It ensures that the tail pointers are correctly updated to reflect the new state of the FIFO after a push operation.<br>Input Signals: push_valid, push_data, push_fifo_id<br>Output Signals: next_tail_valid, next_tail<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that data is available for writing.<br>2. The testbench provides data on `push_data` and specifies the target FIFO using `push_fifo_id`.<br>3. The design monitors `push_valid` and `push_fifo_id` to determine which FIFO's tail needs to be updated.<br>4. The design asserts `next_tail_valid` for the corresponding FIFO to indicate that the tail pointer is being updated.<br>5. The design updates `next_tail` with the new address for the tail pointer based on the data written.<br>                                                                                                                                                                                                         |
| FIFO Pop Operation            | Description: This function manages the pop operation from the FIFO, ensuring that data is correctly read from the FIFO and provided to the output when requested.<br>Input Signals: pop_ready, data_ram_rd_data_valid, data_ram_rd_data<br>Output Signals: pop_valid, pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `pop_ready` to indicate readiness to accept data from the FIFO.<br>2. The design monitors `data_ram_rd_data_valid` to determine when valid data is available from the data RAM.<br>3. When `data_ram_rd_data_valid` is asserted, the design asserts `pop_valid` to indicate that valid data is available for the pop operation.<br>4. The design provides the data on `pop_data` from `data_ram_rd_data`.<br>                                                                                                                                                                                                                                                                                                                                                                      |
| Data RAM Read Address Control | Description: This function manages the generation and validation of read addresses for accessing data from the data RAM, ensuring that the correct addresses are provided for reading data.<br>Input Signals: pop_ready<br>Output Signals: data_ram_rd_addr_valid, data_ram_rd_addr<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `pop_ready` to indicate readiness to initiate a read operation.<br>2. The design monitors `pop_ready` and determines the appropriate read address.<br>3. The design asserts `data_ram_rd_addr_valid` to indicate that the read address is being routed.<br>4. The design provides the routed read address on `data_ram_rd_addr`.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Data RAM Write Management     | Description: This function manages the writing of data to the data RAM, ensuring that the correct data is written to the appropriate addresses based on the push operations. It coordinates the write operations across multiple write ports, handling the logic for determining when and where to write the data.<br>Input Signals: push_valid, push_data, push_fifo_id<br>Output Signals: data_ram_wr_valid, data_ram_wr_addr, data_ram_wr_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that data is available for writing into the FIFO.<br>2. The testbench provides data on `push_data` and specifies the target FIFO using `push_fifo_id`.<br>3. The design monitors `push_valid` and checks if there is space available in the FIFO.<br>4. If space is available, the design asserts `data_ram_wr_valid` to initiate the write operation to the data RAM.<br>5. The design provides the write address on `data_ram_wr_addr` and the data on `data_ram_wr_data`.<br>6. The testbench monitors `data_ram_wr_valid` to confirm that the write operation is initiated.<br>    |
| Data RAM Read Management      | Description: This function manages the reading of data from the data RAM, ensuring that the correct data is retrieved from the appropriate addresses based on the pop operations. It coordinates the read operations across multiple read ports, handling the logic for determining when and where to read the data.<br>Input Signals: data_ram_rd_data_valid, data_ram_rd_data<br>Output Signals: data_ram_rd_addr_valid, data_ram_rd_addr<br><br>Transactions:<br><br>Transaction 1:<br>1. The design asserts `data_ram_rd_addr_valid` to indicate a read operation is requested.<br>2. The design provides the address to be read on `data_ram_rd_addr`.<br>3. The testbench monitors `data_ram_rd_data_valid` to determine when the read data is available.<br>4. Once `data_ram_rd_data_valid` is asserted by the testbench, the design reads the data from `data_ram_rd_data`.<br>                                                                                                                                                                                                                                                 |
| Pointer RAM Write Operation   | Description: This function manages the writing of pointers to the pointer RAM, ensuring that the correct tail pointers are updated for each FIFO. It coordinates the write operations across multiple write ports, handling the logic for determining when and where to write the tail pointers.<br>Input Signals: push_valid, push_data, push_fifo_id<br>Output Signals: ptr_ram_wr_valid, ptr_ram_wr_addr, ptr_ram_wr_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` and provides the new tail pointer value on `push_data` and the target FIFO ID on `push_fifo_id`.<br>2. The design monitors `push_valid` and, if asserted, prepares to update the tail pointer for the specified FIFO.<br>3. The design asserts `ptr_ram_wr_valid` to indicate a write operation is ready to be performed.<br>4. The design provides the address of the current tail pointer on `ptr_ram_wr_addr` and the new tail pointer value on `ptr_ram_wr_data`.<br>5. The testbench monitors `ptr_ram_wr_valid` to confirm the write operation is initiated.<br>                                                  |
| Pointer RAM Read Operation    | Description: This function manages the reading of pointers from the pointer RAM, ensuring that the correct head pointers are retrieved for each FIFO. It coordinates the read operations across multiple read ports, handling the logic for determining when and where to read the head pointers.<br>Input Signals: ptr_ram_rd_data_valid, ptr_ram_rd_data<br>Output Signals: ptr_ram_rd_addr_valid, ptr_ram_rd_addr<br><br>Transactions:<br><br>Transaction 1:<br>1. The design asserts `ptr_ram_rd_addr_valid` to indicate a read operation is requested.<br>2. The design provides the address to be read on `ptr_ram_rd_addr`.<br>3. The testbench monitors `ptr_ram_rd_data_valid` to determine when the read data is available.<br>4. Once `ptr_ram_rd_data_valid` is asserted by the testbench, the design reads the data from `ptr_ram_rd_data`.<br>                                                                                                                                                                                                                                                                             |

### End-to-End Functionality

| Function                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Dynamic Multi-FIFO Management | The 'br_fifo_shared_dynamic_ctrl' RTL module manages multiple logical FIFOs with dynamic allocation, supporting concurrent push and pop operations across multiple ports. The design supports multiple write ports (`NumWritePorts`) and read ports (`NumReadPorts`), allowing simultaneous operations. Each logical FIFO is identified by `push_fifo_id` during push operations. Push operations are initiated by asserting `push_valid` with corresponding `push_data` and `push_fifo_id`. The design checks for space availability and asserts `push_ready` when ready to accept data. Data is written to the data RAM with `data_ram_wr_valid`, `data_ram_wr_addr`, and `data_ram_wr_data`. Pop operations are initiated by asserting `pop_ready`. The design checks for available data and asserts `pop_valid` when data is ready to be read. Data is read from the data RAM with `data_ram_rd_data_valid` and `data_ram_rd_data`, and provided on `pop_data`. The design dynamically manages FIFO entries using pointer RAM, with `ptr_ram_wr_valid`, `ptr_ram_wr_addr`, `ptr_ram_wr_data` for writes, and `ptr_ram_rd_addr_valid`, `ptr_ram_rd_addr` for reads. The design supports configurable parameters such as `Depth`, `Width`, `StagingBufferDepth`, `DataRamReadLatency`, and `PointerRamReadLatency` to tailor performance and resource utilization. The design ensures data integrity and stability under backpressure conditions, with optional assertions for push data and valid stability (`EnableAssertPushValidStability`, `EnableAssertPushDataStability`). The design can handle backpressure by deasserting `push_ready` when the FIFO is full or unable to accept new data. The design supports multiple linked lists per FIFO to enhance pop bandwidth, with the number determined by `StagingBufferDepth`. The design operates over multiple clock cycles, with specific latencies introduced by `DataRamReadLatency` and `PointerRamReadLatency`. |
