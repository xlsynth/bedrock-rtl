## Design Mental Model

### File: ./fifo/rtl/br_fifo_ctrl_1r1w.sv

### SUMMARY

#### Module Instantiation Hierarchy:

- br_fifo_ctrl_1r1w
  - br_fifo_pop_ctrl
    - br_counter
    - br_fifo_pop_ctrl_core
      - br_counter_incr
      - br_misc_unused
  - br_fifo_push_ctrl
    - br_counter
    - br_fifo_push_ctrl_core
      - br_counter_incr
      - br_flow_checks_valid_data_intg
        - br_misc_unused

#### Module Summary Table:

| Module                         | Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| br_fifo_ctrl_1r1w (Top Level)  | The "br_fifo_ctrl_1r1w" RTL module is designed to manage a one-read/one-write (1R1W) FIFO controller using a ready-valid handshake protocol for synchronizing pipeline stages and handling backpressure. Its primary functionality includes interfacing with an external RAM for data storage, supporting both bypass and non-bypass modes to optimize latency and timing, and maintaining status flags for push and pop operations.                                               |
| br_misc_unused                 | The "br_misc_unused" RTL module is designed to handle unused signals by sinking them and internally waiving the corresponding lint errors. Its primary functionality is to ensure that these unused signals do not cause issues during linting, with the expectation that synthesis tools will automatically remove this logic.                                                                                                                                                    |
| br_counter_incr                | The "br_counter_incr" RTL module is designed to implement an incrementing counter that can increase by a variable amount each cycle, with the increment constrained by a specified maximum value. The module handles overflow by either wrapping around or saturating at a defined maximum value, and it supports reinitialization to a specified initial value, with the option to apply increments during reinitialization.                                                      |
| br_flow_checks_valid_data_intg | The "br_flow_checks_valid_data_intg" RTL module is designed to perform assertion checks on ready-valid interfaces within a digital design. Its primary functionality is to ensure that the valid and data signals conform to the ready-valid protocol by checking for conditions such as backpressure, stability of valid and data signals, and ensuring no valid bits are asserted at the end of a test.                                                                          |
| br_counter                     | The "br_counter" RTL module is designed to implement a configurable increment/decrement counter with overflow and underflow handling. Its primary functionality is to allow the counter to increment or decrement by a variable amount each cycle, with options for wrapping or saturating at specified maximum values, and to support reinitialization to a given initial value.                                                                                                  |
| br_fifo_pop_ctrl_core          | The "br_fifo_pop_ctrl_core" RTL module is designed to manage the pop control logic for a FIFO, focusing on bypass and RAM read operations while leaving occupancy tracking to the instantiating module. Its primary functionality includes handling flow control for data popping, managing RAM read addresses, and optionally supporting bypass paths to optimize data throughput when enabled.                                                                                   |
| br_fifo_push_ctrl_core         | The "br_fifo_push_ctrl_core" RTL module is designed to manage the push control logic for a FIFO, focusing on bypass and RAM write operations while leaving occupancy tracking to the instantiating module. Its primary functionality includes handling flow control by determining when data can be pushed into the FIFO, managing bypass paths if enabled, and interfacing with RAM for data storage, all while ensuring protocol compliance through integrated assertion checks. |
| br_fifo_pop_ctrl               | The "br_fifo_pop_ctrl" RTL module is designed to manage the pop control logic for a FIFO (First-In-First-Out) buffer, focusing on handling data flow control and status flag updates. Its primary functionality includes managing the readiness and validity of data being popped from the FIFO, supporting bypass paths for optimized data throughput, and tracking the occupancy status of the FIFO using internal counters.                                                     |
| br_fifo_push_ctrl              | The "br_fifo_push_ctrl" RTL module is designed to manage the push control logic for a FIFO (First-In-First-Out) buffer, ensuring efficient data flow and handling backpressure scenarios. Its primary functionality includes coordinating the push-side interface, managing bypass operations if enabled, and interfacing with RAM for data storage, while maintaining protocol compliance through integrated assertion checks and status flag management.                         |

### Clock Ports

| Name | Description                         |
| ---- | ----------------------------------- |
| clk  | <br> **Clock active edge:** posedge |

### Reset Ports

| Name | Description                          |
| ---- | ------------------------------------ |
| rst  | <br> **Reset polarity:** active-high |

### Input Ports

| Name              | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| push_valid        | **Type:** `logic`.<br><br> **Purpose**: `push_valid` indicates when valid data is available on the `push_data` input for writing into the FIFO.<br><br>**Interaction**: Users or other modules assert `push_valid` to signal that the data on `push_data` is ready to be pushed into the FIFO. It works in conjunction with `push_ready` to manage data flow into the FIFO.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid` is asserted (set to 1) and `push_ready` is also asserted, the data on `push_data` is written into the FIFO.<br>&nbsp;&nbsp;- If `push_valid` is asserted but `push_ready` is not, the data is not written, and the user must continue to assert `push_valid` until `push_ready` becomes asserted.<br>&nbsp;&nbsp;- When `push_valid` is deasserted (set to 0), no data is pushed into the FIFO, regardless of the state of `push_ready`.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- If the FIFO is full (`full` is asserted), `push_ready` will be deasserted, causing backpressure. In this case, even if `push_valid` is asserted, the data will not be written until there is space available in the FIFO.<br>&nbsp;&nbsp;- The behavior of `push_valid` can be influenced by the `EnableBypass` parameter. If bypass is enabled, data can be pushed directly to the pop interface under certain conditions, potentially reducing latency.                                                                                                                                                                                                                                                                                                                                   |
| push_data         | **Type:** `logic[Width-1:0]`.<br><br> **Purpose**: `push_data` is used to provide the data that is intended to be written into the FIFO.<br><br>**Interaction**: Users or other modules interact with `push_data` by driving it with the data they wish to enqueue into the FIFO. This data is considered valid when `push_valid` is asserted.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid` is high and `push_ready` is also high, the data on `push_data` is successfully written into the FIFO.<br>&nbsp;&nbsp;- The width of `push_data` is determined by the `Width` parameter, allowing for flexibility in the size of the data being handled.<br>&nbsp;&nbsp;- If `push_valid` is asserted but `push_ready` is not, the data on `push_data` should remain stable until `push_ready` goes high, indicating that the FIFO is ready to accept new data.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- In scenarios where `EnableBypass` is set to 1, `push_data` can be directly forwarded to the `pop_data` output when the FIFO is empty, allowing for zero-cycle latency in data transfer.<br>&nbsp;&nbsp;- The stability of `push_data` during backpressure conditions can be asserted or covered based on the `EnableAssertPushDataStability` parameter, ensuring data integrity when the FIFO cannot accept new data immediately.                                                                                                                                                                                                                                                                                                                                                                  |
| pop_ready         | **Type:** `logic`.<br><br> **Purpose**: The `pop_ready` port indicates the readiness of the downstream logic to accept data from the FIFO.<br><br>**Interaction**: Users or other modules assert `pop_ready` to signal that they are ready to receive data from the FIFO. This interaction is crucial for controlling the flow of data out of the FIFO.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `pop_ready` is asserted (logic high), it indicates that the downstream logic can accept data. If `pop_valid` is also asserted, data (`pop_data`) is transferred from the FIFO to the downstream logic.<br>&nbsp;&nbsp;- If `pop_ready` is deasserted (logic low), the FIFO will not transfer data, even if `pop_valid` is asserted, effectively stalling the data transfer until `pop_ready` is asserted again.<br>&nbsp;&nbsp;- For example, if `pop_ready` is high and `pop_valid` is high, data is successfully popped from the FIFO. If `pop_ready` is low, no data is transferred regardless of the state of `pop_valid`.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The interaction between `pop_ready` and `pop_valid` is crucial for maintaining data integrity and flow control. The FIFO will only decrement its internal count of items (`items`) when both signals are high, ensuring that data is only removed from the FIFO when it is successfully transferred.<br>&nbsp;&nbsp;- The assertion of `pop_ready` can influence the `empty` and `empty_next` signals, as it affects whether data is removed from the FIFO, potentially transitioning it from a non-empty to an empty state.                                                                                                           |
| ram_rd_data_valid | **Type:** `logic`.<br><br> **Purpose**: The `ram_rd_data_valid` port indicates the validity of the data being read from the RAM, signaling when the data on the `ram_rd_data` port is ready to be used.<br><br>**Interaction**: Users or other modules interact with the `ram_rd_data_valid` port by monitoring its state to determine when the data from the RAM is available and valid for processing. This port is typically used in conjunction with the `ram_rd_data` port to ensure that the data being read is correctly synchronized with the rest of the system.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ram_rd_data_valid` is asserted (logic high), it indicates that the data on `ram_rd_data` is valid and can be used by the receiving logic.<br>&nbsp;&nbsp;- If `ram_rd_data_valid` is not asserted (logic low), the data on `ram_rd_data` should not be considered valid, and any logic dependent on this data should wait until `ram_rd_data_valid` is asserted.<br>&nbsp;&nbsp;- For example, if a read request is made by asserting `ram_rd_addr_valid`, `ram_rd_data_valid` will be asserted after a delay determined by `RamReadLatency`, indicating the data is ready.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The timing of `ram_rd_data_valid` is crucial for maintaining data integrity and synchronization within the FIFO controller. It ensures that data is only processed when it is correctly available, preventing potential errors from using stale or invalid data.<br>&nbsp;&nbsp;- The behavior of `ram_rd_data_valid` is particularly important when `RamReadLatency` is greater than zero, as it ensures that the system accounts for the delay in data availability. |
| ram_rd_data       | **Type:** `logic[    Width-1:0]`.<br><br> **Purpose**: The `ram_rd_data` port is used to receive data from the external RAM module after a read operation is initiated.<br><br>**Interaction**: Users or other modules interact with the `ram_rd_data` port by monitoring it to capture the data output from the RAM. This interaction typically occurs after a read request is made by asserting `ram_rd_addr_valid`.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ram_rd_data_valid` is asserted, the `ram_rd_data` port holds valid data read from the RAM at the address specified by `ram_rd_addr`.<br>&nbsp;&nbsp;- The data width is determined by the `Width` parameter, meaning it can hold a value ranging from 0 to \(2^{\text{Width}} - 1\).<br>&nbsp;&nbsp;- For example, if `Width` is set to 8, `ram_rd_data` can hold values from 0 to 255.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The timing of valid data on `ram_rd_data` is influenced by the `RamReadLatency` parameter. If `RamReadLatency` is greater than 0, there will be a delay of that many cycles between asserting `ram_rd_addr_valid` and receiving valid data on `ram_rd_data`.<br>&nbsp;&nbsp;- The design assumes a read-after-write hazard latency of 1 cycle, meaning if a write occurs to a specific address, a read to the same address can be initiated in the next cycle, and `ram_rd_data` will reflect the updated data.                                                                                                                                                                                                                                                                                               |

### Output Ports

| Name              | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| push_ready        | **Type:** `logic`.<br><br> **Purpose**: The `push_ready` port indicates whether the FIFO is ready to accept new data on the push interface.<br><br>**Interaction**: Users or other modules interact with the `push_ready` port by checking its value before attempting to send data to the FIFO. If `push_ready` is high, the module can assert `push_valid` and provide data on `push_data`.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `push_ready` = 0.<br>&nbsp;&nbsp;- When `push_ready` is high (1), the FIFO is ready to accept new data, and the user can assert `push_valid` with valid data on `push_data`.<br>&nbsp;&nbsp;- When `push_ready` is low (0), the FIFO is full or not ready to accept new data, and the user should not assert `push_valid`.<br>&nbsp;&nbsp;- If `full` is high, `push_ready` will be low, indicating that the FIFO cannot accept more data until space is available.<br>&nbsp;&nbsp;- When `pop_ready` is asserted and the FIFO is not full, `push_ready` will transition to high, allowing new data to be pushed.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `push_ready` signal is directly influenced by the `full` status of the FIFO. When `full` is asserted, `push_ready` will be deasserted, indicating backpressure.<br>&nbsp;&nbsp;- The behavior of `push_ready` can be affected by the `EnableBypass` parameter. If bypass is enabled, `push_ready` may be asserted even when the FIFO is not completely empty, allowing for zero-cycle cut-through latency.<br>&nbsp;&nbsp;- The `push_ready` signal is also involved in the backpressure mechanism, where it will be deasserted when the FIFO is full, preventing further data from being pushed until space is available. |
| pop_valid         | **Type:** `logic`.<br><br> **Purpose**: `pop_valid` indicates when valid data is available at the `pop_data` output for consumption by the downstream logic.<br><br>**Interaction**: Users or other modules monitor `pop_valid` to determine when they can safely read data from `pop_data`. When `pop_valid` is asserted, it signifies that the data on `pop_data` is valid and ready to be used.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `pop_valid` = 0.<br>&nbsp;&nbsp;- When `pop_ready` is asserted and the FIFO is not empty (`empty` = 0), `pop_valid` will be asserted, indicating that valid data is available on `pop_data`.<br>&nbsp;&nbsp;- If the FIFO is empty (`empty` = 1), `pop_valid` will be deasserted, indicating no valid data is available.<br>&nbsp;&nbsp;- In bypass mode (`EnableBypass` = 1), `pop_valid` can be asserted immediately if `push_valid` is asserted and the FIFO is empty, allowing for zero-cycle latency.<br>&nbsp;&nbsp;- When bypass is disabled, `pop_valid` will only be asserted after data has been read from the RAM, introducing a latency of `1 + RamReadLatency` cycles.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- In scenarios where `EnableBypass` is enabled, `pop_valid` can be asserted in the same cycle as `push_valid` if the FIFO is empty, allowing for immediate data availability.<br>&nbsp;&nbsp;- The assertion of `pop_valid` is dependent on the FIFO's internal state and the `pop_ready` signal, which can introduce variability in when `pop_valid` is asserted based on the FIFO's configuration and current state.                                                                                                                                    |
| pop_data          | **Type:** `logic[Width-1:0]`.<br><br> **Purpose**: `pop_data` is used to output the data from the FIFO when a pop operation is performed.<br><br>**Interaction**: Users or other modules interact with `pop_data` by reading the data that is available when `pop_valid` is asserted. This indicates that valid data is present on the `pop_data` port and can be consumed by the receiving logic.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `pop_valid` is high and `pop_ready` is asserted, `pop_data` presents the data that is being popped from the FIFO.<br>&nbsp;&nbsp;- If the FIFO is empty (`empty` is high), `pop_valid` will be low, and `pop_data` will not hold valid data.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `pop_data` is not explicitly assigned a value, so it defaults to 0.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- If `EnableBypass` is set to 1 and the FIFO is empty, `pop_data` can directly reflect `push_data` when `push_valid` is asserted, allowing for zero-cycle latency in data transfer.<br>&nbsp;&nbsp;- When `RegisterPopOutputs` is enabled, `pop_data` is registered, adding an additional cycle of latency but potentially improving timing closure.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| full              | **Type:** `logic`.<br><br> **Purpose**: The `full` port indicates whether the FIFO is currently full, meaning it cannot accept any more data until some data is removed.<br><br>**Interaction**: Users or other modules monitor the `full` signal to determine if they can safely push new data into the FIFO. If `full` is asserted (logic high), the FIFO is full, and no new data should be pushed.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `full = 0`, indicating the FIFO is not full.<br>&nbsp;&nbsp;- When `full = 1`, the FIFO has reached its maximum capacity, and `push_ready` will be deasserted, preventing new data from being pushed.<br>&nbsp;&nbsp;- When `full = 0`, the FIFO has space available, and `push_ready` will be asserted, allowing new data to be pushed.<br>&nbsp;&nbsp;- The transition of `full` from 0 to 1 occurs when the number of items in the FIFO reaches `Depth`.<br>&nbsp;&nbsp;- The transition of `full` from 1 to 0 occurs when an item is popped from the FIFO, creating space for new data.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- If `EnableBypass` is set to 1, the FIFO can temporarily bypass the RAM, potentially affecting the timing of when `full` is asserted or deasserted.<br>&nbsp;&nbsp;- The `full` signal is closely related to the `slots` and `items` signals, as `full` is asserted when `slots` equals 0 and `items` equals `Depth`.                                                                                                                                                                                                                                                                                                                    |
| full_next         | **Type:** `logic`.<br><br> **Purpose**: The `full_next` port indicates whether the FIFO will be full in the next clock cycle based on the current operations.<br><br>**Interaction**: Users or other modules can monitor the `full_next` signal to anticipate when the FIFO will be full, allowing them to manage data flow and avoid overflow conditions.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `full_next` = 0, indicating that the FIFO is not expected to be full immediately after reset.<br>&nbsp;&nbsp;- When `push_valid` is asserted and `push_ready` is deasserted, `full_next` will be set to 1, indicating that the FIFO will be full in the next cycle if no pop operation occurs.<br>&nbsp;&nbsp;- If `pop_ready` is asserted and `pop_valid` is deasserted, `full_next` will be set to 0, indicating that the FIFO will not be full in the next cycle.<br>&nbsp;&nbsp;- The value of `full_next` is updated based on the current state of the FIFO and the operations being performed (push or pop).<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- `full_next` provides a predictive indication of the FIFO's state, allowing for proactive management of data flow.<br>&nbsp;&nbsp;- The behavior of `full_next` is influenced by the parameters `Depth`, `EnableBypass`, and `RamReadLatency`, which determine the FIFO's capacity and latency characteristics.                                                                                                                                                                                                                                                                                                                                               |
| slots             | **Type:** `logic[CountWidth-1:0]`.<br><br> **Purpose**: The `slots` port indicates the number of available slots in the FIFO for new data entries.<br><br>**Interaction**: Users or other modules can monitor the `slots` port to determine how many additional data entries can be pushed into the FIFO without causing overflow.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `slots` = `Depth`, indicating that the FIFO is empty and all slots are available.<br>&nbsp;&nbsp;- When `push_valid` is asserted and `push_ready` is high, a data entry is pushed into the FIFO, decreasing the `slots` count by one.<br>&nbsp;&nbsp;- When `pop_ready` is asserted and `pop_valid` is high, a data entry is removed from the FIFO, increasing the `slots` count by one.<br>&nbsp;&nbsp;- The sum of `slots` and `items` should always equal `Depth`, ensuring consistency in the FIFO's capacity tracking.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- If the FIFO is full (`full` is high), `slots` will be zero, indicating no available slots for new data.<br>&nbsp;&nbsp;- If the FIFO is empty (`empty` is high), `slots` will equal `Depth`, indicating all slots are available for new data.<br>&nbsp;&nbsp;- The `slots` value dynamically adjusts based on the FIFO's push and pop operations, providing real-time feedback on available capacity.                                                                                                                                                                                                                                                                                                                                                                       |
| slots_next        | **Type:** `logic[CountWidth-1:0]`.<br><br> **Purpose**: `slots_next` indicates the number of available slots in the FIFO for new data entries in the next clock cycle.<br><br>**Interaction**: Users or other modules can monitor `slots_next` to determine how many new data entries can be pushed into the FIFO in the upcoming cycle. This information is crucial for managing data flow and preventing overflow.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `slots_next` = `Depth`, indicating all slots are available.<br>&nbsp;&nbsp;- When `push_valid` is asserted and `push_ready` is high, `slots_next` decreases by one, reflecting the addition of a new data entry.<br>&nbsp;&nbsp;- When `pop_ready` is asserted and `pop_valid` is high, `slots_next` increases by one, as a data entry is removed from the FIFO.<br>&nbsp;&nbsp;- If both `push_valid` and `pop_ready` are asserted simultaneously, `slots_next` remains unchanged, as one entry is added and one is removed.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- When the FIFO is full (`full` is high), `slots_next` will be zero, indicating no available slots for new entries.<br>&nbsp;&nbsp;- Conversely, when the FIFO is empty (`empty` is high), `slots_next` will equal `Depth`, indicating all slots are available.<br>&nbsp;&nbsp;- The value of `slots_next` can be used to predict potential backpressure scenarios, especially when `EnableCoverPushBackpressure` is enabled, ensuring efficient data management.                                                                                                                                                                                                                         |
| empty             | **Type:** `logic`.<br><br> **Purpose**: The `empty` port indicates whether the FIFO is currently empty, meaning there are no items available for reading.<br><br>**Interaction**: Users or other modules can monitor the `empty` port to determine if there are any items in the FIFO to be read. This signal can be used to control read operations or to trigger other processes when the FIFO becomes empty.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `empty` is high (1), it signifies that the FIFO contains no items, and `pop_valid` will be low (0), indicating that no valid data is available to be popped.<br>&nbsp;&nbsp;- When `empty` is low (0), it indicates that there are items in the FIFO, and `pop_valid` may be high (1) if `pop_ready` is also high, allowing data to be read.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `empty` = 1, indicating the FIFO starts in an empty state.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- If `push_valid` is asserted and `push_ready` is high, the FIFO will accept new data, potentially causing `empty` to transition from high to low if it was previously empty.<br>&nbsp;&nbsp;- Conversely, if `pop_ready` is asserted and `pop_valid` is high, data is read from the FIFO, which may cause `empty` to transition from low to high if the last item is read.<br>&nbsp;&nbsp;- The `empty` signal is directly influenced by the `push_valid` and `pop_ready` interactions, reflecting the real-time status of the FIFO's content.                                                                                                                                                                                                                                                    |
| empty_next        | **Type:** `logic`.<br><br> **Purpose**: The `empty_next` port indicates whether the FIFO will be empty in the next clock cycle.<br><br>**Interaction**: Users or other modules can monitor the `empty_next` signal to anticipate when the FIFO will be empty in the subsequent cycle, allowing them to manage data flow and control logic accordingly.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `empty_next` is asserted (logic high), it signifies that the FIFO will be empty in the next clock cycle.<br>&nbsp;&nbsp;- When `empty_next` is deasserted (logic low), it indicates that the FIFO will have at least one item in the next cycle.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `empty_next` = 1, indicating that the FIFO will be empty immediately after reset.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `empty_next` signal can be used in conjunction with `pop_ready` and `pop_valid` to optimize data retrieval strategies, especially in systems where minimizing latency is crucial.<br>&nbsp;&nbsp;- The behavior of `empty_next` is influenced by the `pop_ready` and `pop_valid` signals, as well as the internal state of the FIFO, such as `items` and `items_next`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| items             | **Type:** `logic[CountWidth-1:0]`.<br><br> **Purpose**: The `items` port indicates the current number of valid data entries stored in the FIFO.<br><br>**Interaction**: Users or other modules can monitor the `items` port to determine how many entries are currently stored in the FIFO, which can be useful for managing data flow and preventing overflow or underflow conditions.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- Reset Value: Upon reset, `items` = 0, indicating the FIFO is empty.<br>&nbsp;&nbsp;- When `push_valid` is asserted and `push_ready` is high, the `items` count increases by 1, reflecting the addition of a new entry.<br>&nbsp;&nbsp;- When `pop_ready` is asserted and `pop_valid` is high, the `items` count decreases by 1, reflecting the removal of an entry.<br>&nbsp;&nbsp;- The `items` value ranges from 0 to `Depth`, where `Depth` is the maximum number of entries the FIFO can hold.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- If `EnableBypass` is set to 1, the `items` count may not immediately reflect a push operation if the FIFO is empty and the data bypasses directly to the pop interface.<br>&nbsp;&nbsp;- The `items` port provides a real-time count of the FIFO's occupancy, which can be used to dynamically adjust the flow of data into and out of the FIFO based on system requirements.                                                                                                                                                                                                                                                                                                                                                                                                |
| items_next        | **Type:** `logic[CountWidth-1:0]`.<br><br> **Purpose**: `items_next` indicates the number of items that will be in the FIFO in the next clock cycle.<br><br>**Interaction**: Users or other modules can monitor `items_next` to anticipate the FIFO's occupancy in the upcoming cycle, which can be useful for managing data flow and preventing overflow or underflow conditions.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- **Reset Value**: Upon reset, `items_next` = 0, indicating the FIFO is empty.<br>&nbsp;&nbsp;- When `push_valid` is asserted and `push_ready` is high, `items_next` increases by 1, reflecting an incoming data item.<br>&nbsp;&nbsp;- When `pop_ready` is asserted and `pop_valid` is high, `items_next` decreases by 1, reflecting a data item being removed.<br>&nbsp;&nbsp;- If both `push_valid` and `pop_ready` are asserted simultaneously, `items_next` remains unchanged, as one item is added and one is removed concurrently.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- `items_next` helps in predicting FIFO status, which is crucial for systems requiring precise control over data flow, especially in scenarios with variable data rates.<br>&nbsp;&nbsp;- The value of `items_next` can be used to determine when the FIFO is approaching full or empty states, allowing for preemptive actions to manage data flow efficiently.                                                                                                                                                                                                                                                                                                                                                                               |
| ram_wr_valid      | **Type:** `logic`.<br><br> **Purpose**: `ram_wr_valid` indicates when a write operation to the external RAM should be performed.<br><br>**Interaction**: Users or other modules monitor `ram_wr_valid` to determine when to write data to the RAM. It is typically used in conjunction with `ram_wr_addr` and `ram_wr_data` to specify the address and data for the write operation.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ram_wr_valid` is asserted (logic high), it signals that the data on `ram_wr_data` should be written to the address specified by `ram_wr_addr`.<br>&nbsp;&nbsp;- The assertion of `ram_wr_valid` is dependent on the internal logic of the FIFO controller, which manages the flow of data based on the FIFO's state (e.g., `full`, `empty`).<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ram_wr_valid` = 0, indicating no write operations are initiated during reset.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- `ram_wr_valid` may be asserted in response to `push_valid` when the FIFO is not full, allowing new data to be written to the RAM.<br>&nbsp;&nbsp;- The behavior of `ram_wr_valid` can be influenced by the `EnableBypass` parameter. If bypass is enabled, `ram_wr_valid` might be asserted less frequently when the FIFO is empty, as data can be directly forwarded to the pop interface.<br>&nbsp;&nbsp;- The timing of `ram_wr_valid` assertions is crucial for maintaining data integrity and ensuring that write operations do not conflict with read operations, especially considering the `RamReadLatency` parameter.                                                                                                                                                                         |
| ram_wr_addr       | **Type:** `logic[AddrWidth-1:0]`.<br><br> **Purpose**: `ram_wr_addr` specifies the address in the external RAM where data will be written.<br><br>**Interaction**: Users or other modules interact with `ram_wr_addr` by monitoring it to determine where the next data write operation will occur in the RAM. It is driven by the FIFO controller to coordinate data storage.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ram_wr_valid` is asserted, `ram_wr_addr` holds the address for the data being written, as specified by `ram_wr_data`.<br>&nbsp;&nbsp;- The address is determined based on the current state of the FIFO, including the number of items and available slots.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ram_wr_addr` is typically set to 0, indicating the starting address for write operations.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The value of `ram_wr_addr` is influenced by the FIFO's depth and the current number of items (`items`) and slots (`slots`), ensuring efficient use of RAM space.<br>&nbsp;&nbsp;- In scenarios where `EnableBypass` is active, `ram_wr_addr` may be updated less frequently, as data can bypass the RAM under certain conditions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ram_wr_data       | **Type:** `logic[    Width-1:0]`.<br><br> **Purpose**: `ram_wr_data` is used to transfer data from the FIFO controller to the external RAM module during write operations.<br><br>**Interaction**: Users or other modules interact with `ram_wr_data` by monitoring its value when `ram_wr_valid` is asserted. This indicates that the data on `ram_wr_data` should be written to the address specified by `ram_wr_addr`.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `push_valid` is asserted and the FIFO is not full (`full` is low), `ram_wr_data` captures the value of `push_data` to be written to the RAM.<br>&nbsp;&nbsp;- `ram_wr_data` is valid when `ram_wr_valid` is high, indicating that the data should be written to the RAM at the address specified by `ram_wr_addr`.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ram_wr_data` = 0, as it is not assigned a specific value during reset.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- If `EnableBypass` is set to 1, `ram_wr_data` may not always be used immediately for writing to RAM, as data can bypass directly to the pop interface when the FIFO is empty.<br>&nbsp;&nbsp;- The value of `ram_wr_data` is directly influenced by `push_data` when a push operation is valid and accepted by the FIFO, reflecting the data flow from the push interface to the RAM.                                                                                                                                                                                                                                                                                                                                                                                                                |
| ram_rd_addr_valid | **Type:** `logic`.<br><br> **Purpose**: `ram_rd_addr_valid` is used to indicate when a read address is valid and ready to be sent to the RAM for reading data.<br><br>**Interaction**: Users or other modules interact with `ram_rd_addr_valid` by monitoring its signal to determine when a read operation should be initiated on the RAM. It acts as a handshake signal to ensure that the read address being sent is valid and can be processed by the RAM.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ram_rd_addr_valid` is asserted (set to 1), it signifies that the address on `ram_rd_addr` is valid and the RAM should perform a read operation.<br>&nbsp;&nbsp;- If `ram_rd_addr_valid` is deasserted (set to 0), it indicates that no valid read address is being presented, and the RAM should not perform a read operation.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ram_rd_addr_valid` = 0, ensuring no read operations are initiated inadvertently during reset.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The assertion of `ram_rd_addr_valid` is typically synchronized with the `clk` signal to ensure proper timing and coordination with the RAM's read operations.<br>&nbsp;&nbsp;- The behavior of `ram_rd_addr_valid` can be influenced by parameters such as `RamReadLatency`, which may affect when the signal is asserted relative to other operations in the FIFO controller.                                                                                                                                                                                                                                                                                                                                             |
| ram_rd_addr       | **Type:** `logic[AddrWidth-1:0]`.<br><br> **Purpose**: The `ram_rd_addr` port is used to specify the address in the RAM from which data should be read.<br><br>**Interaction**: Users or other modules interact with the `ram_rd_addr` port by providing an address value when they want to read data from the RAM. This address is used in conjunction with the `ram_rd_addr_valid` signal to initiate a read operation.<br><br>**Expected Behavior**:<br>&nbsp;&nbsp;- When `ram_rd_addr_valid` is asserted, the value on `ram_rd_addr` specifies the address in the RAM from which data will be read.<br>&nbsp;&nbsp;- The data at the specified address will be available on the `ram_rd_data` port after a delay defined by `RamReadLatency`.<br>&nbsp;&nbsp;- Reset Value: Upon reset, `ram_rd_addr` is set to 0, ensuring no unintended read operations occur until explicitly set by the user.<br><br>**Interesting Behavior**:<br>&nbsp;&nbsp;- The `ram_rd_addr` port works in tandem with `ram_rd_addr_valid` to ensure that read operations are only initiated when valid addresses are provided.<br>&nbsp;&nbsp;- The address width is determined by the `AddrWidth` parameter, which is calculated based on the `RamDepth`, allowing flexibility in the size of the addressable RAM space.                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

### Design Parameters

| Name                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Depth                          | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `Depth` parameter defines the number of entries the FIFO can hold. It determines the maximum number of data items that can be stored in the FIFO at any given time. Users interact with the design by pushing data into the FIFO when `push_valid` is asserted and retrieving data when `pop_ready` is asserted. The `Depth` parameter affects the behavior of signals such as `full`, `empty`, `items`, and `slots`, which indicate the current status of the FIFO. For example, when the FIFO reaches its maximum capacity, indicated by `full`, no additional data can be pushed until space is freed by popping data. Conversely, when the FIFO is empty, indicated by `empty`, no data is available to pop. The parameter ensures that the FIFO can handle the required data throughput and storage needs of the application. |
| Width                          | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `Width` parameter defines the bit-width of each data entry within the FIFO. It determines the size of the data that can be pushed into the FIFO via `push_data` and subsequently popped out through `pop_data`. Users interact with the design by providing data of this specified width when asserting `push_valid`, and they receive data of the same width when `pop_valid` is asserted. The parameter ensures that the FIFO can handle data entries of varying sizes, allowing for flexibility in accommodating different data widths as required by specific applications.                                                                                                                                                                                                                                                    |
| EnableBypass                   | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableBypass` parameter determines whether the FIFO controller allows data to bypass the RAM when the FIFO is empty, thereby reducing latency. When enabled, data can move directly from the `push_valid` and `push_data` inputs to the `pop_valid` and `pop_data` outputs without waiting for RAM access, achieving zero-cycle latency. This is beneficial for designs prioritizing low latency over timing constraints. Conversely, when disabled, data must pass through the RAM, introducing a delay but improving timing by eliminating direct combinational paths between the push and pop interfaces. This configuration is useful in scenarios where meeting timing constraints is critical.                                                                                                                              |
| RegisterPopOutputs             | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `RegisterPopOutputs` parameter is used to control the timing characteristics of the FIFO's pop interface. When enabled, it ensures that the `pop_valid` and `pop_data` signals are always driven from a register, which can improve the timing of paths dependent on these signals. This comes at the cost of an additional cycle of latency for data to propagate from the push to the pop interface. Users can interact with this parameter to optimize the design for either lower latency or better timing closure, depending on their specific application requirements. For example, enabling this parameter can be beneficial in scenarios where the design needs to meet stringent timing constraints, while disabling it might be preferred in latency-sensitive applications.                                            |
| RamReadLatency                 | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `RamReadLatency` parameter specifies the number of clock cycles between asserting `ram_rd_addr_valid` and receiving valid data on `ram_rd_data`. It defines the read latency of the external RAM interfaced with the FIFO controller. This parameter allows the FIFO to accommodate RAMs with varying read latencies, ensuring that the `pop_valid` and `pop_data` signals are synchronized with the RAM's data availability. Users can adjust this parameter to match the specific latency characteristics of their RAM, ensuring correct data retrieval timing. For example, if the RAM takes two cycles to provide data after a read request, `RamReadLatency` should be set accordingly to maintain proper FIFO operation.                                                                                                     |
| RamDepth                       | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>The `RamDepth` parameter defines the actual depth of the RAM used in the FIFO controller. It determines how many entries the RAM can store, which may differ from the FIFO's logical depth (`Depth`). This parameter allows flexibility in RAM sizing, accommodating scenarios where the RAM depth might be smaller due to bypassing or larger due to practical considerations like available RAM sizes. Users can adjust `RamDepth` to optimize for performance or resource constraints, ensuring the FIFO operates efficiently within the given hardware limitations.                                                                                                                                                                                                                                                                |
| EnableCoverPushBackpressure    | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableCoverPushBackpressure` parameter is used to control the coverage of backpressure scenarios on the push side of the FIFO. When enabled, it ensures that the design accounts for situations where the push interface experiences backpressure, meaning the FIFO cannot accept new data because it is full or nearly full. This parameter is crucial for verifying that the FIFO can handle such conditions correctly. Users can interact with this parameter to ensure that the design is robust against backpressure, which is a common scenario in high-throughput systems. By enabling this parameter, users can validate that the FIFO's behavior under backpressure is covered during testing, ensuring reliable operation in real-world applications.                                                                   |
| EnableAssertPushValidStability | **Type:** `bit`.<br><br> **Purpose of the Parameter**:<br>The `EnableAssertPushValidStability` parameter is used to control the assertion behavior related to the stability of the `push_valid` signal during backpressure conditions. When enabled, it ensures that the `push_valid` signal remains stable (i.e., does not change) when the FIFO is experiencing backpressure, which occurs when the FIFO is full and cannot accept new data. This parameter is particularly useful for verifying the robustness of the design in scenarios where the `push_valid` signal might fluctuate due to external conditions. By asserting stability, it helps in identifying potential issues in the data flow and ensures that the design behaves predictably under backpressure.                                                                                                                      |
| EnableAssertPushDataStability  | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableAssertPushDataStability` parameter is used to control the stability of the `push_data` signal when the FIFO experiences backpressure. When enabled, it ensures that `push_data` remains stable during cycles where the FIFO cannot accept new data due to being full or other constraints. This is particularly important for maintaining data integrity in scenarios where the FIFO is not ready to accept new entries. For example, if the FIFO is full (`full` signal is asserted), and `push_valid` is asserted, `push_data` should not change until the FIFO can accept new data. This parameter is crucial for designs where data consistency is critical during backpressure conditions.                                                                                                                             |
| EnableAssertFinalNotValid      | **Type:** `bit`.<br><br> **Purpose of the Parameter**: <br>The `EnableAssertFinalNotValid` parameter is used to enforce a condition at the end of a test scenario where the FIFO should be empty and no valid signals are asserted. When enabled, it ensures that the FIFO controller asserts a check to confirm that all entries have been processed and the FIFO is in an idle state. This parameter is particularly useful for verifying that the FIFO has correctly handled all data transactions and that no residual data remains in the system. Users can interact with this parameter to validate the integrity and correctness of the FIFO's operation in test environments, ensuring that the design meets expected functional requirements.                                                                                                                                            |
| AddrWidth                      | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`AddrWidth` determines the bit-width required to address the RAM depth in the FIFO controller. It is calculated based on the `RamDepth` parameter, ensuring that the address lines can uniquely identify each storage location within the RAM. This parameter is crucial for defining the size of the address bus used in the RAM interface, allowing users to configure the FIFO to accommodate varying depths of RAM while maintaining efficient addressability.                                                                                                                                                                                                                                                                                                                                                                     |
| CountWidth                     | **Type:** `int`.<br><br> **Purpose of the Parameter**: <br>`CountWidth` determines the bit-width required to represent the count of items or slots in the FIFO. It is calculated based on the `Depth` parameter, which defines the maximum number of entries the FIFO can hold. This parameter ensures that the design can accurately track the number of items currently stored in the FIFO and the available slots for new entries. Users interact with this parameter indirectly through signals like `items`, `items_next`, `slots`, and `slots_next`, which utilize `CountWidth` to manage and report the FIFO's status. For example, if the FIFO is configured with a certain depth, `CountWidth` ensures that the design can handle the full range of possible counts, from empty to full, without overflow.                                                                               |

### Basic Functionality

| Function                                 | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Push Data Handling                       | Description: Manages the flow of data into the FIFO, ensuring data is only pushed when there is space available, using the `push_valid`, `push_ready`, and `full` signals.<br>Input Signals: push_valid, push_data<br>Output Signals: push_ready, ram_wr_valid, ram_wr_addr, ram_wr_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that data is ready to be pushed into the FIFO.<br>2. The testbench provides data on `push_data`.<br>3. The design checks if `full` is deasserted, indicating that there is space available in the FIFO.<br>4. If `full` is deasserted, the design asserts `push_ready` to accept the data.<br>5. The design asserts `ram_wr_valid` to indicate a valid write operation to RAM.<br>6. The design calculates the next write address and provides it on `ram_wr_addr`.<br>7. The design writes the data from `push_data` to `ram_wr_data`.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Backpressure Management                  | Description: Handles backpressure scenarios by deasserting `push_ready` when the FIFO is full, preventing further data from being pushed.<br>Input Signals: push_valid<br>Output Signals: push_ready<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate that data is ready to be pushed into the FIFO.<br>2. The design monitors `full` to determine if the FIFO is full.<br>3. If `full` is asserted, the design deasserts `push_ready` to prevent further data from being pushed.<br>4. The testbench observes `push_ready` to ensure it is deasserted, confirming backpressure handling.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Bypass Path Activation                   | Description: Activates the bypass path when the FIFO is full and RAM is not ready to accept data, ensuring data is not lost.<br>Input Signals: push_valid<br>Output Signals: bypass_valid_unstable<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate data is ready to be pushed.<br>2. The design checks if `full` is asserted, indicating RAM is not ready to accept data.<br>3. The design checks if `bypass_ready` is deasserted, indicating the bypass path should be activated.<br>4. The design asserts `bypass_valid_unstable` to indicate the bypass path is active.<br>5. The testbench monitors `bypass_valid_unstable` to ensure it is asserted when the bypass path is active.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| RAM Write Address Calculation            | Description: Calculates the address for writing data into RAM, ensuring the address is correctly incremented and wraps around if necessary.<br>Input Signals: push_valid<br>Output Signals: ram_wr_addr, ram_wr_valid<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate data is ready to be written to RAM.<br>2. The design checks if `full` is deasserted, indicating space is available in RAM.<br>3. If space is available, the design asserts `ram_wr_valid` to indicate a valid write operation.<br>4. The design calculates the next `ram_wr_addr` based on the current address and increments it.<br>5. If the incremented address exceeds the maximum depth, the design wraps `ram_wr_addr` around to zero.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Pop Data Handling                        | Description: Manages the flow of data from the FIFO, ensuring data is only popped when the FIFO is not empty and `pop_ready` is asserted.<br>Input Signals: pop_ready, empty, ram_rd_data_valid, ram_rd_data<br>Output Signals: pop_valid, pop_data, empty_next, items, items_next<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `pop_ready` to indicate readiness to receive data.<br>2. The design checks if `empty` is deasserted, indicating that the FIFO is not empty.<br>3. If the FIFO is not empty, the design asserts `pop_valid` to indicate valid data is available for popping.<br>4. The design provides the data on `pop_data` from either the RAM or bypass path, depending on the configuration.<br>5. The testbench monitors `pop_valid` and reads the data from `pop_data` when `pop_valid` is asserted.<br>6. The design updates `items` to reflect the new count of items in the FIFO.<br>7. The design updates `empty_next` to reflect the FIFO's empty status for the next cycle.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| RAM Read Address Handling                | Description: Generates and manages the read address for the RAM when data is being popped, ensuring sequential access to the RAM.<br>Input Signals: pop_ready, ram_rd_data_valid<br>Output Signals: ram_rd_addr_valid, ram_rd_addr<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `pop_ready` to indicate readiness to pop data.<br>2. The design checks if `ram_rd_data_valid` is asserted, indicating valid data is available for reading.<br>3. If `ram_rd_data_valid` is asserted, the design asserts `ram_rd_addr_valid` to indicate a valid read address is being generated.<br>4. The design increments the `ram_rd_addr` to point to the next data location in RAM.<br>5. The testbench monitors `ram_rd_addr` to ensure it reflects the correct sequential address for reading.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Data Path Selection                      | Description: Selects between RAM data and bypass data based on the FIFO's empty status and the `bypass_valid_unstable` signal, ensuring the correct data is output on `pop_data`.<br>Input Signals: empty, bypass_valid_unstable, ram_rd_data<br>Output Signals: pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench monitors `empty` to determine if the FIFO is empty.<br>2. If `empty` is asserted, the testbench checks `bypass_valid_unstable` to see if bypass data is available.<br>3. If `bypass_valid_unstable` is asserted, the design outputs `bypass_data_unstable` on `pop_data`.<br>4. If `empty` is deasserted, the design outputs `ram_rd_data` on `pop_data`.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| RAM Write Data Handling                  | Description: Coordinates the writing of data into the external RAM, ensuring data integrity and proper synchronization with the FIFO operations.<br>Input Signals: push_valid, push_data, ram_wr_valid<br>Output Signals: ram_wr_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate data is ready to be written to RAM.<br>2. The design checks if `ram_wr_valid` is asserted, indicating a valid write operation is in progress.<br>3. If `ram_wr_valid` is asserted, the design outputs the data from `push_data` to `ram_wr_data`.<br>4. The testbench monitors `ram_wr_data` to ensure it matches the expected data, confirming data integrity.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| RAM Read Data Handling                   | Description: Manages the retrieval of data from the external RAM, ensuring data is correctly read and synchronized with the FIFO operations.<br>Input Signals: ram_rd_data_valid, ram_rd_data<br>Output Signals: pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `ram_rd_data_valid` to indicate valid data is available for reading from RAM.<br>2. The design checks if `ram_rd_data_valid` is asserted, confirming the availability of data.<br>3. If `ram_rd_data_valid` is asserted, the design outputs the data from `ram_rd_data` to `pop_data`.<br>4. The testbench monitors `pop_data` to ensure it matches the expected data, confirming data integrity.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| FIFO Status Flag Update                  | Description: The purpose of this functionality is to update the status flags of the FIFO, reflecting the current state of the FIFO in terms of fullness, emptiness, and the number of slots and items available.<br>Input Signals: push_valid, pop_ready<br>Output Signals: full, full_next, empty, empty_next, slots, slots_next, items, items_next<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate data is ready to be pushed into the FIFO.<br>2. The design calculates `slots_next` based on the current `slots` and the push operation.<br>3. The design updates `slots` to `slots_next` on the next clock cycle.<br>4. The design checks if `slots_next` equals zero, indicating the FIFO is full, and asserts `full_next`.<br>5. The design updates `full` to `full_next` on the next clock cycle.<br>6. The testbench monitors `full` to determine if the FIFO is full.<br><br><br><br>Transaction 2:<br>1. The testbench asserts `pop_ready` to indicate data is ready to be popped from the FIFO.<br>2. The design calculates `items_next` based on the current `items` and the pop operation.<br>3. The design updates `items` to `items_next` on the next clock cycle.<br>4. The design checks if `items_next` equals zero, indicating the FIFO is empty, and asserts `empty_next`.<br>5. The design updates `empty` to `empty_next` on the next clock cycle.<br>6. The testbench monitors `empty` to determine if the FIFO is empty.<br> |
| FIFO Status Consistency Check            | Description: The purpose of this functionality is to ensure the consistency of the FIFO status flags, verifying that the sum of items and slots equals the FIFO depth.<br>Input Signals: <br>Output Signals: slots, items<br><br>Transactions:<br><br>Transaction 1:<br>1. The design calculates the sum of `items` and `slots`.<br>2. The design checks if the sum equals the `Depth` parameter.<br>3. If the sum does not equal `Depth`, the design triggers an assertion failure.<br>4. The testbench monitors the assertion to ensure it does not fail, confirming status consistency.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Bypass Mode Data Transfer                | Description: Facilitates direct data transfer from the push interface to the pop interface when the FIFO is empty, optimizing latency by bypassing RAM storage.<br>Input Signals: push_valid, push_data, pop_ready, empty<br>Output Signals: pop_valid, pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` and provides data on `push_data`.<br>2. The design checks if `empty` is asserted, indicating the FIFO is empty.<br>3. The testbench asserts `pop_ready` to indicate readiness to receive data.<br>4. If both `push_valid` and `pop_ready` are asserted and `empty` is true, the design asserts `pop_valid`.<br>5. The design transfers data from `push_data` directly to `pop_data`.<br>6. The testbench monitors `pop_valid` and reads the data from `pop_data` when `pop_valid` is asserted.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Cut-Through Latency Management           | Description: Manages the cut-through latency of the FIFO by adjusting data flow based on the parameters `RamReadLatency` and `RegisterPopOutputs`. Ensures data is transferred efficiently with minimal delay.<br>Input Signals: push_valid, pop_ready, ram_rd_data_valid<br>Output Signals: pop_valid, pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate data is ready to be pushed into the FIFO.<br>2. The design checks if `pop_ready` is asserted, indicating readiness to pop data.<br>3. If `EnableBypass` is set and the FIFO is empty, the design immediately asserts `pop_valid`, allowing data to be transferred directly from `push_data` to `pop_data`.<br>4. If `RegisterPopOutputs` is enabled, the design introduces an additional cycle of latency before asserting `pop_valid`.<br>5. The testbench monitors `pop_valid` and reads the data from `pop_data` when `pop_valid` is asserted.<br>6. The design ensures that the latency between `push_valid` and `pop_valid` matches the expected cut-through latency based on the configuration.<br>                                                                                                                                                                                                                                                                                                                                                                            |
| Latency Adjustment with RAM Read Latency | Description: Adjusts the data flow based on the `RamReadLatency` parameter, ensuring that data is correctly staged and output with the appropriate delay.<br>Input Signals: ram_rd_data_valid, pop_ready<br>Output Signals: pop_valid, pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `pop_ready` to indicate readiness to pop data.<br>2. The design checks if `ram_rd_data_valid` is asserted, indicating valid data is available from RAM.<br>3. If `RamReadLatency` is greater than zero, the design stages the data internally before asserting `pop_valid`.<br>4. The design asserts `pop_valid` after the appropriate number of cycles, accounting for `RamReadLatency`.<br>5. The testbench monitors `pop_valid` and reads the data from `pop_data` when `pop_valid` is asserted.<br>6. The design ensures that the latency between `ram_rd_data_valid` and `pop_valid` matches the configured `RamReadLatency`.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Push Valid Stability Under Backpressure  | Description: Ensures that the `push_valid` signal remains stable when the FIFO is full, indicating backpressure and preventing data corruption.<br>Input Signals: push_valid, full<br>Output Signals: <br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate data is available.<br>2. The design asserts `full` to simulate a full FIFO condition.<br>3. The testbench monitors `push_valid` to ensure it remains asserted in the next cycle.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Push Data Stability Under Backpressure   | Description: Ensures that the `push_data` signal remains stable when the FIFO is full, indicating backpressure and preventing data corruption.<br>Input Signals: push_valid, push_data, full<br>Output Signals: <br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` and provides data on `push_data`.<br>2. The design asserts `full` to simulate a full FIFO condition.<br>3. The testbench monitors `push_data` to ensure it remains unchanged in subsequent cycles.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Backpressure Coverage                    | Description: Covers scenarios where backpressure is applied, ensuring the system can handle it without data loss or corruption.<br>Input Signals: push_valid, full<br>Output Signals: push_ready<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench asserts `push_valid` to indicate data is ready to be pushed.<br>2. The design monitors `full` to determine if the FIFO is full.<br>3. If `full` is asserted, the design deasserts `push_ready`, indicating it cannot accept more data.<br>4. The testbench observes `push_ready` to ensure it deasserts, confirming backpressure handling.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| FIFO Depth Configuration                 | Description: Adjusts the FIFO's behavior based on the `Depth` parameter, ensuring the FIFO can handle the specified number of entries.<br>Input Signals: push_valid, pop_ready<br>Output Signals: full, empty, slots, items<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench sets the `Depth` parameter to a specific value.<br>2. The design initializes the FIFO with the specified depth, adjusting internal counters accordingly.<br>3. The testbench asserts `push_valid` to fill the FIFO to its maximum capacity.<br>4. The design monitors `slots` to ensure it decreases with each push operation until it reaches zero.<br>5. The design asserts `full` when `slots` reaches zero, indicating the FIFO is full.<br>6. The testbench asserts `pop_ready` to begin emptying the FIFO.<br>7. The design monitors `items` to ensure it decreases with each pop operation until it reaches zero.<br>8. The design asserts `empty` when `items` reaches zero, indicating the FIFO is empty.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| FIFO Width Configuration                 | Description: Adjusts the FIFO's behavior based on the `Width` parameter, ensuring the FIFO can handle data of the specified bit width.<br>Input Signals: push_valid, push_data, pop_ready<br>Output Signals: pop_data<br><br>Transactions:<br><br>Transaction 1:<br>1. The testbench sets the `Width` parameter to a specific value.<br>2. The design initializes the FIFO with the specified width, adjusting internal data paths accordingly.<br>3. The testbench asserts `push_valid` and provides data on `push_data` with the specified width.<br>4. The design accepts the data and stores it internally, ensuring it matches the specified width.<br>5. The testbench asserts `pop_ready` to retrieve data from the FIFO.<br>6. The design outputs data on `pop_data` with the specified width, ensuring it matches the input data.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |

### End-to-End Functionality

| Function                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Data Transfer with Bypass Enabled  | This function allows for minimal latency data transfer by enabling bypass mode. When `EnableBypass` is set to 1, data can be directly transferred from `push_data` to `pop_data` if the FIFO is empty. By asserting `push_valid` and providing data on `push_data`, and if `pop_ready` is also asserted while the FIFO is empty (`empty` is asserted), `pop_valid` is immediately asserted. This results in a cut-through latency of zero cycles, making data instantly available at the pop interface. Users should monitor `pop_valid` and read data from `pop_data` when it is asserted.                                                                                                                                                |
| Data Transfer with Bypass Disabled | This function is used for data transfer with improved timing by disabling bypass mode. When `EnableBypass` is set to 0, data is always written to RAM before being available at the pop interface. By asserting `push_valid` and providing data on `push_data`, the design asserts `ram_wr_valid` and calculates the write address on `ram_wr_addr`, writing data to `ram_wr_data`. When `pop_ready` is asserted and the FIFO is not empty (`empty` is deasserted), `pop_valid` is asserted after a latency of 1 + `RamReadLatency` cycles. Data is then read from RAM and provided on `pop_data`. Users should monitor `pop_valid` and read data from `pop_data` when it is asserted, ensuring data integrity with a predictable latency. |
| FIFO Status Monitoring             | This function involves monitoring the FIFO status flags to manage data flow and prevent overflow or underflow. By continuously monitoring `full`, `empty`, `slots`, and `items`, users can determine the FIFO's current status. The `full` flag indicates that the FIFO cannot accept more data, while the `empty` flag indicates that no data is available for popping. The `slots` and `items` signals provide the number of available slots and items in the FIFO, respectively. The `full_next`, `empty_next`, `slots_next`, and `items_next` signals are used to predict the FIFO's status in the next cycle. Users should adjust data flow based on these flags to ensure efficient FIFO operation without data loss or corruption.  |
